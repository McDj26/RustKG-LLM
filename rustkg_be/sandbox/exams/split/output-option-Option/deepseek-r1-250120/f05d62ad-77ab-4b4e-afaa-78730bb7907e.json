{"create_time":"2025-03-22T15:11:17.615Z","id":"f05d62ad-77ab-4b4e-afaa-78730bb7907e","source_url":"file:///C:/Users/Dj/.rustup/toolchains/1.31-x86_64-pc-windows-msvc/share/doc/rust/html/std/option/enum.Option.html","relations":["has argument","has associated type","has declaration","has description","has documentation","has example","has experimental flag","has full name","has link","has method","has method implementation","has return type","has source","has stability","has trait bound","has type","has variant","implements","is a","is part of module","requires method","requires trait","stable since"],"add_triples":[["&'a Option<T>","has associated type","IntoIter"],["&'a Option<T>","has associated type","Item"],["&'a Option<T>","has method","into_iter"],["&'a Option<T>","implements","IntoIterator"],["&'a Option<T>","stable since","1.4.0"],["&'a mut Option<T>","has associated type","IntoIter"],["&'a mut Option<T>","has associated type","Item"],["&'a mut Option<T>","has method","into_iter"],["&'a mut Option<T>","implements","IntoIterator"],["&'a mut Option<T>::IntoIter","has type","IterMut<'a, T>"],["&'a mut Option<T>::Item","has type","&'a mut T"],["&'a mut Option<T>::into_iter","has description","Which kind of iterator are we turning this into?"],["&'a mut Option<T>::into_iter","has return type","IterMut<'a, T>"],["&'a mut Option<T>::into_iter","is a","method"],["&mut I","implements","Iterator"],["&mut R","implements","Read"],["&mut W","implements","Write"],["Any","has method","get_type_id"],["Any","requires trait","Sized"],["Borrow","has method","borrow"],["Borrow","requires method","borrow"],["BorrowMut","has method","borrow_mut"],["BorrowMut","requires trait","Sized"],["Clone","has full name","std::clone::Clone"],["Clone","has method","clone"],["Clone","has method","clone_from"],["Clone","is part of module","std::clone"],["D","implements","FnOnce() -> U"],["Error","has description","The type of this value when viewed as failed."],["Error","has stability","This is a nightly-only experimental API. (try_trait #42327)"],["Error","has type","NoneError"],["F","implements","FnOnce"],["F","implements","FnOnce(T) -> U"],["From","has method","from"],["From","is a","trait"],["From<&'a Option<T>>","requires method","from"],["From<&'a mut Option<T>>::from","has argument","o"],["From<&'a mut Option<T>>::from","has description","Performs the conversion."],["From<&'a mut Option<T>>::from","has return type","Option<&'a mut T>"],["From<T>::from","has argument","val"],["From<T>::from","has description","Performs the conversion."],["From<T>::from","has return type","Option<T>"],["I","implements","IntoIterator"],["Into","requires method","into"],["IntoIter","has description","An iterator over the value in Some variant of an Option."],["IntoIter","has type","std::option::IntoIter"],["IntoIter","has type","std::option::Iter"],["IntoIter","has type","std::option::IterMut"],["IntoIter","is a","struct"],["IntoIter<T>","has full name","std::option::IntoIter"],["IntoIterator","has associated type","IntoIter"],["IntoIterator","has associated type","Item"],["IntoIterator","has full name","std::iter::IntoIterator"],["IntoIterator","has method","into_iter"],["IntoIterator","is a","trait"],["IntoIterator","is part of module","std::iter"],["IntoIterator::IntoIter","has type","I"],["IntoIterator::IntoIter","is a","associated type"],["IntoIterator::Item","has type","<I as Iterator>::Item"],["IntoIterator::Item","is a","associated type"],["Item","has type","&'a T"],["Item","has type","&'a mut T"],["Item","has type","T"],["Iter","has description","An iterator over a reference to the Some variant of an Option."],["Iter","implements","Iterator"],["Iter","is a","struct"],["IterMut","has description","An iterator over a mutable reference to the Some variant of an Option."],["IterMut","implements","Iterator"],["IterMut","is a","struct"],["None","has description","No value"],["NoneError","has description","The error type that results from applying the try operator (`?`) to a `None` value. If you wish to allow `x?` (where `x` is an `Option<T>`) to be converted into your error type, you can implement `impl From<NoneError>` for `YourErrorType`. In that case, `x?` within a function that returns `Result<_, YourErrorType>` will translate a `None` value into an `Err` result."],["NoneError","is a","struct"],["Ok","has description","The type of this value when viewed as successful."],["Ok","has stability","This is a nightly-only experimental API. (try_trait #42327)"],["Ok","has type","T"],["Option","has declaration","pub enum Option<T> { None, Some(T), }"],["Option","has full name","std::option::Option"],["Option","has method","and"],["Option","has method","and_then"],["Option","has method","as_mut"],["Option","has method","as_pin_mut"],["Option","has method","as_pin_ref"],["Option","has method","as_ref"],["Option","has method","cloned"],["Option","has method","deref"],["Option","has method","expect"],["Option","has method","filter"],["Option","has method","get_or_insert"],["Option","has method","get_or_insert_with"],["Option","has method","is_none"],["Option","has method","is_some"],["Option","has method","iter"],["Option","has method","iter_mut"],["Option","has method","map"],["Option","has method","map_or"],["Option","has method","map_or_else"],["Option","has method","ok_or"],["Option","has method","ok_or_else"],["Option","has method","or"],["Option","has method","or_else"],["Option","has method","replace"],["Option","has method","take"],["Option","has method","transpose"],["Option","has method","unwrap"],["Option","has method","unwrap_or"],["Option","has method","unwrap_or_default"],["Option","has method","unwrap_or_else"],["Option","has method","xor"],["Option","has variant","None"],["Option","has variant","Some"],["Option","implements","Clone"],["Option","implements","Copy"],["Option","implements","Debug"],["Option","implements","Default"],["Option","implements","Eq"],["Option","implements","From<&'a Option<T>>"],["Option","implements","From<&'a mut Option<T>>"],["Option","implements","From<T>"],["Option","implements","FromIterator<Option<A>>"],["Option","implements","Hash"],["Option","implements","IntoIterator"],["Option","implements","Ord"],["Option","implements","PartialEq<Option<T>>"],["Option","implements","PartialOrd<Option<T>>"],["Option","implements","Send"],["Option","implements","Sync"],["Option","implements","Try"],["Option","is a","enum"],["Option","is part of module","std::option"],["Option","stable since","1.0.0"],["Option<&'a T>","implements","From<&'a Option<T>>"],["Option<&'a T>","stable since","1.30.0"],["Option<&'a mut T>","implements","From<&'a mut Option<T>>"],["Option<&T>","has method","cloned"],["Option<&T>::cloned","has argument","self"],["Option<&T>::cloned","has description","Maps an Option<&T> to an Option<T> by cloning the contents of the option."],["Option<&T>::cloned","has return type","Option<T>"],["Option<&T>::cloned","is a","method"],["Option<&T>::cloned","requires trait","Clone"],["Option<&mut T>","has method","cloned"],["Option<&mut T>::cloned","has argument","self"],["Option<&mut T>::cloned","has description","Maps an Option<&mut T> to an Option<T> by cloning the contents of the option."],["Option<&mut T>::cloned","has return type","Option<T>"],["Option<&mut T>::cloned","is a","method"],["Option<&mut T>::cloned","requires trait","Clone"],["Option<&mut T>::cloned","stable since","1.26.0"],["Option<Result<T, E>>","has method","transpose"],["Option<T>","has associated type","Error"],["Option<T>","has associated type","IntoIter"],["Option<T>","has associated type","Item"],["Option<T>","has associated type","Ok"],["Option<T>","has full name","std::option::Option"],["Option<T>","has full name","std::option::Option<T>"],["Option<T>","has method","as_ref"],["Option<T>","has method","cmp"],["Option<T>","has method","deref"],["Option<T>","has method","from_error"],["Option<T>","has method","from_ok"],["Option<T>","has method","ge"],["Option<T>","has method","gt"],["Option<T>","has method","into_iter"],["Option<T>","has method","into_result"],["Option<T>","has method","is_none"],["Option<T>","has method","is_some"],["Option<T>","has method","le"],["Option<T>","has method","lt"],["Option<T>","has method","max"],["Option<T>","has method","min"],["Option<T>","has method","ok_or"],["Option<T>","has method","ok_or_else"],["Option<T>","has method","or"],["Option<T>","has method","or_else"],["Option<T>","has method","unwrap_or_default"],["Option<T>","has method","xor"],["Option<T>","has variant","None"],["Option<T>","has variant","Some"],["Option<T>","implements","Clone"],["Option<T>","implements","Copy"],["Option<T>","implements","Default"],["Option<T>","implements","From<T>"],["Option<T>","implements","Hash"],["Option<T>","implements","IntoIterator"],["Option<T>","implements","Ord"],["Option<T>","implements","PartialOrd"],["Option<T>","implements","Try"],["Option<T>","is a","enum"],["Option<T>","is part of module","std::option"],["Option<T>::default","has description","Returns None."],["Option<T>::default","has return type","Option<T>"],["Option<T>::default","is a","method"],["Option<T>::hash","has argument","self"],["Option<T>::hash","has argument","state"],["Option<T>::hash","has description","Feeds this value into the given Hasher. Read more"],["Option<T>::hash","is a","method"],["Option<T>::hash::state","has type","&mut __HT"],["Option<T>::hash_slice","has description","Feeds a slice of this type into the given Hasher. Read more"],["Option<T>::hash_slice","is a","method"],["Option<T>::hash_slice","stable since","1.3.0"],["Option<T>::hash_slice::data","has type","&[Self]"],["Option<V>","implements","FromIterator<Option<A>>"],["Ordering","has full name","std::cmp::Ordering"],["Ordering","is a","enum"],["Owned","has type","T"],["PartialOrd","has full name","std::cmp::PartialOrd"],["PartialOrd","has method","partial_cmp"],["PartialOrd","is part of module","std::cmp"],["Result<T, E>","has variant","Err"],["Result<T, E>","has variant","Ok"],["String","is a","struct"],["T","implements","Any"],["T","implements","BorrowMut"],["T","implements","From"],["T","implements","ToOwned"],["T","implements","TryFrom"],["T","implements","TryInto"],["ToOwned","has associated type","Owned"],["ToOwned","has method","clone_into"],["ToOwned","has method","to_owned"],["ToOwned","is a","trait"],["ToOwned","requires trait","Clone"],["TryFrom","has associated type","Error"],["TryFrom","has method","try_from"],["TryFrom","has stability","This is a nightly-only experimental API. (try_from #33417)"],["TryFrom","is a","trait"],["TryFrom::Error","has type","!"],["TryFrom::Error","is a","associated type"],["TryInto","has associated type","Error"],["TryInto","is a","trait"],["TryInto","requires method","try_into"],["TryInto::Error","has description","The type returned in the event of a conversion error."],["TryInto::Error","has type","<U as TryFrom<T>>::Error"],["and","has argument","optb"],["and","has argument","self"],["and","has description","Returns None if the option is None, otherwise returns optb."],["and","has return type","Option<U>"],["and_then","has argument","f"],["and_then","has argument","self"],["and_then","has description","Returns None if the option is None, otherwise calls f with the wrapped value and returns the result. Some languages call this operation flatmap."],["and_then","has return type","Option<U>"],["as_mut","has argument","self"],["as_mut","has description","Converts from Option<T> to Option<&mut T>."],["as_mut","has return type","Option<&mut T>"],["as_mut::self","has type","&mut Option<T>"],["as_pin_mut","has argument","self"],["as_pin_mut","has description","Converts from Pin<&mut Option<T>> to Option<Pin<&mut T>>"],["as_pin_mut","has return type","Option<Pin<&'a mut T>>"],["as_pin_mut","has stability","nightly-only experimental API (pin #49150)"],["as_pin_mut::self","has type","Pin<&'a mut Option<T>>"],["as_pin_ref","has argument","self"],["as_pin_ref","has description","Converts from Pin<&Option<T>> to Option<Pin<&T>>"],["as_pin_ref","has return type","Option<Pin<&'a T>>"],["as_pin_ref","has stability","nightly-only experimental API (pin #49150)"],["as_pin_ref::self","has type","Pin<&'a Option<T>>"],["as_ref","has argument","as_ref::self"],["as_ref","has argument","self"],["as_ref","has description","Converts from Option<T> to Option<&T>."],["as_ref","has full name","std::option::Option::as_ref"],["as_ref","has return type","Option<&T>"],["as_ref","is a","method"],["as_ref::self","has type","&Option<T>"],["as_ref::self","has type","&Self"],["borrow","has argument","borrow::self"],["borrow","has description","Immutably borrows from an owned value"],["borrow","has return type","&T"],["borrow::self","has type","&T"],["borrow_mut","has description","Mutably borrows from an owned value"],["borrow_mut","has return type","&mut T"],["clone","has description","Returns a copy of the value."],["clone","has return type","Option<T>"],["clone_from","has argument","self"],["clone_from","has argument","source"],["clone_from","has description","Performs copy-assignment from source."],["clone_into","has argument","self"],["clone_into","has argument","target"],["clone_into","has description","Uses borrowed data to replace owned data, usually by cloning."],["clone_into","has experimental flag","This is a nightly-only experimental API. (toowned_clone_into #41263)"],["clone_into","is a","function"],["cmp","has argument","other"],["cmp","has argument","self"],["cmp","has description","This method returns an Ordering between self and other."],["cmp","has return type","Ordering"],["default","has type","D"],["default","has type","U"],["deref","has return type","Option<&<T as Deref>::Target>"],["deref","has stability","nightly-only experimental API (inner_deref #50264)"],["deref","requires trait","Deref"],["eq","has argument","other"],["eq","has argument","self"],["eq","has description","This method tests for self and other values to be equal, and is used by ==."],["eq","has return type","bool"],["eq","is a","method"],["err","has type","E"],["err","has type","FnOnce() -> E"],["expect","has argument","msg"],["expect","has argument","self"],["expect","has declaration","pub fn expect(self, msg: &str) -> T"],["expect","has description","Panics if the value is a None with a custom panic message provided by msg."],["expect","has description","Unwraps an option, yielding the content of a Some. Panics if the value is a None with a custom panic message provided by msg."],["expect","has return type","T"],["expect::msg","has type","&str"],["expect::self","has type","Option<T>"],["f","has type","F"],["f","has type","FnOnce() -> T"],["f","has type","FnOnce(T) -> Option<U>"],["f","has type","std::fmt::Formatter"],["filter","has argument","predicate"],["filter","has declaration","pub fn filter<P>(self, predicate: P) -> Option<T> where P: FnOnce(&T) -> bool"],["filter","has description","Returns None if the option is None, otherwise calls predicate with the wrapped value and returns: Some(t) if predicate returns true (where t is the wrapped value), and None if predicate returns false. This function works similar to Iterator::filter(). You can imagine the Option<T> being an iterator over one or zero elements. filter() lets you decide which elements to keep."],["filter","has return type","Option<T>"],["filter","stable since","1.27.0"],["fmt","has argument","f"],["fmt","has argument","self"],["fmt","has description","Formats the value using the given formatter."],["fmt","has return type","std::result::Result<(), std::fmt::Error>"],["fmt","is a","method"],["from","has argument","from::t"],["from","has argument","o: &'a Option<T>"],["from","has description","Performs the conversion."],["from","has return type","Option<&'a T>"],["from","has return type","T"],["from","is a","function"],["from::t","has type","T"],["from_error","has description","Wrap an error value to construct the composite result. For example, Result::Err(x) and Result::from_error(x) are equivalent. Read more"],["from_error","has return type","Option<T>"],["from_error","has stability","This is a nightly-only experimental API. (try_trait #42327)"],["from_iter","has argument","iter: I"],["from_iter","has description","Takes each element in the Iterator: if it is None, no further elements are taken, and the None is returned. Should no None occur, a container with the values of each Option is returned."],["from_iter","has example","Here is an example which increments every integer in a vector, checking for overflow"],["from_iter","has return type","Option<V>"],["from_iter","is a","function"],["from_ok","has description","Wrap an OK value to construct the composite result. For example, Result::Ok(x) and Result::from_ok(x) are equivalent. Read more"],["from_ok","has return type","Option<T>"],["from_ok","has stability","This is a nightly-only experimental API. (try_trait #42327)"],["ge","has argument","other"],["ge","has argument","self"],["ge","has description","This method tests greater than or equal to (for self and other) and is used by the >= operator."],["ge","has return type","bool"],["get_or_insert","has argument","get_or_insert::v"],["get_or_insert","has declaration","pub fn get_or_insert(&mut self, v: T) -> &mut T"],["get_or_insert","has description","Inserts v into the option if it is None, then returns a mutable reference to the contained value."],["get_or_insert","has return type","&mut T"],["get_or_insert","stable since","1.20.0"],["get_or_insert::v","has type","T"],["get_or_insert_with","has argument","f"],["get_or_insert_with","has argument","self"],["get_or_insert_with","has description","Inserts a value computed from f into the option if it is None, then returns a mutable reference to the contained value."],["get_or_insert_with","has return type","&mut T"],["get_or_insert_with","stable since","1.20.0"],["get_type_id","has description","Gets the TypeId of self"],["get_type_id","has experimental flag","#27745"],["get_type_id","has return type","TypeId"],["gt","has argument","other"],["gt","has argument","self"],["gt","has description","This method tests greater than (for self and other) and is used by the > operator."],["gt","has return type","bool"],["into","has argument","into::self"],["into","has description","Performs the conversion."],["into","has return type","U"],["into::self","has type","T"],["into_iter","has argument","into_iter::self"],["into_iter","has argument","self"],["into_iter","has description","Creates an iterator from a value."],["into_iter","has description","Creates an iterator from a value. Read more"],["into_iter","has description","Returns a consuming iterator over the possibly contained value."],["into_iter","has example","let x = Some(\"string\"); let v: Vec<&str> = x.into_iter().collect(); assert_eq!(v, [\"string\"]); let x = None; let v: Vec<&str> = x.into_iter().collect(); assert!(v.is_empty());"],["into_iter","has return type","I"],["into_iter","has return type","IntoIter<T>"],["into_iter","has return type","std::option::IntoIter"],["into_iter","has return type","std::option::Iter"],["into_iter","has return type","std::option::IterMut"],["into_iter","is a","function"],["into_iter::self","has type","I"],["into_result","has description","Applies the \"?\" operator. A return of Ok(t) means that the execution should continue normally, and the result of ? is the value t. A return of Err(e) means that execution should branch to the innermost enclosing catch, or return from the function. Read more"],["into_result","has return type","Result<T, NoneError>"],["into_result","has stability","This is a nightly-only experimental API. (try_trait #42327)"],["is_none","has argument","is_none::self"],["is_none","has description","Returns true if the option is a None value."],["is_none","has full name","std::option::Option::is_none"],["is_none","has return type","bool"],["is_none","is a","method"],["is_none::self","has type","&Self"],["is_some","has argument","is_some::self"],["is_some","has description","Returns true if the option is a Some value."],["is_some","has full name","std::option::Option::is_some"],["is_some","has return type","bool"],["is_some","is a","method"],["is_some::self","has type","&Self"],["iter","has argument","&self"],["iter","has description","Returns an iterator over the possibly contained value."],["iter","has return type","Iter<T>"],["iter_mut","has argument","&mut self"],["iter_mut","has description","Returns a mutable iterator over the possibly contained value."],["iter_mut","has return type","IterMut<T>"],["le","has argument","other"],["le","has argument","self"],["le","has description","This method tests less than or equal to (for self and other) and is used by the <= operator."],["le","has return type","bool"],["lt","has argument","other"],["lt","has argument","self"],["lt","has description","This method tests less than (for self and other) and is used by the < operator."],["lt","has return type","bool"],["map","has argument","f"],["map","has argument","self"],["map","has declaration","pub fn map<U, F>(self, f: F) -> Option<U> where F: FnOnce(T) -> U"],["map","has description","Maps an Option<T> to Option<U> by applying a function to a contained value."],["map","has return type","Option<U>"],["map_or","has argument","default"],["map_or","has argument","f"],["map_or","has argument","self"],["map_or","has declaration","pub fn map_or<U, F>(self, default: U, f: F) -> U where F: FnOnce(T) -> U"],["map_or","has description","Applies a function to the contained value (if any), or returns the provided default (if not)."],["map_or","has return type","U"],["map_or_else","has argument","default"],["map_or_else","has argument","f"],["map_or_else","has argument","self"],["map_or_else","has declaration","pub fn map_or_else<U, D, F>(self, default: D, f: F) -> U where D: FnOnce() -> U, F: FnOnce(T) -> U"],["map_or_else","has description","Applies a function to the contained value (if any), or computes a default (if not)."],["map_or_else","has return type","U"],["max","has argument","other"],["max","has argument","self"],["max","has description","Compares and returns the maximum of two values."],["max","has return type","Self"],["max","stable since","1.21.0"],["min","has argument","other"],["min","has argument","self"],["min","has description","Compares and returns the minimum of two values."],["min","has return type","Self"],["min","stable since","1.21.0"],["ne","has description","This method tests for !=."],["ne","has return type","bool"],["ne","is a","method"],["o","has type","&'a mut Option<T>"],["ok_or","has argument","err"],["ok_or","has declaration","pub fn ok_or<E>(self, err: E) -> Result<T, E>"],["ok_or","has description","Transforms the Option<T> into a Result<T, E>, mapping Some(v) to Ok(v) and None to Err(err)."],["ok_or","has return type","Result<T, E>"],["ok_or_else","has argument","err"],["ok_or_else","has declaration","pub fn ok_or_else<E, F>(self, err: F) -> Result<T, E> where F: FnOnce() -> E"],["ok_or_else","has description","Transforms the Option<T> into a Result<T, E>, mapping Some(v) to Ok(v) and None to Err(err())."],["ok_or_else","has return type","Result<T, E>"],["optb","has type","Option<T>"],["optb","has type","Option<U>"],["or","has argument","optb"],["or","has argument","self"],["or","has declaration","pub fn or(self, optb: Option<T>) -> Option<T>"],["or","has description","Returns the option if it contains a value, otherwise returns optb."],["or","has description","Returns the option if it contains a value, otherwise returns optb. Arguments passed to or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use or_else, which is lazily evaluated."],["or","has return type","Option<T>"],["or::optb","has type","Option<T>"],["or_else","has argument","f"],["or_else","has argument","self"],["or_else","has declaration","pub fn or_else<F>(self, f: F) -> Option<T> where F: FnOnce() -> Option<T>"],["or_else","has description","Returns the option if it contains a value, otherwise calls f and returns the result."],["or_else","has return type","Option<T>"],["or_else::f","has type","FnOnce() -> Option<T>"],["other","has type","&Option<T>"],["other","has type","&std::option::Option<T>"],["parse","has example","good_year_from_input.parse().ok().unwrap_or_default()"],["partial_cmp","has argument","other"],["partial_cmp","has argument","self"],["partial_cmp","has description","This method returns an ordering between self and other values if one exists."],["partial_cmp","has return type","Option<Ordering>"],["predicate","has type","FnOnce(&T) -> bool"],["replace","has argument","self"],["replace","has argument","value"],["replace","has description","Replaces the actual value in the option by the value given in parameter, returning the old value if present, leaving a Some in its place without deinitializing either one."],["replace","has return type","Option<T>"],["replace","stable since","1.31.0"],["self","has type","&Option<T>"],["self","has type","&mut Option<T>"],["self","has type","&self"],["self","has type","&std::option::Option<T>"],["self","has type","Option<T>"],["source","has type","&Option<T>"],["std::cmp::PartialEq","requires method","eq"],["std::cmp::PartialEq","requires method","ne"],["std::fmt::Debug","requires method","fmt"],["std::option::IntoIter","has full name","std::option::IntoIter"],["std::option::IntoIter","is a","struct"],["std::option::Iter","has full name","std::option::Iter"],["std::option::Iter","is a","struct"],["std::option::IterMut","has full name","std::option::IterMut"],["std::option::IterMut","is a","struct"],["std::option::Option<T>","has method","eq"],["std::option::Option<T>","has method","fmt"],["std::option::Option<T>","has method","ne"],["std::option::Option<T>","implements","std::cmp::Eq"],["std::option::Option<T>","implements","std::cmp::PartialEq"],["std::option::Option<T>","implements","std::fmt::Debug"],["std::option::Option<T>","implements","std::marker::Send"],["std::option::Option<T>","implements","std::marker::Sync"],["take","has argument","self"],["take","has description","Takes the value out of the option, leaving a None in its place."],["take","has return type","Option<T>"],["target","has type","&mut T"],["to_owned","has argument","self"],["to_owned","has description","Creates owned data from borrowed data, usually by cloning."],["to_owned","has return type","T"],["to_owned","is a","function"],["transpose","has description","Transposes an Option of a Result into a Result of an Option. None will be mapped to Ok(None). Some(Ok(_)) and Some(Err(_)) will be mapped to Ok(Some(_)) and Err(_)."],["transpose","has example","#![feature(transpose_result)]...assert_eq!(x, y.transpose());"],["transpose","has return type","Result<Option<T>, E>"],["transpose","has source","../../src/core/option.rs.html#995-1001"],["transpose","has stability","This is a nightly-only experimental API. (transpose_result #47338)"],["try_from","has argument","try_from::value"],["try_from","has description","Performs the conversion."],["try_from","has return type","Result<T, <T as TryFrom<U>>::Error>"],["try_from","has stability","This is a nightly-only experimental API. (try_from #33417)"],["try_from","is a","function"],["try_from::value","has type","U"],["try_into","has argument","try_into::self"],["try_into","has description","Performs the conversion."],["try_into","has return type","Result<U, <U as TryFrom<T>>::Error>"],["try_into","has stability","This is a nightly-only experimental API. (try_from #33417)"],["try_into::self","has type","T"],["unwrap","has argument","self"],["unwrap","has declaration","pub fn unwrap(self) -> T"],["unwrap","has description","Moves the value v out of the Option<T> if it is Some(v). Panics if the self value equals None."],["unwrap","has return type","T"],["unwrap_or","has argument","def"],["unwrap_or","has argument","self"],["unwrap_or","has declaration","pub fn unwrap_or(self, def: T) -> T"],["unwrap_or","has description","Returns the contained value or a default. Arguments passed to unwrap_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use unwrap_or_else, which is lazily evaluated."],["unwrap_or","has return type","T"],["unwrap_or_default","has description","Returns the contained value or a default. Consumes the self argument then, if Some, returns the contained value, otherwise if None, returns the default value for that type."],["unwrap_or_default","has return type","T"],["unwrap_or_default","requires trait","Default"],["unwrap_or_else","has argument","f"],["unwrap_or_else","has argument","self"],["unwrap_or_else","has declaration","pub fn unwrap_or_else<F>(self, f: F) -> T where F: FnOnce() -> T"],["unwrap_or_else","has description","Returns the contained value or computes it from a closure."],["unwrap_or_else","has return type","T"],["usize","is a","primitive"],["val","has type","T"],["value","has type","T"],["xor","has argument","optb"],["xor","has argument","self"],["xor","has declaration","pub fn xor(self, optb: Option<T>) -> Option<T>"],["xor","has description","Returns Some if exactly one of self, optb is Some, otherwise returns None."],["xor","has return type","Option<T>"],["xor","has stability","This is a nightly-only experimental API. (option_xor #50512)"],["xor::optb","has type","Option<T>"]],"add_links":["../../../index.html","../../index.html","../../src/alloc/borrow.rs.html","../../src/core/any.rs.html","../../src/core/borrow.rs.html","../../src/core/clone.rs.html","../../src/core/cmp.rs.html","../../src/core/convert.rs.html","../../src/core/hash/mod.rs.html","../../src/core/iter/traits.rs.html","../../src/core/option.rs.html","../../std/any/trait.Any.html","../../std/borrow/trait.Borrow.html","../../std/borrow/trait.BorrowMut.html","../../std/borrow/trait.ToOwned.html","../../std/clone/trait.Clone.html","../../std/cmp/enum.Ordering.html","../../std/cmp/trait.Eq.html","../../std/cmp/trait.Ord.html","../../std/cmp/trait.PartialEq.html","../../std/cmp/trait.PartialOrd.html","../../std/convert/trait.From.html","../../std/convert/trait.Into.html","../../std/convert/trait.TryFrom.html","../../std/convert/trait.TryInto.html","../../std/default/trait.Default.html","../../std/fmt/struct.Error.html","../../std/fmt/struct.Formatter.html","../../std/fmt/trait.Debug.html","../../std/hash/trait.Hash.html","../../std/io/trait.Read.html","../../std/io/trait.Write.html","../../std/iter/trait.FromIterator.html","../../std/iter/trait.IntoIterator.html","../../std/iter/trait.Iterator.html","../../std/marker/trait.Copy.html","../../std/marker/trait.Send.html","../../std/marker/trait.Sized.html","../../std/marker/trait.Sync.html","../../std/ops/trait.Deref.html","../../std/ops/trait.FnOnce.html","../../std/ops/trait.Try.html","../../std/option/enum.Option.html","../../std/option/struct.IntoIter.html","../../std/option/struct.Iter.html","../../std/option/struct.IterMut.html","../../std/option/struct.NoneError.html","../../std/pin/struct.Pin.html","../../std/primitive.usize.html","../../std/result/enum.Result.html","../../std/str/trait.FromStr.html","../../std/string/struct.String.html","../index.html","../primitive.bool.html","../primitive.never.html","../primitive.reference.html","../primitive.str.html","enum.Option.html","https://github.com/rust-lang/rust/issues/41263","https://github.com/rust-lang/rust/issues/47338","https://github.com/rust-lang/rust/issues/49150","https://play.rust-lang.org/","https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Afn%20is_even(n%3A%20%26i32)%20-%3E%20bool%20%7B%0A%20%20%20%20n%20%25%202%20%3D%3D%200%0A%7D%0A%0Aassert_eq!(None.filter(is_even)%2C%20None)%3B%0Aassert_eq!(Some(3).filter(is_even)%2C%20None)%3B%0Aassert_eq!(Some(4).filter(is_even)%2C%20Some(4))%3B%0A%7D","https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Afn%20nobody()%20-%3E%20Option%3C%26'static%20str%3E%20%7B%20None%20%7D%0Afn%20vikings()%20-%3E%20Option%3C%26'static%20str%3E%20%7B%20Some(%22vikings%22)%20%7D%0A%0Aassert_eq!(Some(%22barbarians%22).or_else(vikings)%2C%20Some(%22barbarians%22))%3B%0Aassert_eq!(None.or_else(vikings)%2C%20Some(%22vikings%22))%3B%0Aassert_eq!(None.or_else(nobody)%2C%20None)%3B%0A%7D","https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Afn%20sq(x%3A%20u32)%20-%3E%20Option%3Cu32%3E%20%7B%20Some(x%20*%20x)%20%7D%0Afn%20nope(_%3A%20u32)%20-%3E%20Option%3Cu32%3E%20%7B%20None%20%7D%0A%0Aassert_eq!(Some(2).and_then(sq).and_then(sq)%2C%20Some(16))%3B%0Aassert_eq!(Some(2).and_then(sq).and_then(nope)%2C%20None)","https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20x%20%3D%20Some(%22string%22)%3B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20x.into_iter().collect()%3B%0Aassert_eq!(v%2C%20%5B%22string%22%5D)%3B%0A%0Alet%20x%20%3D%20None%3B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20x.into_iter().collect()%3B%0Aassert!(v.is_empty())%3B%0A%7D","https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20x%20%3D%20Some(2)%3B%0Alet%20y%20%3D%20None%3B%0Aassert_eq!(x.or(y)%2C%20Some(2))%3B%0A%0Alet%20x%20%3D%20None%3B%0Alet%20y%20%3D%20Some(100)%3B%0Aassert_eq!(x.or(y)%2C%20Some(100))%3B%0A%0Alet%20x%20%3D%20Some","https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20x%20%3D%20Some(2)%3B%0Alet%20y%3A%20Option%3C%26str%3E%20%3D%20None%3B%0Aassert_eq!(x.and(y)%2C%20None)%3B%0A%0Alet%20x%3A%20Option%3Cu32%3E%20%3D%20None%3B%0Alet%20y%20%3D%20Some(%22foo%22)%3B%0Aassert_eq!(x.and(y)%2C%20None)%3B%0A%0Alet%20x%20%3D%20Some(2)%3B%0Alet%20y%20%3D%20Some(%22foo%22)%3B%0Aassert_eq!(x.and(y)%2C%20Some(%22foo%22))%3B%0A%0Alet%20x%3A%20Option%3Cu32%3E%20%3D%20None%3B%0Alet%20y%3A%20Option%3C%26str%3E%20%3D%20None%3B%0Aassert_eq!(x.and(y)%2C%20None)%3B%0A%7D","index.html","settings.html","struct.IntoIter.html","struct.Iter.html","struct.IterMut.html","struct.NoneError.html"],"metrics":{"escapeCount":0,"costTime":4515577,"totalUsage":{"prompt_tokens":138372,"completion_tokens":138863,"cached_tokens":0,"reasoning_tokens":122881},"chunkLength":26,"chunksInfo":[{"contextLength":0,"contentLength":7000,"costTime":111629},{"contextLength":500,"contentLength":7000,"costTime":204828},{"contextLength":500,"contentLength":7000,"costTime":184804},{"contextLength":500,"contentLength":7000,"costTime":139853},{"contextLength":500,"contentLength":7000,"costTime":142424},{"contextLength":500,"contentLength":7000,"costTime":231517},{"contextLength":500,"contentLength":7000,"costTime":68544},{"contextLength":500,"contentLength":7000,"costTime":136566},{"contextLength":500,"contentLength":7000,"costTime":189718},{"contextLength":500,"contentLength":7000,"costTime":170740},{"contextLength":500,"contentLength":7000,"costTime":173692},{"contextLength":500,"contentLength":7000,"costTime":167738},{"contextLength":500,"contentLength":7000,"costTime":190972},{"contextLength":500,"contentLength":7000,"costTime":42531},{"contextLength":500,"contentLength":7000,"costTime":90090},{"contextLength":500,"contentLength":7000,"costTime":237941},{"contextLength":500,"contentLength":7000,"costTime":154583},{"contextLength":500,"contentLength":7000,"costTime":182579},{"contextLength":500,"contentLength":7000,"costTime":217389},{"contextLength":500,"contentLength":7000,"costTime":338206},{"contextLength":500,"contentLength":7000,"costTime":145897},{"contextLength":500,"contentLength":7000,"costTime":244701},{"contextLength":500,"contentLength":7000,"costTime":252711},{"contextLength":500,"contentLength":7000,"costTime":264840},{"contextLength":500,"contentLength":7000,"costTime":41981},{"contextLength":500,"contentLength":3078,"costTime":189103}]},"model":"deepseek-r1-250120","extraInfo":{"startTime":"2025-03-22T13:55:16.586Z","examGroup":"split"}}