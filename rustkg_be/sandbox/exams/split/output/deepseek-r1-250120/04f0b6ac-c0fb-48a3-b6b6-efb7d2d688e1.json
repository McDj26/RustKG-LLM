{"create_time":"2025-03-22T14:38:37.108Z","id":"04f0b6ac-c0fb-48a3-b6b6-efb7d2d688e1","source_url":"file:///C:/Users/Dj/.rustup/toolchains/1.30-x86_64-pc-windows-msvc/share/doc/rust/html/std/option/enum.Option.html","relations":["has argument","has associated type","has attribute","has declaration","has description","has example","has method","has module","has return type","has source link","has stability","has trait implementation","has type","has variant","implements","returns","stable since"],"add_triples":[["Any<T>","has method","get_type_id"],["Any<T>","has source link","../../src/core/any.rs.html#114-116"],["Any<T>","has stability","This is a nightly-only experimental API. (get_type_id #27745)"],["Any<T>","implements","Any"],["Borrow<T>","has method","borrow"],["Borrow<T>","has source link","../../src/core/borrow.rs.html#219-221"],["Borrow<T>","implements","Borrow"],["BorrowMut<T>","has method","borrow_mut"],["BorrowMut<T>","has source link","../../src/core/borrow.rs.html#224-226"],["BorrowMut<T>","implements","BorrowMut"],["Debug","has method","fmt"],["Default","has method","default"],["Error","has type","<U as TryFrom<T>>::Error"],["From<&'a Option<T>>","has method","from"],["From<&'a mut Option<T>>","has method","from"],["From<T>","has method","from"],["From<T>","has source link","../../src/core/convert.rs.html#462-464"],["From<T>","implements","From"],["I","implements","IntoIterator"],["Into<T, U>","has method","into"],["Into<T, U>","has source link","../../src/core/convert.rs.html#453-458"],["Into<T, U>","implements","Into"],["IntoIter","has type","I"],["IntoIterator","has associated type","IntoIter"],["IntoIterator","has associated type","Item"],["IntoIterator","has method","into_iter"],["IntoIterator","has source link","../../src/core/iter/traits.rs.html#255-262"],["Item","has type","<I as Iterator>::Item"],["Option","has description","The `Option` type. See the module level documentation for more."],["Option","has method","as_mut"],["Option","has method","as_pin_mut"],["Option","has method","as_ref"],["Option","has method","expect"],["Option","has method","is_none"],["Option","has method","is_some"],["Option","has method","map"],["Option","has method","map_or"],["Option","has method","map_or_else"],["Option","has method","ok_or"],["Option","has method","ok_or_else"],["Option","has method","unwrap"],["Option","has method","unwrap_or"],["Option","has method","unwrap_or_else"],["Option","has variant","None"],["Option","has variant","Some"],["Option","implements","Clone"],["Option","implements","Copy"],["Option","implements","Debug"],["Option","implements","Default"],["Option","implements","Eq"],["Option","implements","From<&'a Option<T>>"],["Option","implements","From<&'a mut Option<T>>"],["Option","implements","From<T>"],["Option","implements","FromIterator<Option<A>>"],["Option","implements","Hash"],["Option","implements","IntoIterator"],["Option","implements","Ord"],["Option","implements","PartialEq<Option<T>>"],["Option","implements","PartialOrd<Option<T>>"],["Option","implements","Try"],["Option","stable since","1.0.0"],["Option<&'a T>","has method","cloned"],["Option<T>","has method","replace"],["Option<T>","has method","take"],["Option<T>","has method","unwrap_or_default"],["Option<T>","has variant","None"],["Option<T>","has variant","Some"],["Option<T>","implements","Clone"],["Option<T>","implements","Copy"],["Option<T>","implements","Debug"],["Option<T>","implements","Default"],["Option<T>","implements","Deref"],["Option<T>","implements","Eq"],["Option<T>","implements","From<&'a Option<T>>"],["Option<T>","implements","From<&'a mut Option<T>>"],["Option<T>","implements","From<T>"],["Option<T>","implements","FromIterator<Option<A>>"],["Option<T>","implements","Hash"],["Option<T>","implements","IntoIterator"],["Option<T>","implements","Ord"],["Option<T>","implements","PartialEq<Option<T>>"],["Option<T>","implements","PartialOrd<Option<T>>"],["Option<T>","implements","Try"],["Ord","has method","cmp"],["Ord","has method","max"],["Ord","has method","min"],["Owned","has type","T"],["PartialEq","has method","eq"],["PartialEq","has method","ne"],["PartialOrd","has method","ge"],["PartialOrd","has method","gt"],["PartialOrd","has method","le"],["PartialOrd","has method","lt"],["PartialOrd","has method","partial_cmp"],["ToOwned<T>","has associated type","Owned"],["ToOwned<T>","has method","clone_into"],["ToOwned<T>","has method","to_owned"],["ToOwned<T>","has source link","../../src/alloc/borrow.rs.html#90-101"],["ToOwned<T>","implements","ToOwned"],["Try","has method","from_error"],["Try","has method","from_ok"],["Try","has method","into_result"],["TryInto","has associated type","Error"],["TryInto","has method","try_into"],["TryInto","has source link","../../src/core/convert.rs.html#469-476"],["TryInto","has stability","This is a nightly-only experimental API. (try_from #33417)"],["TryInto<T, U>","implements","TryInto"],["and","has argument","optb"],["and","has argument","self"],["and","has example","let x = Some(2); let y: Option<&str> = None; assert_eq!(x.and(y), None);"],["and","returns","std::option::Option<U>"],["and_then","has argument","f"],["and_then","has argument","self"],["and_then","has description","Returns None if the option is None, otherwise calls f with the wrapped value and returns the result."],["and_then","has example","fn sq(x: u32) -> Option<u32> { Some(x * x) } ..."],["and_then","returns","std::option::Option<U>"],["as_mut","returns","Option<&mut T>"],["as_pin_mut","returns","Option<PinMut<'a, T>>"],["as_ref","returns","Option<&T>"],["borrow","has description","Immutably borrows from an owned value."],["borrow","has return type","&T"],["borrow_mut","has description","Mutably borrows from an owned value."],["borrow_mut","has return type","&mut T"],["clone_from","has argument","self"],["clone_from","has argument","source"],["clone_from","has description","Performs copy-assignment from source."],["clone_into","has description","Uses borrowed data to replace owned data, usually by cloning."],["clone_into","has stability","This is a nightly-only experimental API. (toowned_clone_into #41263)"],["cloned","has description","Maps an Option<&T> to an Option<T> by cloning the contents."],["cloned","returns","Option<T>"],["deref","has attribute","unstable"],["expect","has argument","msg: &str"],["f","has type","FnOnce() -> E"],["f","has type","FnOnce(T) -> std::option::Option<U>"],["filter","has argument","predicate"],["filter","has description","Returns None if the option is None, otherwise calls predicate with the wrapped value and returns:"],["filter","returns","std::option::Option<T>"],["filter","stable since","1.27.0"],["from","has argument","t: T"],["from","has description","Performs the conversion."],["from","has return type","T"],["from_iter","has description","Takes each element in the Iterator: if it is None, no further elements are taken, and the None is returned."],["from_iter","has return type","Option<V>"],["get_type_id","has description","Gets the TypeId of self."],["get_type_id","has return type","TypeId"],["into","has description","Performs the conversion."],["into","has return type","U"],["into_iter","has description","Creates an iterator from a value."],["into_iter","has return type","I"],["is_none","has description","Returns `true` if the option is a `None` value."],["is_none","returns","bool"],["is_some","has description","Returns `true` if the option is a `Some` value."],["is_some","returns","bool"],["iter","has argument","self"],["iter","has description","Returns an iterator over the possibly contained value."],["iter","has example","let x = Some(4); assert_eq!(x.iter().next(), Some(&4)); let x: Option<u32> = None; assert_eq!(x.iter().next(), None);"],["iter","has source link","../../src/core/option.rs.html#539-541"],["iter","returns","std::option::Iter<T>"],["iter_mut","has argument","self"],["iter_mut","has description","Returns a mutable iterator over the possibly contained value."],["iter_mut","has example","let mut x = Some(4); match x.iter_mut().next() { Some(v) => *v = 42, None => {} }; assert_eq!(x, Some(42));"],["iter_mut","has source link","../../src/core/option.rs.html#560-562"],["iter_mut","returns","std::option::IterMut<T>"],["map","returns","Option<U>"],["map_or","has argument","default: U"],["map_or_else","has argument","default: D"],["max","stable since","1.21.0"],["min","stable since","1.21.0"],["ok_or","returns","Result<T, E>"],["ok_or_else","has argument","f"],["ok_or_else","has argument","self"],["ok_or_else","has description","Transforms the Option<T> into a Result<T, E>, mapping Some(v) to Ok(v) and None to Err(err())."],["ok_or_else","has example","let x = Some(\"foo\"); assert_eq!(x.ok_or_else(|| 0), Ok(\"foo\")); let x: Option<&str> = None; assert_eq!(x.ok_or_else(|| 0), Err(0));"],["ok_or_else","returns","Result<T, E>"],["ok_or_else","returns","std::result::Result<T, E>"],["optb","has type","std::option::Option<U>"],["partial_cmp","has argument","other"],["partial_cmp","has argument","self"],["partial_cmp","has description","This method returns an ordering between self and other values if one exists."],["partial_cmp","has return type","Option<Ordering>"],["predicate","has type","FnOnce(&T) -> bool"],["replace","has argument","value"],["replace","has attribute","unstable"],["replace","has declaration","pub fn replace(&mut self, value: T) -> Option<T>"],["replace","has description","Replaces the actual value in the option by the value given in parameter, returning the old value if present."],["replace","returns","Option<T>"],["self","has type","&mut std::option::Option<T>"],["self","has type","&std::option::Option<T>"],["self","has type","std::option::Option<T>"],["std::option::Iter","implements","std::iter::Iterator"],["std::option::IterMut","implements","std::iter::Iterator"],["std::option::Option","has method","and"],["std::option::Option","has method","and_then"],["std::option::Option","has method","filter"],["std::option::Option","has method","iter"],["std::option::Option","has method","iter_mut"],["std::option::Option","has method","ok_or_else"],["std::option::Option","has method","xor"],["take","has declaration","pub fn take(&mut self) -> Option<T>"],["take","has description","Takes the value out of the option, leaving a None in its place."],["take","has example","let mut x = Some(2); let y = x.take(); assert_eq!(x, None); assert_eq!(y, Some(2));"],["take","returns","Option<T>"],["to_owned","has description","Creates owned data from borrowed data, usually by cloning."],["to_owned","has return type","T"],["transpose","has attribute","unstable"],["try_into","has description","Performs the conversion."],["try_into","has return type","Result<U, <U as TryFrom<T>>::Error>"],["unwrap","returns","T"],["unwrap_or","has argument","def: T"],["unwrap_or_default","has description","Returns the contained value or a default."],["unwrap_or_default","returns","T"],["unwrap_or_else","has argument","f: F"],["value","has type","T"],["xor","has description","Returns Some if exactly one of self, optb is Some, otherwise returns None."]],"add_links":["../../src/alloc/borrow.rs.html","../../src/core/any.rs.html","../../src/core/borrow.rs.html","../../src/core/clone.rs.html","../../src/core/cmp.rs.html","../../src/core/convert.rs.html","../../src/core/fmt/mod.rs.html","../../src/core/iter/traits.rs.html","../../src/core/option.rs.html","../../std/any/trait.Any.html","../../std/borrow/trait.Borrow.html","../../std/borrow/trait.BorrowMut.html","../../std/borrow/trait.ToOwned.html","../../std/clone/trait.Clone.html","../../std/cmp/trait.Eq.html","../../std/cmp/trait.Ord.html","../../std/cmp/trait.PartialEq.html","../../std/cmp/trait.PartialOrd.html","../../std/convert/trait.From.html","../../std/convert/trait.Into.html","../../std/convert/trait.TryInto.html","../../std/default/trait.Default.html","../../std/fmt/trait.Debug.html","../../std/hash/trait.Hash.html","../../std/index.html","../../std/iter/trait.FromIterator.html","../../std/iter/trait.IntoIterator.html","../../std/iter/trait.Iterator.html","../../std/ops/trait.Deref.html","../../std/ops/trait.Try.html","../../std/option/struct.Iter.html","../../std/option/struct.IterMut.html","../../std/pin/struct.PinMut.html","../../std/primitive.usize.html","../../std/result/enum.Result.html","../../std/string/struct.String.html","../index.html","enum.Option.html","index.html","struct.IntoIter.html","struct.Iter.html","struct.IterMut.html","struct.NoneError.html"],"metrics":{"escapeCount":0,"costTime":608955,"totalUsage":{"prompt_tokens":75147,"completion_tokens":18524,"cached_tokens":0,"reasoning_tokens":13809},"chunkLength":5,"chunksInfo":[{"contextLength":0,"contentLength":39000,"costTime":52137},{"contextLength":500,"contentLength":39000,"costTime":263881},{"contextLength":500,"contentLength":39000,"costTime":121738},{"contextLength":500,"contentLength":39000,"costTime":62577},{"contextLength":500,"contentLength":20900,"costTime":108622}]},"model":"deepseek-r1-250120","extraInfo":{"startTime":"2025-03-22T14:28:26.746Z","examGroup":"split"}}