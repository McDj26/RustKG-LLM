{"create_time":"2025-03-23T08:55:46.074Z","id":"93f95c98-34bd-481d-9723-e9f545f3fdef","source_url":"file:///C:/Users/Dj/.rustup/toolchains/1.31-x86_64-pc-windows-msvc/share/doc/rust/html/std/primitive.u8.html","relations":["has argument","has associated error","has associated type","has declaration","has description","has example","has feature","has method","has return type","has stability","has type","implements","is a","panics if","returns","see also","stable since"],"relation_triples":[["&'a u8","has associated type","u8"],["&'a u8","has method","shl"],["&'a u8","has method","shr<i128>"],["&'a u8","implements","Shl<i128>"],["&'a u8","implements","Shl<i32>"],["&'a u8","implements","Shl<u64>"],["&'a u8","implements","Shr<i128>"],["&'a u8","implements","Shr<i32>"],["&'a u8","implements","Shr<u16>"],["&'a u8","implements","Sub<u8>"],["&'b u8","has associated type","u8"],["&'b u8","has method","shl"],["&'b u8","has method","shr<&'a u32>"],["&'b u8","implements","Shl<&'a i128>"],["&'b u8","implements","Shl<&'a u128>"],["&'b u8","implements","Shl<&'a usize>"],["&'b u8","implements","Shr<&'a u32>"],["&'b u8","implements","Sub<&'a u8>"],["&'b u8::Sub<&'a u8>::sub","has argument","sub::other"],["&'b u8::Sub<&'a u8>::sub","has argument","sub::self"],["&'b u8::Sub<&'a u8>::sub","is a","method"],["Any","has method","get_type_id"],["BitXor<&'a u8>","has associated type","Output"],["BitXor<u8>","has associated type","Output"],["Borrow","has method","borrow"],["BorrowMut","has method","borrow_mut"],["Default","has method","default"],["Display for u8::fmt","has declaration","fn fmt(&self, f: &mut Formatter) -> Result<(), Error>"],["Display for u8::fmt","has description","Formats the value using the given formatter."],["From","has method","from"],["From","implements","From<T> for T"],["FromStr","has associated error","ParseIntError"],["H","implements","Hasher"],["Into","has method","into"],["LowerHex for u8::fmt","has declaration","fn fmt(&self, f: &mut Formatter) -> Result<(), Error>"],["LowerHex for u8::fmt","has description","Formats the value using the given formatter."],["Mul<u8>","has associated type","Output"],["Not","has associated type","Output"],["Octal","has method","fmt"],["Output","has type","<u8 as BitXor<u8>>::Output"],["Output","has type","<u8 as Shr<i32>>::Output"],["Output","has type","<u8 as Shr<u16>>::Output"],["Output","has type","<u8 as Sub<u8>>::Output"],["Output","has type","u8"],["Product<&'a u8> for u8::product","has declaration","fn product<I>(iter: I) -> u8 where I: Iterator<Item = &'a u8>"],["Product<&'a u8> for u8::product","has description","Method which takes an iterator and generates Self from the elements by multiplying the items."],["Product<u8> for u8::product","has declaration","fn product<I>(iter: I) -> u8 where I: Iterator<Item = u8>"],["Product<u8> for u8::product","has description","Method which takes an iterator and generates Self from the elements by multiplying the items."],["Rem<u8>","has associated type","Output"],["Shl<&'a i128> for &'b u8","has associated type","Output"],["Shl<&'a i128> for &'b u8::shl","has argument","other"],["Shl<&'a i128> for &'b u8::shl","has argument","self"],["Shl<&'a i128> for &'b u8::shl","has declaration","fn shl(self, other: &'a i128) -> <u8 as Shl<i128>>::Output"],["Shl<&'a i128> for &'b u8::shl","has description","Performs the << operation."],["Shl<&'a i128> for &'b u8::shl","has return type","<u8 as Shl<i128>>::Output"],["Shl<&'a i16> for u8","has associated type","Output"],["Shl<&'a i16> for u8::shl","has argument","other"],["Shl<&'a i16> for u8::shl","has argument","self"],["Shl<&'a i16> for u8::shl","has declaration","fn shl(self, other: &'a i16) -> <u8 as Shl<i16>>::Output"],["Shl<&'a i16> for u8::shl","has description","Performs the << operation."],["Shl<&'a i16> for u8::shl","has return type","<u8 as Shl<i16>>::Output"],["Shl<&'a u128> for &'b u8","has associated type","Output"],["Shl<&'a u128> for &'b u8","has method","shl"],["Shl<i128> for &'a u8","has associated type","Output"],["Shl<i128> for &'a u8","has method","shl"],["Shl<i32> for u8","has associated type","Output"],["Shl<i32> for u8","has method","shl"],["Shl<isize>","has associated type","Output"],["Shl<u128> for u8","has associated type","Output"],["Shl<u128> for u8::shl","has argument","other"],["Shl<u128> for u8::shl","has argument","self"],["Shl<u128> for u8::shl","has declaration","fn shl(self, other: u128) -> <u8 as Shl<u128>>::Output"],["Shl<u128> for u8::shl","has description","Performs the << operation."],["Shl<u128> for u8::shl","has return type","<u8 as Shl<u128>>::Output"],["Shl<u64> for &'a u8","has associated type","Output"],["Shl<u64> for &'a u8","has method","shl"],["Shl<usize> for u8","has associated type","Output"],["Shl<usize> for u8","has method","shl"],["ShlAssign<&'a i8>","stable since","1.22.0"],["ShlAssign<&'a u16>","stable since","1.22.0"],["ShlAssign<i8>","stable since","1.8.0"],["Shr<&'a u32>","has associated type","Output"],["Shr<&i16>::Output","has description","The resulting type after applying the >> operator."],["Shr<&i16>::shr","has argument","other"],["Shr<&i16>::shr","has description","Performs the >> operation."],["Shr<&i16>::shr","has return type","<u8 as Shr<i16>>::Output"],["Shr<&i8>::Output","has description","The resulting type after applying the >> operator."],["Shr<&i8>::shr","has argument","other"],["Shr<&i8>::shr","has description","Performs the >> operation."],["Shr<&i8>::shr","has return type","<u8 as Shr<i8>>::Output"],["Shr<&isize>::Output","has description","The resulting type after applying the >> operator."],["Shr<&isize>::shr","has argument","other"],["Shr<&isize>::shr","has description","Performs the >> operation."],["Shr<&isize>::shr","has return type","<u8 as Shr<isize>>::Output"],["Shr<i128>","has associated type","Output"],["Shr<i128>::Output","has description","The resulting type after applying the >> operator."],["Shr<i128>::shr","has argument","other"],["Shr<i128>::shr","has description","Performs the >> operation."],["Shr<i128>::shr","has return type","u8"],["Shr<i32> for &'a u8","has associated type","Output"],["Shr<u128>::Output","has description","The resulting type after applying the >> operator."],["Shr<u128>::shr","has argument","other"],["Shr<u128>::shr","has description","Performs the >> operation."],["Shr<u128>::shr","has return type","<u8 as Shr<u128>>::Output"],["Shr<u16> for &'a u8","has associated type","Output"],["Shr<u32>","has associated type","Output"],["Shr<u8> for u8","has associated type","Output"],["Sub<u8> for &'a u8","has associated type","Output"],["Sub<u8> for u8","has associated type","Output"],["ToOwned","has associated type","Owned"],["ToOwned","has method","clone_into"],["ToOwned","has method","to_owned"],["ToOwned::Owned","has type","T"],["ToString","has method","to_string"],["TryFrom","has associated type","Error"],["TryFrom","has method","try_from"],["TryFrom::Error","has type","!"],["TryInto","has associated type","Error"],["TryInto","has method","try_into"],["TryInto::Error","has type","<U as TryFrom<T>>::Error"],["bitxor","has argument","other"],["bitxor","has argument","self"],["bitxor","has description","Performs the ^ operation."],["bitxor","has return type","<u8 as BitXor<u8>>::Output"],["bitxor_assign","has argument","other"],["bitxor_assign","has argument","self"],["bitxor_assign","has description","Performs the ^= operation."],["bitxor_assign::other","has type","u8"],["bitxor_assign::self","has type","&mut u8"],["borrow","has description","Immutably borrows from an owned value."],["borrow","has return type","&T"],["borrow_mut","has description","Mutably borrows from an owned value."],["borrow_mut","has return type","&mut T"],["checked_pow","has argument","checked_pow::exp"],["checked_pow","has argument","checked_pow::self"],["checked_pow","has description","Checked exponentiation. Computes self.pow(exp), returning None if overflow occurred."],["checked_pow","has return type","Option<u8>"],["checked_pow","has stability","This is a nightly-only experimental API. (no_panic_pow #48320)"],["checked_pow::exp","has type","u32"],["checked_pow::self","has type","u8"],["clone","has description","Returns a copy of the value."],["clone","has return type","u8"],["clone","is a","function"],["clone_from","has argument","source"],["clone_from","has description","Performs copy-assignment from source."],["clone_from","is a","function"],["clone_into","has argument","target"],["clone_into","has description","Uses borrowed data to replace owned data, usually by cloning."],["clone_into","has feature","toowned_clone_into #41263"],["clone_into::target","has type","&mut T"],["cmp","has description","This method returns an Ordering between self and other."],["cmp","has return type","Ordering"],["count_ones","has argument","self"],["count_ones","has description","Returns the number of ones in the binary representation of self."],["count_ones","returns","u32"],["count_zeros","has argument","self"],["count_zeros","has description","Returns the number of zeros in the binary representation of self."],["count_zeros","returns","u32"],["data","has type","&[u8]"],["default","has description","Returns the default value of 0"],["default","has return type","u8"],["div","has description","This operation rounds towards zero, truncating any fractional part of the exact result."],["div","has return type","u8"],["eq_ignore_ascii_case","has argument","eq_ignore_ascii_case::other"],["eq_ignore_ascii_case","has declaration","pub fn eq_ignore_ascii_case(&self, other: &u8) -> bool"],["eq_ignore_ascii_case","has description","Checks that two values are an ASCII case-insensitive match."],["eq_ignore_ascii_case","has example","let lowercase_a = 97u8; let uppercase_a = 65u8; assert!(lowercase_a.eq_ignore_ascii_case(&uppercase_a));"],["eq_ignore_ascii_case","has return type","bool"],["eq_ignore_ascii_case","is a","function"],["eq_ignore_ascii_case","stable since","1.23.0"],["eq_ignore_ascii_case::other","has type","&u8"],["f","has type","&mut Formatter"],["fmt","has argument","f"],["fmt","has argument","self"],["fmt","has description","Formats the value using the given formatter."],["fmt","has return type","Result<(), Error>"],["from","has argument","t"],["from","has description","Performs the conversion."],["from","has return type","T"],["from::t","has type","T"],["from_be","has argument","x"],["from_be","has description","Converts an integer from big endian to the target's endianness."],["from_be","returns","u8"],["from_le","has argument","x"],["from_le","has description","Converts an integer from little endian to the target's endianness."],["from_le","returns","u8"],["from_str","has argument","src"],["from_str","has description","Parses a string s to return a value of this type."],["from_str","has return type","Result<u8, ParseIntError>"],["from_str","is a","function"],["from_str_radix","has argument","radix"],["from_str_radix","has argument","src"],["from_str_radix","has declaration","pub fn from_str_radix(src: &str, radix: u32) -> Result<u8, ParseIntError>"],["from_str_radix","has return type","Result<u8, ParseIntError>"],["get_type_id","has description","Gets the TypeId of self."],["get_type_id","has feature","get_type_id #27745"],["get_type_id","has return type","TypeId"],["hash","has argument","self"],["hash","has argument","state"],["hash","has description","Feeds this value into the given [Hasher]."],["hash","is a","function"],["hash_slice","has argument","data"],["hash_slice","has argument","state"],["hash_slice","has description","Feeds a slice of this type into the given [Hasher]."],["hash_slice","is a","function"],["into","has description","Performs the conversion."],["into","has return type","U"],["is_ascii","has declaration","pub fn is_ascii(&self) -> bool"],["is_ascii","has description","Checks if the value is within the ASCII range."],["is_ascii","has example","let ascii = 97u8; let non_ascii = 150u8; assert!(ascii.is_ascii()); assert!(!non_ascii.is_ascii());"],["is_ascii","has return type","bool"],["is_ascii","is a","function"],["is_ascii","stable since","1.23.0"],["is_ascii_alphabetic","has declaration","pub fn is_ascii_alphabetic(&self) -> bool"],["is_ascii_alphabetic","has description","Checks if the value is an ASCII alphabetic character: U+0041 'A' ... U+007A 'z'."],["is_ascii_alphabetic","has example","let uppercase_a = b'A'; let a = b'a'; assert!(uppercase_a.is_ascii_alphabetic()); assert!(a.is_ascii_alphabetic());"],["is_ascii_alphabetic","has return type","bool"],["is_ascii_alphabetic","is a","function"],["is_ascii_alphabetic","stable since","1.24.0"],["is_ascii_alphanumeric","has declaration","pub fn is_ascii_alphanumeric(&self) -> bool"],["is_ascii_alphanumeric","has description","Checks if the value is an ASCII alphanumeric character."],["is_ascii_alphanumeric","has example","let zero = b'0'; assert!(zero.is_ascii_alphanumeric());"],["is_ascii_alphanumeric","has return type","bool"],["is_ascii_alphanumeric","is a","function"],["is_ascii_alphanumeric","stable since","1.24.0"],["is_ascii_control","has declaration","pub fn is_ascii_control(&self) -> bool"],["is_ascii_control","has description","Checks if the value is an ASCII control character..."],["is_ascii_control","has return type","bool"],["is_ascii_control","is a","function"],["is_ascii_control","stable since","1.24.0"],["is_ascii_digit","has declaration","pub fn is_ascii_digit(&self) -> bool"],["is_ascii_digit","has description","Checks if the value is an ASCII decimal digit: U+0030 '0' ... U+0039 '9'."],["is_ascii_digit","has example","let zero = b'0'; assert!(zero.is_ascii_digit());"],["is_ascii_digit","has return type","bool"],["is_ascii_digit","is a","function"],["is_ascii_digit","stable since","1.24.0"],["is_ascii_graphic","has declaration","pub fn is_ascii_graphic(&self) -> bool"],["is_ascii_graphic","has description","Checks if the value is an ASCII graphic character: U+0021 '!' ... U+007E '~'."],["is_ascii_graphic","has example","let uppercase_a = b'A'; assert!(uppercase_a.is_ascii_graphic());"],["is_ascii_graphic","has return type","bool"],["is_ascii_graphic","is a","function"],["is_ascii_graphic","stable since","1.24.0"],["is_ascii_hexdigit","has declaration","pub fn is_ascii_hexdigit(&self) -> bool"],["is_ascii_hexdigit","has description","Checks if the value is an ASCII hexadecimal digit."],["is_ascii_hexdigit","has example","let uppercase_a = b'A'; assert!(uppercase_a.is_ascii_hexdigit());"],["is_ascii_hexdigit","has return type","bool"],["is_ascii_hexdigit","is a","function"],["is_ascii_hexdigit","stable since","1.24.0"],["is_ascii_lowercase","has declaration","pub fn is_ascii_lowercase(&self) -> bool"],["is_ascii_lowercase","has description","Checks if the value is an ASCII lowercase character: U+0061 'a' ... U+007A 'z'."],["is_ascii_lowercase","has example","let a = b'a'; assert!(a.is_ascii_lowercase());"],["is_ascii_lowercase","has return type","bool"],["is_ascii_lowercase","is a","function"],["is_ascii_lowercase","stable since","1.24.0"],["is_ascii_punctuation","has declaration","pub fn is_ascii_punctuation(&self) -> bool"],["is_ascii_punctuation","has description","Checks if the value is an ASCII punctuation character."],["is_ascii_punctuation","has example","let percent = b'%'; assert!(percent.is_ascii_punctuation());"],["is_ascii_punctuation","has return type","bool"],["is_ascii_punctuation","is a","function"],["is_ascii_punctuation","stable since","1.24.0"],["is_ascii_uppercase","has declaration","pub fn is_ascii_uppercase(&self) -> bool"],["is_ascii_uppercase","has description","Checks if the value is an ASCII uppercase character: U+0041 'A' ... U+005A 'Z'."],["is_ascii_uppercase","has example","let uppercase_a = b'A'; assert!(uppercase_a.is_ascii_uppercase());"],["is_ascii_uppercase","has return type","bool"],["is_ascii_uppercase","is a","function"],["is_ascii_uppercase","stable since","1.24.0"],["is_ascii_whitespace","has declaration","pub fn is_ascii_whitespace(&self) -> bool"],["is_ascii_whitespace","has description","Checks if the value is an ASCII whitespace character..."],["is_ascii_whitespace","has return type","bool"],["is_ascii_whitespace","is a","function"],["is_ascii_whitespace","stable since","1.24.0"],["leading_zeros","has argument","self"],["leading_zeros","has description","Returns the number of leading zeros in the binary representation of self."],["leading_zeros","returns","u32"],["make_ascii_lowercase","has declaration","pub fn make_ascii_lowercase(&mut self)"],["make_ascii_lowercase","has description","Converts this value to its ASCII lower case equivalent in-place."],["make_ascii_lowercase","has example","let mut byte = b'A'; byte.make_ascii_lowercase(); assert_eq!(b'a', byte);"],["make_ascii_lowercase","is a","function"],["make_ascii_lowercase","stable since","1.23.0"],["make_ascii_uppercase","has declaration","pub fn make_ascii_uppercase(&mut self)"],["make_ascii_uppercase","has description","Converts this value to its ASCII upper case equivalent in-place."],["make_ascii_uppercase","has example","let mut byte = b'a'; byte.make_ascii_uppercase(); assert_eq!(b'A', byte);"],["make_ascii_uppercase","is a","function"],["make_ascii_uppercase","stable since","1.23.0"],["max_value","has declaration","pub const fn max_value() -> u8"],["max_value","returns","255"],["min_value","has declaration","pub const fn min_value() -> u8"],["min_value","returns","0"],["mul","has description","Performs the * operation."],["mul","has return type","u8"],["n","has type","u32"],["not","has description","Performs the unary ! operation."],["not","has return type","u8"],["other","has type","&'a i8"],["other","has type","&'a u16"],["other","has type","&'a u32"],["other","has type","&'a u8"],["other","has type","&'a usize"],["other","has type","&i16"],["other","has type","&i8"],["other","has type","&isize"],["other","has type","i128"],["other","has type","i32"],["other","has type","i64"],["other","has type","i8"],["other","has type","u128"],["other","has type","u16"],["other","has type","u32"],["other","has type","u8"],["overflowing_div_euc","has argument","rhs"],["overflowing_div_euc","has argument","self"],["overflowing_div_euc","has description","Calculates the quotient of Euclidean division of self by rhs. Returns a tuple of the quotient along with a boolean indicating whether an arithmetic overflow would occur. Note that for unsigned integers overflow never occurs, so the second value is always false."],["overflowing_div_euc","has example","assert_eq!(5u8.overflowing_div_euc(2), (2, false));"],["overflowing_div_euc","has feature","euclidean_division"],["overflowing_div_euc","has return type","(u8, bool)"],["overflowing_div_euc","has stability","nightly-only experimental API (euclidean_division)"],["overflowing_div_euc","panics if","rhs is 0"],["overflowing_div_euc","see also","https://github.com/rust-lang/rust/issues/49048"],["overflowing_div_euc::rhs","has type","u8"],["overflowing_div_euc::self","has type","u8"],["overflowing_mod_euc","has argument","rhs"],["overflowing_mod_euc","has argument","self"],["overflowing_mod_euc","has description","Calculates the remainder self.mod_euc(rhs) by Euclidean division. Returns a tuple of the modulo after dividing along with a boolean indicating whether an arithmetic overflow would occur. Note that for unsigned integers overflow never occurs, so the second value is always false."],["overflowing_mod_euc","has example","assert_eq!(5u8.overflowing_mod_euc(2), (1, false));"],["overflowing_mod_euc","has feature","euclidean_division"],["overflowing_mod_euc","has return type","(u8, bool)"],["overflowing_mod_euc","has stability","nightly-only experimental API (euclidean_division)"],["overflowing_mod_euc","panics if","rhs is 0"],["overflowing_mod_euc","see also","https://github.com/rust-lang/rust/issues/49048"],["overflowing_mod_euc::rhs","has type","u8"],["overflowing_mod_euc::self","has type","u8"],["overflowing_neg","has argument","self"],["overflowing_neg","has description","Negates self in an overflowing fashion. Returns !self + 1 using wrapping operations to return the value that represents the negation of this unsigned value. Note that for positive unsigned values overflow always occurs, but negating 0 does not overflow."],["overflowing_neg","has example","assert_eq!(0u8.overflowing_neg(), (0, false)); assert_eq!(2u8.overflowing_neg(), (-2i32 as u8, true));"],["overflowing_neg","has return type","(u8, bool)"],["overflowing_neg","stable since","1.7.0"],["overflowing_neg::self","has type","u8"],["overflowing_pow","has argument","exp"],["overflowing_pow","has argument","self"],["overflowing_pow","has description","Raises self to the power of exp using exponentiation by squaring. Returns a tuple of the exponentiation along with a bool indicating whether an overflow happened."],["overflowing_pow","has example","assert_eq!(3u8.overflowing_pow(5), (243, false)); assert_eq!(3u8.overflowing_pow(6), (217, true));"],["overflowing_pow","has feature","no_panic_pow"],["overflowing_pow","has return type","(u8, bool)"],["overflowing_pow","has stability","nightly-only experimental API (no_panic_pow)"],["overflowing_pow","see also","https://github.com/rust-lang/rust/issues/48320"],["overflowing_pow::exp","has type","u32"],["overflowing_pow::self","has type","u8"],["overflowing_rem","has argument","rhs"],["overflowing_rem","has argument","self"],["overflowing_rem","has description","Calculates the remainder when self is divided by rhs. Returns a tuple of the remainder after dividing along with a boolean indicating whether an arithmetic overflow would occur. Note that for unsigned integers overflow never occurs, so the second value is always false."],["overflowing_rem","has example","assert_eq!(5u8.overflowing_rem(2), (1, false));"],["overflowing_rem","has return type","(u8, bool)"],["overflowing_rem","panics if","rhs is 0"],["overflowing_rem","stable since","1.7.0"],["overflowing_rem::rhs","has type","u8"],["overflowing_rem::self","has type","u8"],["overflowing_shl","has argument","rhs"],["overflowing_shl","has argument","self"],["overflowing_shl","has description","Shifts self left by rhs bits. Returns a tuple of the shifted version of self along with a boolean indicating whether the shift value was larger than or equal to the number of bits."],["overflowing_shl","has example","assert_eq!(0x1u8.overflowing_shl(4), (0x10, false)); assert_eq!(0x1u8.overflowing_shl(132), (0x10, true));"],["overflowing_shl","has return type","(u8, bool)"],["overflowing_shl","stable since","1.7.0"],["overflowing_shl::rhs","has type","u32"],["overflowing_shl::self","has type","u8"],["partial_cmp","has description","This method returns an ordering between self and other values if one exists."],["partial_cmp","has return type","Option<Ordering>"],["radix","has type","u32"],["rem","has description","Performs the % operation."],["rem","has return type","u8"],["reverse_bits","has argument","self"],["reverse_bits","has description","Reverses the bit pattern of the integer."],["reverse_bits","has stability","This is a nightly-only experimental API. (#48763)"],["reverse_bits","returns","u8"],["rotate_left","has argument","n"],["rotate_left","has argument","self"],["rotate_left","has description","Shifts the bits to the left by a specified amount, n, wrapping the truncated bits to the end of the resulting integer."],["rotate_left","returns","u8"],["rotate_right","has argument","n"],["rotate_right","has argument","self"],["rotate_right","has description","Shifts the bits to the right by a specified amount, n, wrapping the truncated bits to the beginning of the resulting integer."],["rotate_right","returns","u8"],["saturating_add","has argument","saturating_add::rhs"],["saturating_add","has argument","saturating_add::self"],["saturating_add","has description","Saturating integer addition. Computes self + rhs, saturating at the numeric bounds instead of overflowing."],["saturating_add","has return type","u8"],["saturating_add::rhs","has type","u8"],["saturating_add::self","has type","u8"],["saturating_mul","has argument","saturating_mul::rhs"],["saturating_mul","has argument","saturating_mul::self"],["saturating_mul","has description","Saturating integer multiplication. Computes self * rhs, saturating at the numeric bounds instead of overflowing."],["saturating_mul","has return type","u8"],["saturating_mul","stable since","1.7.0"],["saturating_mul::rhs","has type","u8"],["saturating_mul::self","has type","u8"],["saturating_pow","has argument","saturating_pow::exp"],["saturating_pow","has argument","saturating_pow::self"],["saturating_pow","has description","Saturating integer exponentiation. Computes self.pow(exp), saturating at the numeric bounds instead of overflowing."],["saturating_pow","has return type","u8"],["saturating_pow","has stability","This is a nightly-only experimental API. (no_panic_pow #48320)"],["saturating_pow::exp","has type","u32"],["saturating_pow::self","has type","u8"],["saturating_sub","has argument","saturating_sub::rhs"],["saturating_sub","has argument","saturating_sub::self"],["saturating_sub","has description","Saturating integer subtraction. Computes self - rhs, saturating at the numeric bounds instead of overflowing."],["saturating_sub","has return type","u8"],["saturating_sub::rhs","has type","u8"],["saturating_sub::self","has type","u8"],["self","has type","&'a u8"],["self","has type","&'b u8"],["self","has type","&u8"],["self","has type","u8"],["shl","has argument","&'a u128"],["shl","has argument","i128"],["shl","has argument","i32"],["shl","has argument","other"],["shl","has argument","self"],["shl","has argument","u64"],["shl","has argument","usize"],["shl","has description","Performs the << operation."],["shl","has return type","<u8 as Shl<i128>>::Output"],["shl","has return type","<u8 as Shl<u128>>::Output"],["shl","has return type","<u8 as Shl<u64>>::Output"],["shl","has return type","u8"],["shl_assign","has argument","other"],["shl_assign","has argument","self"],["shl_assign","has description","Performs the <<= operation."],["shl_assign","has return type","&mut Command"],["shl_assign::other","has type","u64"],["shl_assign::self","has type","&mut u8"],["shr","has argument","other"],["shr","has argument","self"],["shr","has description","Performs the >> operation."],["shr","has return type","<u8 as Shr<i32>>::Output"],["shr","has return type","u8"],["shr<&'a u32>","has argument","other"],["shr<&'a u32>","has argument","self"],["shr<&'a u32>","has description","Performs the >> operation."],["shr<&'a u32>","has return type","Output"],["shr<&'a u32>","is a","function"],["shr<i128>","has argument","other"],["shr<i128>","has argument","self"],["shr<i128>","has description","Performs the >> operation."],["shr<i128>","has return type","Output"],["shr<i128>","is a","function"],["shr<u32>","has argument","other"],["shr<u32>","has argument","self"],["shr<u32>","has description","Performs the >> operation."],["shr<u32>","has return type","Output"],["shr<u32>","is a","function"],["shr_assign::other","has type","u16"],["shr_assign::other","has type","u32"],["shr_assign::other","has type","u8"],["shr_assign::other","has type","usize"],["shr_assign::self","has type","&mut u8"],["source","has type","&Self"],["src","has type","&str"],["state","has type","&mut H"],["sub","has argument","other"],["sub","has argument","self"],["sub","has description","Performs the - operation."],["sub","has return type","<u8 as Sub<u8>>::Output"],["sub","has return type","u8"],["sub::other","has type","&'a u8"],["sub::self","has type","&'b u8"],["swap_bytes","has argument","self"],["swap_bytes","has description","Reverses the byte order of the integer."],["swap_bytes","returns","u8"],["to_ascii_lowercase","has declaration","pub fn to_ascii_lowercase(&self) -> u8"],["to_ascii_lowercase","has description","Makes a copy of the value in its ASCII lower case equivalent."],["to_ascii_lowercase","has example","let uppercase_a = 65u8; assert_eq!(97, uppercase_a.to_ascii_lowercase());"],["to_ascii_lowercase","has return type","u8"],["to_ascii_lowercase","is a","function"],["to_ascii_lowercase","see also","make_ascii_lowercase"],["to_ascii_lowercase","stable since","1.23.0"],["to_ascii_uppercase","has declaration","pub fn to_ascii_uppercase(&self) -> u8"],["to_ascii_uppercase","has description","Makes a copy of the value in its ASCII upper case equivalent."],["to_ascii_uppercase","has example","let lowercase_a = 97u8; assert_eq!(65, lowercase_a.to_ascii_uppercase());"],["to_ascii_uppercase","has return type","u8"],["to_ascii_uppercase","is a","function"],["to_ascii_uppercase","see also","make_ascii_uppercase"],["to_ascii_uppercase","stable since","1.23.0"],["to_be","has description","Converts self to big endian from the target's endianness."],["to_be","returns","u8"],["to_le","has description","Converts self to little endian from the target's endianness."],["to_le","returns","u8"],["to_owned","has description","Creates owned data from borrowed data, usually by cloning."],["to_owned","has return type","T"],["to_string","has description","Converts the given value to a String."],["to_string","has return type","String"],["trailing_zeros","has argument","self"],["trailing_zeros","has description","Returns the number of trailing zeros in the binary representation of self."],["trailing_zeros","returns","u32"],["try_from","has argument","value"],["try_from","has description","Performs the conversion."],["try_from","has feature","try_from #33417"],["try_from","has return type","Result<T, TryFrom::Error>"],["try_from::value","has type","U"],["try_into","has description","Performs the conversion."],["try_into","has feature","try_from #33417"],["try_into","has return type","Result<U, TryInto::Error>"],["u8","has associated type","Shr<&i16>::Output"],["u8","has associated type","Shr<&i8>::Output"],["u8","has associated type","Shr<&isize>::Output"],["u8","has associated type","Shr<i128>::Output"],["u8","has associated type","Shr<u128>::Output"],["u8","has associated type","u8"],["u8","has method","bitxor"],["u8","has method","checked_pow"],["u8","has method","count_ones"],["u8","has method","count_zeros"],["u8","has method","from_be"],["u8","has method","from_le"],["u8","has method","from_str_radix"],["u8","has method","leading_zeros"],["u8","has method","max_value"],["u8","has method","min_value"],["u8","has method","mul"],["u8","has method","not"],["u8","has method","overflowing_div_euc"],["u8","has method","overflowing_mod_euc"],["u8","has method","overflowing_neg"],["u8","has method","overflowing_pow"],["u8","has method","overflowing_rem"],["u8","has method","overflowing_shl"],["u8","has method","rem"],["u8","has method","reverse_bits"],["u8","has method","rotate_left"],["u8","has method","rotate_right"],["u8","has method","saturating_add"],["u8","has method","saturating_mul"],["u8","has method","saturating_pow"],["u8","has method","saturating_sub"],["u8","has method","shl"],["u8","has method","shr<u32>"],["u8","has method","swap_bytes"],["u8","has method","to_be"],["u8","has method","to_le"],["u8","has method","trailing_zeros"],["u8","implements","AddAssign<u8>"],["u8","implements","BitAnd<&'a u8>"],["u8","implements","BitAnd<u8>"],["u8","implements","BitXor<&'a u8>"],["u8","implements","BitXor<u8>"],["u8","implements","BitXorAssign<u8>"],["u8","implements","Clone"],["u8","implements","Copy"],["u8","implements","Default"],["u8","implements","Display"],["u8","implements","Div<u8>"],["u8","implements","DivAssign<u8>"],["u8","implements","From<NonZeroU8>"],["u8","implements","From<bool>"],["u8","implements","FromStr"],["u8","implements","Hash"],["u8","implements","LowerHex"],["u8","implements","Mul<u8>"],["u8","implements","MulAssign<&u8>"],["u8","implements","Not"],["u8","implements","Octal"],["u8","implements","Ord"],["u8","implements","PartialOrd<u8>"],["u8","implements","Product<&'a u8>"],["u8","implements","Product<u8>"],["u8","implements","Rem<u8>"],["u8","implements","RemAssign<&u8>"],["u8","implements","RemAssign<u8>"],["u8","implements","Shl<&'a i16>"],["u8","implements","Shl<i32>"],["u8","implements","Shl<i64>"],["u8","implements","Shl<isize>"],["u8","implements","Shl<u128>"],["u8","implements","Shl<usize>"],["u8","implements","ShlAssign<&'a i8>"],["u8","implements","ShlAssign<&'a u16>"],["u8","implements","ShlAssign<i8>"],["u8","implements","ShlAssign<u64>"],["u8","implements","Shr<&i16>"],["u8","implements","Shr<&i8>"],["u8","implements","Shr<&isize>"],["u8","implements","Shr<i128>"],["u8","implements","Shr<u128>"],["u8","implements","Shr<u32>"],["u8","implements","Shr<u8>"],["u8","implements","ShrAssign<u16>"],["u8","implements","ShrAssign<u32>"],["u8","implements","ShrAssign<u8>"],["u8","implements","ShrAssign<usize>"],["u8","implements","Sub<u8>"],["u8","implements","SubAssign<u8>"],["u8","implements","TryFrom<i128>"],["u8","implements","TryFrom<i16>"],["u8","implements","TryFrom<i32>"],["u8","implements","TryFrom<i64>"],["u8","implements","TryFrom<i8>"],["u8","implements","TryFrom<isize>"],["u8","implements","TryFrom<u128>"],["u8","implements","TryFrom<u16>"],["u8","implements","TryFrom<u32>"],["u8","implements","TryFrom<u64>"],["u8","implements","TryFrom<usize>"],["u8","is a","primitive type"],["u8","see also","std::u8 module"],["u8","stable since","1.0.0"],["u8","stable since","1.8.0"],["u8::FromStr","has associated type","ParseIntError"],["u8::ShrAssign<u16>::shr_assign","has argument","shr_assign::other"],["u8::ShrAssign<u16>::shr_assign","has argument","shr_assign::self"],["u8::ShrAssign<u16>::shr_assign","is a","method"],["u8::ShrAssign<u16>::shr_assign","stable since","1.8.0"],["u8::ShrAssign<u32>::shr_assign","has argument","shr_assign::other"],["u8::ShrAssign<u32>::shr_assign","has argument","shr_assign::self"],["u8::ShrAssign<u32>::shr_assign","is a","method"],["u8::ShrAssign<u32>::shr_assign","stable since","1.8.0"],["u8::ShrAssign<u8>::shr_assign","has argument","shr_assign::other"],["u8::ShrAssign<u8>::shr_assign","has argument","shr_assign::self"],["u8::ShrAssign<u8>::shr_assign","is a","method"],["u8::ShrAssign<u8>::shr_assign","stable since","1.8.0"],["u8::ShrAssign<usize>::shr_assign","has argument","shr_assign::other"],["u8::ShrAssign<usize>::shr_assign","has argument","shr_assign::self"],["u8::ShrAssign<usize>::shr_assign","is a","method"],["u8::ShrAssign<usize>::shr_assign","stable since","1.8.0"],["u8::TryFrom<i16>","has associated type","TryFromIntError"],["u8::bitand","has argument","other"],["u8::bitand","has argument","self"],["u8::bitand","has return type","u8"],["u8::bitand","is a","method"],["u8::bitand::other","has type","u8"],["u8::from_str","has argument","src"],["u8::from_str","has return type","Result<u8, ParseIntError>"],["u8::from_str::src","has type","&str"],["u8::try_from","has argument","u"],["u8::try_from","has return type","Result<u8, TryFromIntError>"],["u8::try_from::u","has type","i16"],["x","has type","u8"]],"links":["../../../../std/process/struct.Command.html","../alloc/index.html","../core/index.html","../proc_macro/index.html","../src/core/clone.rs.html","../src/core/cmp.rs.html","../src/core/convert.rs.html","../src/core/fmt/num.rs.html","../src/core/hash/mod.rs.html","../src/core/internal_macros.rs.html","../src/core/iter/traits.rs.html","../src/core/num/mod.rs.html","../src/core/ops/arith.rs.html","../src/core/ops/bit.rs.html","../std/any/struct.TypeId.html","../std/any/trait.Any.html","../std/borrow/trait.Borrow.html","../std/borrow/trait.BorrowMut.html","../std/borrow/trait.ToOwned.html","../std/clone/trait.Clone.html","../std/cmp/trait.Ord.html","../std/cmp/trait.PartialOrd.html","../std/convert/trait.From.html","../std/convert/trait.TryFrom.html","../std/convert/trait.TryInto.html","../std/default/trait.Default.html","../std/fmt/struct.Error.html","../std/fmt/struct.Formatter.html","../std/fmt/trait.Octal.html","../std/hash/trait.Hash.html","../std/index.html","../std/marker/trait.Copy.html","../std/num/struct.ParseIntError.html","../std/ops/trait.BitXor.html","../std/ops/trait.BitXorAssign.html","../std/ops/trait.Div.html","../std/ops/trait.Mul.html","../std/ops/trait.Not.html","../std/ops/trait.Rem.html","../std/ops/trait.Shl.html","../std/ops/trait.ShlAssign.html","../std/ops/trait.Shr.html","../std/ops/trait.Sub.html","../std/option/enum.Option.html","../std/result/enum.Result.html","../std/str/trait.FromStr.html","../std/string/struct.String.html","../std/string/trait.ToString.html","../test/index.html","any/index.html","arch/index.html","ascii/index.html","borrow/index.html","boxed/index.html","cell/index.html","char/index.html","clone/index.html","cmp/index.html","collections/index.html","convert/index.html","default/index.html","env/index.html","error/index.html","f32/index.html","f64/index.html","ffi/index.html","fmt/index.html","fs/index.html","future/index.html","hash/index.html","hint/index.html","https://github.com/rust-lang/rust/issues/48320","https://github.com/rust-lang/rust/issues/49048","https://play.rust-lang.org/","i128/index.html","i16/index.html","i32/index.html","i64/index.html","i8/index.html","intrinsics/index.html","io/index.html","isize/index.html","iter/index.html","keyword.as.html","macro.assert.html","marker/index.html","mem/index.html","net/index.html","num/index.html","ops/index.html","option/index.html","os/index.html","panic/index.html","path/index.html","pin/index.html","prelude/index.html","primitive.array.html","primitive.bool.html","primitive.i32.html","primitive.i64.html","primitive.i8.html","primitive.isize.html","primitive.tuple.html","primitive.u16.html","primitive.u32.html","primitive.u64.html","primitive.u8.html","primitive.usize.html","process/index.html","ptr/index.html","raw/index.html","rc/index.html","result/index.html","slice/index.html","str/index.html","string/index.html","sync/index.html","task/index.html","thread/index.html","time/index.html","u128/index.html","u16/index.html","u32/index.html","u64/index.html","u8/index.html","usize/index.html","vec/index.html"],"metrics":{"escapeCount":1,"costTime":4358748,"totalUsage":{"prompt_tokens":306681,"completion_tokens":112998,"cached_tokens":0,"reasoning_tokens":96001},"chunkLength":19,"chunksInfo":[{"contextLength":0,"contentLength":39000,"costTime":136159},{"contextLength":500,"contentLength":39000,"costTime":76454},{"contextLength":500,"contentLength":39000,"costTime":144425},{"contextLength":500,"contentLength":39000,"costTime":312552},{"contextLength":500,"contentLength":39000,"costTime":317506},{"contextLength":500,"contentLength":39000,"costTime":155273},{"contextLength":500,"contentLength":39000,"costTime":515187},{"contextLength":500,"contentLength":39000,"costTime":309904},{"contextLength":500,"contentLength":39000,"costTime":282755},{"contextLength":500,"contentLength":39000,"costTime":219827},{"contextLength":500,"contentLength":39000,"costTime":229017},{"contextLength":500,"contentLength":39000,"costTime":378208},{"contextLength":500,"contentLength":39000,"costTime":238012},{"contextLength":500,"contentLength":39000,"costTime":230513},{"contextLength":500,"contentLength":39000,"costTime":53577},{"contextLength":500,"contentLength":39000,"costTime":324885},{"contextLength":500,"contentLength":39000,"costTime":263422},{"contextLength":500,"contentLength":39000,"costTime":77723},{"contextLength":500,"contentLength":21853,"costTime":93349}]},"model":"deepseek-r1-250120","extraInfo":{"startTime":"2025-03-23T07:43:01.096Z","examGroup":"split","examParams":{"windowLength":39000}}}