{
  "create_time": "2025-03-23T08:36:56.641Z",
  "id": "0d6461a4-e124-4575-9e32-2185b3e54aa1",
  "source_url": "file:///C:/Users/Dj/.rustup/toolchains/1.30-x86_64-pc-windows-msvc/share/doc/rust/html/std/primitive.slice.html",
  "relations": [
    "deprecated",
    "has argument",
    "has associated type",
    "has declaration",
    "has description",
    "has example",
    "has full name",
    "has method",
    "has parameter",
    "has return type",
    "has source code",
    "has stability",
    "has type",
    "implements",
    "is a",
    "related to module",
    "returns",
    "stable since"
  ],
  "relation_triples": [
    ["&'a [SocketAddr]", "implements", "ToSocketAddrs"],
    ["&'a [T]", "implements", "Default"],
    ["&'a [T]", "implements", "IntoIterator"],
    ["&'a mut [T]", "implements", "IntoIterator"],
    ["&'a mut [u8]", "implements", "Write"],
    ["&'b [B]", "has method", "eq"],
    ["&'b [B]", "has method", "ne"],
    ["&'b [B]", "implements", "PartialEq<[A; 10]>"],
    ["&'b [B]", "implements", "PartialEq<[A; 15]>"],
    ["&'b [B]", "implements", "PartialEq<[A; 16]>"],
    ["&'b [B]", "implements", "PartialEq<[A; 17]>"],
    ["&'b [B]", "implements", "PartialEq<[A; 18]>"],
    ["&'b [B]", "implements", "PartialEq<[A; 19]>"],
    ["&'b [B]", "implements", "PartialEq<[A; 1]>"],
    ["&'b [B]", "implements", "PartialEq<[A; 20]>"],
    ["&'b [B]", "implements", "PartialEq<[A; 21]>"],
    ["&'b [B]", "implements", "PartialEq<[A; 24]>"],
    ["&'b [B]", "implements", "PartialEq<[A; 26]>"],
    ["&'b [B]", "implements", "PartialEq<[A; 27]>"],
    ["&'b [B]", "implements", "PartialEq<[A; 28]>"],
    ["&'b [B]", "implements", "PartialEq<[A; 2]>"],
    ["&'b [B]", "implements", "PartialEq<[A; 30]>"],
    ["&'b [B]", "implements", "PartialEq<[A; 32]>"],
    ["&'b [B]", "implements", "PartialEq<[A; 4]>"],
    ["&'b [B]", "implements", "PartialEq<[A; 5]>"],
    ["&'b [B]", "implements", "PartialEq<[A; 6]>"],
    ["&'b [B]", "implements", "PartialEq<[A; 8]>"],
    ["&'b [char]", "implements", "Pattern<'a>"],
    ["&'b mut [B]", "has method", "eq"],
    ["&'b mut [B]", "implements", "PartialEq<[A; 11]>"],
    ["&'b mut [B]", "implements", "PartialEq<[A; 13]>"],
    ["&'b mut [B]", "implements", "PartialEq<[A; 14]>"],
    ["&'b mut [B]", "implements", "PartialEq<[A; 15]>"],
    ["&'b mut [B]", "implements", "PartialEq<[A; 16]>"],
    ["&'b mut [B]", "implements", "PartialEq<[A; 17]>"],
    ["&'b mut [B]", "implements", "PartialEq<[A; 1]>"],
    ["&'b mut [B]", "implements", "PartialEq<[A; 21]>"],
    ["&'b mut [B]", "implements", "PartialEq<[A; 23]>"],
    ["&'b mut [B]", "implements", "PartialEq<[A; 25]>"],
    ["&'b mut [B]", "implements", "PartialEq<[A; 26]>"],
    ["&'b mut [B]", "implements", "PartialEq<[A; 27]>"],
    ["&'b mut [B]", "implements", "PartialEq<[A; 29]>"],
    ["&'b mut [B]", "implements", "PartialEq<[A; 31]>"],
    ["&'b mut [B]", "implements", "PartialEq<[A; 32]>"],
    ["&'b mut [B]", "implements", "PartialEq<[A; 3]>"],
    ["&'b mut [B]", "implements", "PartialEq<[A; 5]>"],
    ["&'b mut [B]", "implements", "PartialEq<[A; 8]>"],
    ["&[T]", "has method", "cmp"],
    ["&[T]", "has method", "max"],
    ["&[T]", "has method", "min"],
    ["&mut [B]", "has method", "eq"],
    ["&mut [B]", "has method", "ne"],
    ["&mut [B]", "implements", "PartialEq<[A; 10]>"],
    ["&mut [B]", "implements", "PartialEq<[A; 30]>"],
    ["AsMut<[T]>", "implements", "AsMut trait for [T]"],
    ["AsRef<[T]>", "has method", "as_ref"],
    ["B", "implements", "PartialEq<A>"],
    ["BufRead", "has method", "lines"],
    ["Chunks<T>", "has full name", "std::slice::Chunks<T>"],
    ["Chunks<T>", "implements", "Iterator"],
    ["ChunksMut<T>", "has full name", "std::slice::ChunksMut<T>"],
    ["ChunksMut<T>", "implements", "Iterator"],
    ["Default for &'a [T]", "has description", "Creates an empty slice."],
    ["Default", "has method", "default"],
    ["ExactChunks<T>", "has full name", "std::slice::ExactChunks<T>"],
    ["ExactChunks<T>", "implements", "Iterator"],
    ["ExactChunksMut<T>", "has full name", "std::slice::ExactChunksMut<T>"],
    ["ExactChunksMut<T>", "implements", "Iterator"],
    ["I", "implements", "SliceIndex<[T]>"],
    ["Item", "has type", "Result<String>"],
    ["Iter", "has type", "Cloned<Iter<'a, SocketAddr>>"],
    ["Iter<'a, T>", "is a", "iterator"],
    ["IterMut<'a, T>", "is a", "iterator"],
    ["Lines<B>", "has associated type", "Item"],
    ["Lines<B>", "implements", "Iterator"],
    ["Output", "has type", "String"],
    ["Output", "is a", "Vec<T>"],
    ["Owned", "has type", "Vec<T>"],
    ["Owned", "has type", "Vec<u8>"],
    ["PartialEq<[A; 8]>", "has method", "eq"],
    ["PartialEq<[A; 8]>", "has method", "ne"],
    ["Pattern<'a>", "has associated type", "Searcher"],
    [
      "Pattern<'a>",
      "has description",
      "Searches for chars that are equal to any of the chars in the array"
    ],
    ["Pattern<'a>", "has method", "into_searcher"],
    ["RSplit<T, F>", "implements", "Iterator"],
    ["RSplit<T, F>", "is a", "struct"],
    ["RSplitMut<T, F>", "implements", "Iterator"],
    ["RSplitMut<T, F>", "is a", "struct"],
    ["RSplitN<T, F>", "implements", "Iterator"],
    ["RSplitN<T, F>", "is a", "struct"],
    ["RSplitNMut<T, F>", "implements", "Iterator"],
    ["RSplitNMut<T, F>", "is a", "struct"],
    ["Searcher", "is a", "CharSliceSearcher<'a, 'b>"],
    ["SliceConcatExt<T>", "has associated type", "Output"],
    ["SliceConcatExt<T>", "has method", "concat"],
    ["SliceConcatExt<T>", "has method", "join"],
    ["SplitN<T, F>", "implements", "Iterator"],
    ["SplitN<T, F>", "is a", "struct"],
    ["SplitNMut<T, F>", "implements", "Iterator"],
    ["SplitNMut<T, F>", "is a", "struct"],
    ["T", "implements", "Ord"],
    ["ToSocketAddrs", "has associated type", "Iter"],
    ["Windows<T>", "implements", "Iterator"],
    ["Write", "has method", "by_ref"],
    ["Write", "has method", "flush"],
    ["Write", "has method", "write"],
    ["Write", "has method", "write_all"],
    ["Write", "has method", "write_fmt"],
    ["[B]", "has method", "eq"],
    ["[B]", "has method", "ne"],
    ["[B]", "implements", "PartialEq<[A; 0]>"],
    ["[B]", "implements", "PartialEq<[A; 11]>"],
    ["[B]", "implements", "PartialEq<[A; 14]>"],
    ["[B]", "implements", "PartialEq<[A; 16]>"],
    ["[B]", "implements", "PartialEq<[A; 17]>"],
    ["[B]", "implements", "PartialEq<[A; 18]>"],
    ["[B]", "implements", "PartialEq<[A; 19]>"],
    ["[B]", "implements", "PartialEq<[A; 1]>"],
    ["[B]", "implements", "PartialEq<[A; 21]>"],
    ["[B]", "implements", "PartialEq<[A; 22]>"],
    ["[B]", "implements", "PartialEq<[A; 24]>"],
    ["[B]", "implements", "PartialEq<[A; 29]>"],
    ["[B]", "implements", "PartialEq<[A; 30]>"],
    ["[B]", "implements", "PartialEq<[A; 4]>"],
    ["[B]", "implements", "PartialEq<[A; 5]>"],
    ["[B]", "implements", "PartialEq<[A; 6]>"],
    ["[B]", "implements", "PartialEq<[A; 7]>"],
    ["[B]", "implements", "PartialEq<[A; 9]>"],
    ["[T]", "has method", "fmt"],
    ["[T]", "implements", "AsRef<[T]>"],
    ["[T]", "implements", "Debug"],
    ["[T]", "implements", "Hash where T: Hash"],
    ["[T]", "implements", "IndexMut<I> where I: SliceIndex<[T]>"],
    ["[T]", "implements", "Ord where T: Ord"],
    ["[T]", "implements", "PartialOrd where T: PartialOrd"],
    ["[V]", "implements", "SliceConcatExt<T>"],
    [
      "align_to",
      "has description",
      "Transmute the slice to a slice of another type, ensuring alignment of the types is maintained."
    ],
    ["align_to", "has return type", "(&[T], &[U], &[T])"],
    ["align_to", "is a", "function"],
    ["align_to", "stable since", "1.30.0"],
    [
      "align_to_mut",
      "has description",
      "Transmute the slice to a slice of another type, ensuring alignment of the types is maintained."
    ],
    ["align_to_mut", "has return type", "(&mut [T], &mut [U], &mut [T])"],
    ["align_to_mut", "is a", "function"],
    ["align_to_mut", "stable since", "1.30.0"],
    ["as_mut", "has return type", "&mut [T]"],
    [
      "as_ptr",
      "has description",
      "Returns a raw pointer to the slice's buffer."
    ],
    [
      "as_ptr",
      "has example",
      "let x = &[1, 2, 4]; let x_ptr = x.as_ptr(); unsafe { for i in 0..x.len() { assert_eq!(x.get_unchecked(i), &*x_ptr.add(i)); } }"
    ],
    ["as_ptr", "is a", "method"],
    ["as_ptr", "returns", "*const T"],
    ["as_ref", "has parameter", "self"],
    ["as_ref", "has return type", "&[T]"],
    ["b", "has type", "&B"],
    [
      "binary_search",
      "has declaration",
      "pub fn binary_search(&self, x: &T) -> Result<usize, usize> where T: Ord"
    ],
    [
      "binary_search",
      "has description",
      "Binary searches this sorted slice for a given element. If the value is found then Ok is returned, containing the index of the matching element; if the value is not found then Err is returned, containing the index where a matching element could be inserted while maintaining sorted order."
    ],
    [
      "binary_search",
      "has example",
      "let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]; assert_eq!(s.binary_search(&13), Ok(9)); assert_eq!(s.binary_search(&4), Err(7)); assert_eq!(s.binary_search(&100), Err(13)); let r = s.binary_search(&1); assert!(match r { Ok(1..=4) => true, _ => false });"
    ],
    ["binary_search", "has parameter", "x"],
    ["binary_search", "has return type", "Result<usize, usize>"],
    [
      "binary_search_by",
      "has declaration",
      "pub fn binary_search_by<'a, F>(&'a self, f: F) -> Result<usize, usize> where F: FnMut(&'a T) -> Ordering"
    ],
    [
      "binary_search_by",
      "has description",
      "Binary searches this sorted slice with a comparator function. The comparator function should implement an order consistent with the sort order of the underlying slice, returning an order code that indicates whether its argument is Less, Equal or Greater the desired target."
    ],
    [
      "binary_search_by",
      "has example",
      "let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]; let seek = 13; assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Ok(9)); let seek = 4; assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(7)); let seek = 100; assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(13)); let seek = 1; let r = s.binary_search_by(|probe| probe.cmp(&seek)); assert!(match r { Ok(1..=4) => true, _ => false });"
    ],
    ["binary_search_by", "has parameter", "f"],
    ["binary_search_by", "has return type", "Result<usize, usize>"],
    [
      "binary_search_by_key",
      "has declaration",
      "pub fn binary_search_by_key<'a, B, F>(&'a self, b: &B, f: F) -> Result<usize, usize> where B: Ord, F: FnMut(&'a T) -> B"
    ],
    [
      "binary_search_by_key",
      "has description",
      "Binary searches this sorted slice with a key extraction function. Assumes that the slice is sorted by the key, for instance with sort_by_key using the same key extraction function."
    ],
    [
      "binary_search_by_key",
      "has example",
      "let s = [(0, 0), (2, 1), (4, 1), (5, 1), (3, 1), (1, 2), (2, 3), (4, 5), (5, 8), (3, 13), (1, 21), (2, 34), (4, 55)]; assert_eq!(s.binary_search_by_key(&13, |&(a,b)| b), Ok(9)); assert_eq!(s.binary_search_by_key(&4, |&(a,b)| b), Err(7)); assert_eq!(s.binary_search_by_key(&100, |&(a,b)| b), Err(13)); let r = s.binary_search_by_key(&1, |&(a,b)| b); assert!(match r { Ok(1..=4) => true, _ => false });"
    ],
    ["binary_search_by_key", "has parameter", "b"],
    ["binary_search_by_key", "has parameter", "f"],
    ["binary_search_by_key", "has return type", "Result<usize, usize>"],
    ["binary_search_by_key", "stable since", "1.10.0"],
    ["by_ref", "has return type", "&mut Self"],
    ["chunk_size", "has type", "usize"],
    [
      "chunks",
      "has description",
      "Returns an iterator over chunk_size elements of the slice at a time. The chunks are slices and do not overlap."
    ],
    ["chunks", "has parameter", "chunk_size"],
    ["chunks", "has return type", "Chunks<T>"],
    [
      "chunks_mut",
      "has description",
      "Returns an iterator over chunk_size elements of the slice at a time. The chunks are mutable slices, and do not overlap."
    ],
    ["chunks_mut", "has parameter", "chunk_size"],
    ["chunks_mut", "has return type", "ChunksMut<T>"],
    [
      "clone_from_slice",
      "has declaration",
      "pub fn clone_from_slice(&mut self, src: &[T]) where T: Clone"
    ],
    [
      "clone_from_slice",
      "has description",
      "Copies the elements from src into self. The length of src must be the same as self. If src implements Copy, it can be more performant to use copy_from_slice."
    ],
    [
      "clone_from_slice",
      "has example",
      "let src = [1, 2, 3, 4]; let mut dst = [0, 0]; dst.clone_from_slice(&src[2..]); assert_eq!(src, [1, 2, 3, 4]); assert_eq!(dst, [3, 4]);"
    ],
    ["clone_from_slice", "stable since", "1.7.0"],
    [
      "clone_into",
      "has stability",
      "nightly-only experimental API: toowned_clone_into #41263"
    ],
    [
      "cmp",
      "has description",
      "This method returns an Ordering between self and other."
    ],
    ["cmp", "has parameter", "other"],
    ["cmp", "has parameter", "self"],
    ["cmp", "has return type", "Ordering"],
    ["compare", "has type", "FnMut(&T, &T) -> Ordering"],
    ["concat", "has return type", "String"],
    ["concat", "has return type", "Vec<T>"],
    [
      "concat",
      "has stability",
      "nightly-only experimental API: slice_concat_ext #27747"
    ],
    ["connect", "deprecated", "Deprecated since 1.3.0: renamed to join"],
    [
      "contains",
      "has description",
      "Returns true if the slice contains an element with the given value."
    ],
    [
      "contains",
      "has example",
      "let v = [10, 40, 30]; assert!(v.contains(&30)); assert!(!v.contains(&50));"
    ],
    ["contains", "has parameter", "contains::x"],
    ["contains", "has return type", "bool"],
    ["contains", "is a", "method"],
    ["contains::x", "has type", "&T"],
    [
      "copy_from_slice",
      "has description",
      "Copies all elements from src into self, using a memcpy."
    ],
    [
      "copy_from_slice",
      "has example",
      "let src = [1, 2, 3, 4]; let mut dst = [0, 0]; dst.copy_from_slice(&src[2..]); assert_eq!(src, [1, 2, 3, 4]); assert_eq!(dst, [3, 4]);"
    ],
    ["copy_from_slice", "has parameter", "src"],
    ["copy_from_slice", "is a", "function"],
    ["copy_from_slice", "stable since", "1.9.0"],
    ["data", "has type", "&[u8]"],
    ["default", "has return type", "&'a [T]"],
    [
      "ends_with",
      "has description",
      "Returns true if needle is a suffix of the slice."
    ],
    [
      "ends_with",
      "has example",
      "let v = [10, 40, 30]; assert!(v.ends_with(&[30])); assert!(v.ends_with(&[40, 30]));..."
    ],
    ["ends_with", "has parameter", "ends_with::needle"],
    ["ends_with", "has return type", "bool"],
    ["ends_with", "is a", "method"],
    ["ends_with::needle", "has type", "&[T]"],
    ["eq", "has argument", "eq::other"],
    ["eq", "has argument", "eq::self"],
    [
      "eq",
      "has description",
      "This method tests for `self` and `other` values to be equal, and is used by `==`."
    ],
    [
      "eq",
      "has description",
      "This method tests for self and other values to be equal, and is used by =="
    ],
    [
      "eq",
      "has description",
      "This method tests for self and other values to be equal, and is used by ==. Read more"
    ],
    ["eq", "has parameter", "eq::other"],
    ["eq", "has parameter", "eq::self"],
    ["eq", "has parameter", "other"],
    ["eq", "has parameter", "other: &[A; 8]"],
    ["eq", "has parameter", "self"],
    ["eq", "has return type", "bool"],
    ["eq::other", "has type", "&[A; 16]"],
    ["eq::other", "has type", "&[A; 21]"],
    ["eq::other", "has type", "&[A; 30]"],
    ["eq::self", "has type", "&self"],
    [
      "eq_ignore_ascii_case",
      "has description",
      "Checks that two slices are an ASCII case-insensitive match."
    ],
    ["eq_ignore_ascii_case", "has parameter", "other"],
    ["eq_ignore_ascii_case", "has return type", "bool"],
    ["eq_ignore_ascii_case", "is a", "function"],
    ["eq_ignore_ascii_case", "stable since", "1.23.0"],
    ["exact_chunks", "has parameter", "chunk_size"],
    ["exact_chunks", "has return type", "ExactChunks<T>"],
    [
      "exact_chunks",
      "has stability",
      "This is a nightly-only experimental API. (exact_chunks #47115)"
    ],
    ["exact_chunks_mut", "has parameter", "chunk_size"],
    ["exact_chunks_mut", "has return type", "ExactChunksMut<T>"],
    [
      "exact_chunks_mut",
      "has stability",
      "This is a nightly-only experimental API. (exact_chunks #47115)"
    ],
    ["f", "has type", "&mut Formatter"],
    ["f", "has type", "FnMut(&'a T) -> B"],
    ["f", "has type", "FnMut(&'a T) -> Ordering"],
    ["f", "has type", "FnMut(&T) -> K"],
    [
      "first",
      "has description",
      "Returns the first element of the slice, or None if it is empty."
    ],
    ["first", "returns", "Option<&T>"],
    [
      "first_mut",
      "has description",
      "Returns a mutable pointer to the first element of the slice, or None if it is empty."
    ],
    ["first_mut", "returns", "Option<&mut T>"],
    ["flush", "has return type", "Result<()>"],
    ["fmt", "has description", "Formats the value using the given formatter."],
    ["fmt", "has parameter", "f"],
    ["fmt", "has parameter", "self"],
    ["fmt", "has return type", "Result<(), Error>"],
    ["fmt", "has type", "Arguments"],
    [
      "get",
      "has description",
      "Returns a reference to an element or subslice depending on the type of index."
    ],
    [
      "get",
      "has example",
      "let v = [10, 40, 30]; assert_eq!(Some(&40), v.get(1)); assert_eq!(Some(&[10, 40][..]), v.get(0..2));"
    ],
    ["get", "has parameter", "get::index"],
    ["get", "is a", "method"],
    ["get", "returns", "Option<&<I as SliceIndex<[T]>>::Output>"],
    ["get::index", "has type", "I"],
    [
      "get_mut",
      "has description",
      "Returns a mutable reference to an element or subslice depending on the type of index"
    ],
    [
      "get_mut",
      "has example",
      "let x = &mut [0, 1, 2]; if let Some(elem) = x.get_mut(1) { *elem = 42; } assert_eq!(x, &[0, 42, 2]);"
    ],
    ["get_mut", "has parameter", "get_mut::index"],
    ["get_mut", "is a", "method"],
    ["get_mut", "returns", "Option<&mut <I as SliceIndex<[T]>>::Output>"],
    ["get_mut::index", "has type", "I"],
    [
      "impl AsciiExt",
      "deprecated",
      "Deprecated since 1.26.0: use inherent methods instead"
    ],
    ["impl AsciiExt", "has associated type", "Owned"],
    ["impl AsciiExt", "has method", "is_ascii"],
    ["impl AsciiExt", "has method", "to_ascii_uppercase"],
    ["impl<'a> BufRead", "has method", "fill_buf"],
    ["impl<'a> BufRead", "implements", "BufRead trait"],
    ["impl<'a> Read", "has method", "read"],
    ["impl<'a> Read", "implements", "Read trait"],
    ["impl<S> SliceConcatExt<str>", "has associated type", "Output"],
    ["impl<S> SliceConcatExt<str>", "has method", "concat"],
    ["impl<S> SliceConcatExt<str>", "has method", "connect"],
    ["impl<S> SliceConcatExt<str>", "has method", "join"],
    ["impl<T> ToOwned", "has associated type", "Owned"],
    ["impl<T> ToOwned", "has method", "clone_into"],
    ["impl<T> ToOwned", "has method", "to_owned"],
    ["into_searcher", "has parameter", "haystack: &'a str"],
    ["into_searcher", "has parameter", "self"],
    ["into_searcher", "has return type", "CharSliceSearcher<'a, 'b>"],
    [
      "into_vec",
      "has description",
      "Converts self into a vector without clones or allocation."
    ],
    ["into_vec", "has parameter", "self: Box<[T]>"],
    ["into_vec", "has return type", "Vec<T>"],
    [
      "is_ascii",
      "has description",
      "Checks if all bytes in this slice are within the ASCII range."
    ],
    ["is_ascii", "has return type", "bool"],
    ["is_ascii", "is a", "function"],
    ["is_ascii", "stable since", "1.23.0"],
    [
      "is_empty",
      "has description",
      "Returns true if the slice has a length of 0."
    ],
    ["is_empty", "returns", "bool"],
    ["join", "has parameter", "sep: &T"],
    ["join", "has parameter", "sep: &str"],
    ["join", "has return type", "String"],
    ["join", "has return type", "Vec<T>"],
    [
      "last",
      "has description",
      "Returns the last element of the slice, or None if it is empty."
    ],
    [
      "last",
      "has example",
      "let v = [10, 40, 30]; assert_eq!(Some(&30), v.last()); let w: &[i32] = &[]; assert_eq!(None, w.last());"
    ],
    ["last", "is a", "method"],
    ["last", "returns", "Option<&T>"],
    [
      "last_mut",
      "has description",
      "Returns a mutable pointer to the last item in the slice."
    ],
    [
      "last_mut",
      "has example",
      "let x = &mut [0, 1, 2]; if let Some(last) = x.last_mut() { *last = 10; } assert_eq!(x, &[0, 1, 10]);"
    ],
    ["last_mut", "is a", "method"],
    ["last_mut", "returns", "Option<&mut T>"],
    ["len", "has description", "Returns the number of elements in the slice."],
    ["len", "returns", "usize"],
    ["lines", "has parameter", "self"],
    ["lines", "returns", "Lines<Self>"],
    [
      "make_ascii_lowercase",
      "has description",
      "Converts this slice to its ASCII lower case equivalent in-place."
    ],
    ["make_ascii_lowercase", "is a", "function"],
    ["make_ascii_lowercase", "stable since", "1.23.0"],
    [
      "make_ascii_uppercase",
      "has description",
      "Converts this slice to its ASCII upper case equivalent in-place."
    ],
    ["make_ascii_uppercase", "is a", "function"],
    ["make_ascii_uppercase", "stable since", "1.23.0"],
    [
      "max",
      "has description",
      "Compares and returns the maximum of two values."
    ],
    ["max", "has return type", "Self"],
    ["max", "stable since", "1.21.0"],
    ["mid", "has type", "usize"],
    [
      "min",
      "has description",
      "Compares and returns the minimum of two values."
    ],
    ["min", "has return type", "Self"],
    ["min", "stable since", "1.21.0"],
    ["ne", "has argument", "ne::other"],
    ["ne", "has argument", "ne::self"],
    ["ne", "has description", "This method tests for !="],
    ["ne", "has description", "This method tests for !=."],
    ["ne", "has description", "This method tests for `!=`."],
    ["ne", "has parameter", "ne::other"],
    ["ne", "has parameter", "ne::self"],
    ["ne", "has parameter", "other"],
    ["ne", "has parameter", "other: &[A; 8]"],
    ["ne", "has parameter", "self"],
    ["ne", "has return type", "bool"],
    ["ne::other", "has type", "&[A; 16]"],
    ["ne::other", "has type", "&[A; 21]"],
    ["ne::other", "has type", "&[A; 30]"],
    ["ne::self", "has type", "&self"],
    ["other", "has type", "&[A; 10]"],
    ["other", "has type", "&[A; 11]"],
    ["other", "has type", "&[A; 18]"],
    ["other", "has type", "&[A; 24]"],
    ["other", "has type", "&[A; 26]"],
    ["other", "has type", "&[A; 30]"],
    ["other", "has type", "&[A; 31]"],
    ["other", "has type", "&[T]"],
    ["other", "has type", "&[u8]"],
    ["other", "has type", "&mut [T]"],
    ["pred", "has type", "FnMut(&T) -> bool"],
    ["read", "has parameter", "buf: &mut [u8]"],
    [
      "repeat",
      "has example",
      "assert_eq!([1, 2].repeat(3), vec![1, 2, 1, 2, 1, 2]);"
    ],
    ["repeat", "has return type", "Vec<T>"],
    [
      "repeat",
      "has stability",
      "This is a nightly-only experimental API. (repeat_generic_slice #48784)"
    ],
    ["repeat::n", "has type", "usize"],
    [
      "rotate_left",
      "has declaration",
      "pub fn rotate_left(&mut self, mid: usize)"
    ],
    [
      "rotate_left",
      "has description",
      "Rotates the slice in-place such that the first mid elements of the slice move to the end while the last self.len() - mid elements move to the front. After calling rotate_left, the element previously at index mid will become the first element in the slice."
    ],
    [
      "rotate_left",
      "has example",
      "let mut a = ['a', 'b', 'c', 'd', 'e', 'f']; a.rotate_left(2); assert_eq!(a, ['c', 'd', 'e', 'f', 'a', 'b']);"
    ],
    ["rotate_left", "stable since", "1.26.0"],
    [
      "rotate_right",
      "has declaration",
      "pub fn rotate_right(&mut self, k: usize)"
    ],
    [
      "rotate_right",
      "has description",
      "Rotates the slice in-place such that the first self.len() - k elements of the slice move to the end while the last k elements move to the front. After calling rotate_right, the element previously at index self.len() - k will become the first element in the slice."
    ],
    [
      "rotate_right",
      "has example",
      "let mut a = ['a', 'b', 'c', 'd', 'e', 'f']; a.rotate_right(2); assert_eq!(a, ['e', 'f', 'a', 'b', 'c', 'd']);"
    ],
    ["rotate_right", "stable since", "1.26.0"],
    [
      "rsplit",
      "has description",
      "Returns an iterator over subslices separated by elements that match pred, starting at the end of the slice and working backwards. The matched element is not contained in the subslices."
    ],
    [
      "rsplit",
      "has example",
      "let slice = [11, 22, 33, 0, 44, 55]; let mut iter = slice.rsplit(|num| *num == 0); assert_eq!(iter.next().unwrap(), &[44, 55]);..."
    ],
    ["rsplit", "has parameter", "rsplit::pred"],
    ["rsplit", "has return type", "RSplit<T, F>"],
    ["rsplit", "is a", "method"],
    ["rsplit", "stable since", "1.27.0"],
    ["rsplit::pred", "has type", "FnMut(&T) -> bool"],
    [
      "rsplit_mut",
      "has description",
      "Returns an iterator over mutable subslices separated by elements that match pred, starting at the end of the slice and working backwards. The matched element is not contained in the subslices."
    ],
    [
      "rsplit_mut",
      "has example",
      "let mut v = [100, 400, 300, 200, 600, 500]; let mut count = 0; for group in v.rsplit_mut..."
    ],
    ["rsplit_mut", "has parameter", "rsplit_mut::pred"],
    ["rsplit_mut", "has return type", "RSplitMut<T, F>"],
    ["rsplit_mut", "is a", "method"],
    ["rsplit_mut", "stable since", "1.27.0"],
    ["rsplit_mut::pred", "has type", "FnMut(&T) -> bool"],
    [
      "rsplitn",
      "has description",
      "Returns an iterator over subslices separated by elements that match pred limited to returning at most n items. This starts at the end of the slice and works backwards. The matched element is not contained in the subslices."
    ],
    [
      "rsplitn",
      "has example",
      "let v = [10, 40, 30, 20, 60, 50]; for group in v.rsplitn(2, |num| *num % 3 == 0) { println!(\"{:?}\", group); }"
    ],
    ["rsplitn", "has parameter", "rsplitn::n"],
    ["rsplitn", "has parameter", "rsplitn::pred"],
    ["rsplitn", "has return type", "RSplitN<T, F>"],
    ["rsplitn", "is a", "method"],
    ["rsplitn::n", "has type", "usize"],
    ["rsplitn::pred", "has type", "FnMut(&T) -> bool"],
    [
      "rsplitn_mut",
      "has description",
      "Returns an iterator over subslices separated by elements that match pred limited to returning at most n items. This starts at the end of the slice and works backwards. The matched element is not contained in the subslices."
    ],
    [
      "rsplitn_mut",
      "has example",
      "let mut s = [10, 40, 30, 20, 60, 50]; for group in s.rsplitn_mut(2, |num| *num % 3 == 0) { group[0] = 1; } assert_eq!(s, [1, 40, 30, 20, 60, 1]);"
    ],
    ["rsplitn_mut", "has parameter", "rsplitn_mut::n"],
    ["rsplitn_mut", "has parameter", "rsplitn_mut::pred"],
    ["rsplitn_mut", "has return type", "RSplitNMut<T, F>"],
    ["rsplitn_mut", "is a", "method"],
    ["rsplitn_mut::n", "has type", "usize"],
    ["rsplitn_mut::pred", "has type", "FnMut(&T) -> bool"],
    ["self", "has type", "&[T]"],
    ["size", "has type", "usize"],
    [
      "slice",
      "has description",
      "A dynamically-sized view into a contiguous sequence, [T]"
    ],
    ["slice", "has method", "chunks"],
    ["slice", "has method", "chunks_mut"],
    ["slice", "has method", "exact_chunks"],
    ["slice", "has method", "exact_chunks_mut"],
    ["slice", "has method", "first"],
    ["slice", "has method", "first_mut"],
    ["slice", "has method", "is_empty"],
    ["slice", "has method", "len"],
    ["slice", "has method", "split"],
    ["slice", "has method", "split_at"],
    ["slice", "has method", "split_first"],
    ["slice", "has method", "split_first_mut"],
    ["slice", "has method", "windows"],
    ["slice", "is a", "primitive type"],
    ["slice", "related to module", "std::slice"],
    ["sort", "has description", "Sorts the slice."],
    ["sort", "is a", "function"],
    [
      "sort_by",
      "has description",
      "Sorts the slice with a comparator function."
    ],
    ["sort_by", "has parameter", "compare"],
    ["sort_by", "is a", "function"],
    [
      "sort_by_key",
      "has description",
      "Sorts the slice with a key extraction function."
    ],
    ["sort_by_key", "has parameter", "f"],
    ["sort_by_key", "is a", "function"],
    ["sort_by_key", "stable since", "1.7.0"],
    [
      "sort_unstable",
      "has declaration",
      "pub fn sort_unstable(&mut self) where T: Ord"
    ],
    [
      "sort_unstable",
      "has description",
      "Sorts the slice, but may not preserve the order of equal elements. This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate), and O(n log n) worst-case."
    ],
    [
      "sort_unstable",
      "has example",
      "let mut v = [-5, 4, 1, -3, 2]; v.sort_unstable(); assert!(v == [-5, -3, 1, 2, 4]);"
    ],
    ["sort_unstable", "stable since", "1.20.0"],
    [
      "sort_unstable_by",
      "has declaration",
      "pub fn sort_unstable_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering"
    ],
    [
      "sort_unstable_by",
      "has description",
      "Sorts the slice with a comparator function, but may not preserve the order of equal elements. This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate), and O(n log n) worst-case."
    ],
    [
      "sort_unstable_by",
      "has example",
      "let mut v = [5, 4, 1, 3, 2]; v.sort_unstable_by(|a, b| a.cmp(b)); assert!(v == [1, 2, 3, 4, 5]); v.sort_unstable_by(|a, b| b.cmp(a)); assert!(v == [5, 4, 3, 2, 1]);"
    ],
    ["sort_unstable_by", "stable since", "1.20.0"],
    [
      "sort_unstable_by_key",
      "has declaration",
      "pub fn sort_unstable_by_key<K, F>(&mut self, f: F) where F: FnMut(&T) -> K, K: Ord"
    ],
    [
      "sort_unstable_by_key",
      "has description",
      "Sorts the slice with a key extraction function, but may not preserve the order of equal elements. This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate), and O(m n log(m n)) worst-case, where the key function is O(m)."
    ],
    [
      "sort_unstable_by_key",
      "has example",
      "let mut v = [-5i32, 4, 1, -3, 2]; v.sort_unstable_by_key(|k| k.abs()); assert!(v == [1, 2, -3, 4, -5]);"
    ],
    ["sort_unstable_by_key", "stable since", "1.20.0"],
    [
      "split",
      "has description",
      "Returns an iterator over subslices separated by elements that match pred."
    ],
    ["split", "has parameter", "pred"],
    ["split", "has return type", "Split<T, F>"],
    ["split_at", "has description", "Divides one slice into two at an index."],
    ["split_at", "has parameter", "mid"],
    ["split_at", "has return type", "(&[T], &[T])"],
    [
      "split_first",
      "has description",
      "Returns the first and all the rest of the elements of the slice, or None if it is empty."
    ],
    ["split_first", "returns", "Option<(&T, &[T])>"],
    [
      "split_first_mut",
      "has description",
      "Returns the first and all the rest of the elements of the slice, or None if it is empty."
    ],
    ["split_first_mut", "returns", "Option<(&mut T, &mut [T])>"],
    [
      "split_last",
      "has description",
      "Returns the last and all the rest of the elements of the slice, or None if it is empty."
    ],
    [
      "split_last",
      "has example",
      "let x = &[0, 1, 2]; if let Some((last, elements)) = x.split_last() { assert_eq!(last, &2); assert_eq!(elements, &[0, 1]); }"
    ],
    ["split_last", "is a", "method"],
    ["split_last", "returns", "Option<(T, &[T])>"],
    ["split_last", "stable since", "1.5.0"],
    [
      "split_last_mut",
      "has description",
      "Returns the last and all the rest of the elements of the slice, or None if it is empty."
    ],
    [
      "split_last_mut",
      "has example",
      "let x = &mut [0, 1, 2]; if let Some((last, elements)) = x.split_last_mut() { *last = 3; elements[0] = 4; elements[1] = 5; } assert_eq!(x, &[4, 5, 3]);"
    ],
    ["split_last_mut", "is a", "method"],
    ["split_last_mut", "returns", "Option<(&mut T, &mut [T])>"],
    ["split_last_mut", "stable since", "1.5.0"],
    [
      "splitn",
      "has description",
      "Returns an iterator over subslices separated by elements that match pred, limited to returning at most n items. The matched element is not contained in the subslices."
    ],
    [
      "splitn",
      "has example",
      "let v = [10, 40, 30, 20, 60, 50]; for group in v.splitn(2, |num| *num % 3 == 0) { println!(\"{:?}\", group); }"
    ],
    ["splitn", "has parameter", "splitn::n"],
    ["splitn", "has parameter", "splitn::pred"],
    ["splitn", "has return type", "SplitN<T, F>"],
    ["splitn", "is a", "method"],
    ["splitn::n", "has type", "usize"],
    ["splitn::pred", "has type", "FnMut(&T) -> bool"],
    [
      "splitn_mut",
      "has description",
      "Returns an iterator over subslices separated by elements that match pred, limited to returning at most n items. The matched element is not contained in the subslices."
    ],
    [
      "splitn_mut",
      "has example",
      "let mut v = [10, 40, 30, 20, 60, 50]; for group in v.splitn_mut(2, |num| *num % 3 == 0) { group[0] = 1; } assert_eq!(v, [1, 40, 30, 1, 60, 50]);"
    ],
    ["splitn_mut", "has parameter", "splitn_mut::n"],
    ["splitn_mut", "has parameter", "splitn_mut::pred"],
    ["splitn_mut", "has return type", "SplitNMut<T, F>"],
    ["splitn_mut", "is a", "method"],
    ["splitn_mut::n", "has type", "usize"],
    ["splitn_mut::pred", "has type", "FnMut(&T) -> bool"],
    ["src", "has type", "&[T]"],
    [
      "starts_with",
      "has description",
      "Returns true if needle is a prefix of the slice."
    ],
    [
      "starts_with",
      "has example",
      "let v = [10, 40, 30]; assert!(v.starts_with(&[10])); assert!(v.starts_with(&[10, 40]));..."
    ],
    ["starts_with", "has parameter", "starts_with::needle"],
    ["starts_with", "has return type", "bool"],
    ["starts_with", "is a", "method"],
    ["starts_with::needle", "has type", "&[T]"],
    [
      "swap_with_slice",
      "has description",
      "Swaps all elements in self with those in other."
    ],
    [
      "swap_with_slice",
      "has example",
      "let mut slice1 = [0, 0]; let mut slice2 = [1, 2, 3, 4]; slice1.swap_with_slice(&mut slice2[2..]); assert_eq!(slice1, [3, 4]); assert_eq!(slice2, [1, 2, 0, 0]);"
    ],
    ["swap_with_slice", "has parameter", "other"],
    ["swap_with_slice", "is a", "function"],
    ["swap_with_slice", "stable since", "1.27.0"],
    ["to_ascii_lowercase", "has return type", "Vec<u8>"],
    ["to_ascii_lowercase", "stable since", "1.23.0"],
    ["to_ascii_uppercase", "has return type", "Vec<u8>"],
    ["to_ascii_uppercase", "stable since", "1.23.0"],
    ["to_owned", "has return type", "Vec<T>"],
    ["to_socket_addrs", "has return type", "Result<Iter>"],
    ["to_vec", "has description", "Copies self into a new Vec."],
    ["to_vec", "has example", "let s = [10, 40, 30]; let x = s.to_vec();"],
    [
      "windows",
      "has description",
      "Returns an iterator over overlapping subslices of length `size`."
    ],
    ["windows", "has parameter", "size"],
    ["windows", "has return type", "Windows<T>"],
    ["write", "has parameter", "data"],
    ["write", "has return type", "Result<usize>"],
    ["write_all", "has parameter", "data"],
    ["write_all", "has return type", "Result<()>"],
    ["write_fmt", "has parameter", "fmt"],
    ["write_fmt", "has return type", "Result<()>"],
    ["x", "has type", "&T"]
  ],
  "links": [
    "../../../primitive.usize.html",
    "../../std/clone/trait.Clone.html",
    "../../std/cmp/enum.Ordering.html",
    "../../std/cmp/trait.Ord.html",
    "../../std/ops/trait.FnMut.html",
    "../../std/result/enum.Result.html",
    "../alloc/index.html",
    "../core/index.html",
    "../proc_macro/index.html",
    "../src/alloc/slice.rs.html",
    "../src/alloc/str.rs.html",
    "../src/core/array.rs.html",
    "../src/core/cmp.rs.html",
    "../src/core/convert.rs.html",
    "../src/core/slice/mod.rs.html",
    "../src/core/str/pattern.rs.html",
    "../src/std/ascii.rs.html",
    "../src/std/io/impls.rs.html",
    "../src/std/io/mod.rs.html",
    "../src/std/net/addr.rs.html",
    "../std/ascii/trait.AsciiExt.html",
    "../std/borrow/trait.Borrow.html",
    "../std/boxed/struct.Box.html",
    "../std/clone/trait.Clone.html",
    "../std/cmp/enum.Ordering.html",
    "../std/cmp/trait.Ord.html",
    "../std/cmp/trait.PartialEq.html",
    "../std/cmp/trait.PartialOrd.html",
    "../std/convert/trait.AsMut.html",
    "../std/fmt/struct.Arguments.html",
    "../std/fmt/struct.Error.html",
    "../std/fmt/struct.Formatter.html",
    "../std/fmt/trait.Debug.html",
    "../std/hash/trait.Hash.html",
    "../std/index.html",
    "../std/io/struct.Lines.html",
    "../std/io/trait.BufRead.html",
    "../std/io/trait.Write.html",
    "../std/io/type.Result.html",
    "../std/iter/struct.Cloned.html",
    "../std/iter/trait.IntoIterator.html",
    "../std/iter/trait.Iterator.html",
    "../std/marker/trait.Copy.html",
    "../std/marker/trait.Sized.html",
    "../std/net/enum.SocketAddr.html",
    "../std/ops/trait.FnMut.html",
    "../std/ops/trait.Index.html",
    "../std/ops/trait.IndexMut.html",
    "../std/option/enum.Option.html",
    "../std/primitive.pointer.html",
    "../std/primitive.u8.html",
    "../std/primitive.unit.html",
    "../std/primitive.usize.html",
    "../std/process/struct.Command.html",
    "../std/result/enum.Result.html",
    "../std/slice/struct.Chunks.html",
    "../std/slice/struct.ChunksMut.html",
    "../std/slice/struct.ExactChunks.html",
    "../std/slice/struct.ExactChunksMut.html",
    "../std/slice/struct.Iter.html",
    "../std/slice/struct.RSplit.html",
    "../std/slice/struct.RSplitMut.html",
    "../std/slice/struct.RSplitN.html",
    "../std/slice/struct.RSplitNMut.html",
    "../std/slice/struct.Split.html",
    "../std/slice/struct.SplitMut.html",
    "../std/slice/struct.SplitN.html",
    "../std/slice/struct.SplitNMut.html",
    "../std/slice/trait.SliceIndex.html",
    "../std/string/struct.String.html",
    "../std/vec/struct.Vec.html",
    "../test/index.html",
    "alloc/index.html",
    "any/index.html",
    "arch/index.html",
    "ascii/index.html",
    "borrow/index.html",
    "boxed/index.html",
    "cell/index.html",
    "char/index.html",
    "clone/index.html",
    "cmp/index.html",
    "collections/index.html",
    "convert/index.html",
    "default/index.html",
    "env/index.html",
    "error/index.html",
    "f32/index.html",
    "f64/index.html",
    "ffi/index.html",
    "fmt/index.html",
    "fs/index.html",
    "future/index.html",
    "hash/index.html",
    "hint/index.html",
    "i128/index.html",
    "i16/index.html",
    "i32/index.html",
    "i64/index.html",
    "i8/index.html",
    "intrinsics/index.html",
    "io/index.html",
    "isize/index.html",
    "iter/index.html",
    "keyword.fn.html",
    "keyword.let.html",
    "keyword.struct.html",
    "macro.assert.html",
    "macro.assert_eq.html",
    "macro.assert_ne.html",
    "macro.await.html",
    "macro.cfg.html",
    "macro.column.html",
    "macro.compile_error.html",
    "macro.concat.html",
    "macro.concat_idents.html",
    "macro.debug_assert.html",
    "macro.debug_assert_eq.html",
    "macro.debug_assert_ne.html",
    "macro.env.html",
    "macro.eprint.html",
    "macro.eprintln.html",
    "macro.file.html",
    "macro.format.html",
    "macro.format_args.html",
    "macro.include.html",
    "macro.include_bytes.html",
    "macro.include_str.html",
    "macro.is_aarch64_feature_detected.html",
    "macro.is_arm_feature_detected.html",
    "macro.is_mips64_feature_detected.html",
    "macro.is_mips_feature_detected.html",
    "macro.is_powerpc64_feature_detected.html",
    "macro.is_powerpc_feature_detected.html",
    "macro.is_x86_feature_detected.html",
    "macro.line.html",
    "macro.module_path.html",
    "macro.option_env.html",
    "macro.panic.html",
    "macro.print.html",
    "macro.println.html",
    "macro.select.html",
    "macro.stringify.html",
    "macro.thread_local.html",
    "macro.try.html",
    "macro.unimplemented.html",
    "macro.unreachable.html",
    "macro.vec.html",
    "macro.write.html",
    "macro.writeln.html",
    "marker/index.html",
    "mem/index.html",
    "net/index.html",
    "num/index.html",
    "ops/index.html",
    "option/index.html",
    "os/index.html",
    "panic/index.html",
    "path/index.html",
    "pin/index.html",
    "prelude/index.html",
    "primitive.array.html",
    "primitive.bool.html",
    "primitive.char.html",
    "primitive.f32.html",
    "primitive.f64.html",
    "primitive.fn.html",
    "primitive.i128.html",
    "primitive.i16.html",
    "primitive.i32.html",
    "primitive.i64.html",
    "primitive.i8.html",
    "primitive.isize.html",
    "primitive.never.html",
    "primitive.pointer.html",
    "primitive.reference.html",
    "primitive.slice.html",
    "primitive.str.html",
    "primitive.tuple.html",
    "primitive.u128.html",
    "primitive.u16.html",
    "primitive.u32.html",
    "primitive.u64.html",
    "primitive.u8.html",
    "primitive.unit.html",
    "primitive.usize.html",
    "process/index.html",
    "ptr/index.html",
    "raw/index.html",
    "rc/index.html",
    "result/index.html",
    "slice/index.html",
    "str/index.html",
    "string/index.html",
    "sync/index.html",
    "task/index.html",
    "thread/index.html",
    "time/index.html",
    "u128/index.html",
    "u16/index.html",
    "u32/index.html",
    "u64/index.html",
    "u8/index.html",
    "usize/index.html",
    "vec/index.html"
  ],
  "metrics": {
    "escapeCount": 1,
    "costTime": 3229001,
    "totalUsage": {
      "prompt_tokens": 270690,
      "completion_tokens": 83811,
      "cached_tokens": 0,
      "reasoning_tokens": 67034
    },
    "chunkLength": 17,
    "chunksInfo": [
      { "contextLength": 0, "contentLength": 39000, "costTime": 281612 },
      { "contextLength": 500, "contentLength": 39000, "costTime": 129104 },
      { "contextLength": 500, "contentLength": 39000, "costTime": 197944 },
      { "contextLength": 500, "contentLength": 39000, "costTime": 261627 },
      { "contextLength": 500, "contentLength": 39000, "costTime": 129910 },
      { "contextLength": 500, "contentLength": 39000, "costTime": 276768 },
      { "contextLength": 500, "contentLength": 39000, "costTime": 89706 },
      { "contextLength": 500, "contentLength": 39000, "costTime": 256555 },
      { "contextLength": 500, "contentLength": 39000, "costTime": 222903 },
      { "contextLength": 500, "contentLength": 39000, "costTime": 59631 },
      { "contextLength": 500, "contentLength": 39000, "costTime": 363383 },
      { "contextLength": 500, "contentLength": 39000, "costTime": 187282 },
      { "contextLength": 500, "contentLength": 39000, "costTime": 86546 },
      { "contextLength": 500, "contentLength": 39000, "costTime": 393297 },
      { "contextLength": 500, "contentLength": 39000, "costTime": 164110 },
      { "contextLength": 500, "contentLength": 39000, "costTime": 67529 },
      { "contextLength": 500, "contentLength": 13345, "costTime": 61094 }
    ]
  },
  "model": "deepseek-r1-250120",
  "extraInfo": {
    "startTime": "2025-03-23T07:43:00.825Z",
    "examGroup": "split",
    "examParams": { "windowLength": 39000 }
  }
}
