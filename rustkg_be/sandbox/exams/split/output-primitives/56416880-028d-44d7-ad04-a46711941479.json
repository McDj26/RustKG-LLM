{"create_time":"2025-03-23T08:35:43.136Z","id":"56416880-028d-44d7-ad04-a46711941479","source_url":"file:///C:/Users/Dj/.rustup/toolchains/1.31-x86_64-pc-windows-msvc/share/doc/rust/html/std/primitive.slice.html","relations":["defined in module","has argument","has associated type","has attribute","has declaration","has description","has example","has method","has parameter","has return type","has stability","has trait implementation","has type","implements","is a","requires trait","requires where clause","returns","stable since"],"relation_triples":[["&'_ [T]","implements","Default"],["&'_ mut [T]","implements","Default"],["&'a [T]","implements","IntoIterator"],["&'a mut [T]","implements","IntoIterator"],["&'b [B]","has method","eq"],["&'b [B]","has method","ne"],["&'b [B]","implements","PartialEq<[A; 0]>"],["&'b [B]","implements","PartialEq<[A; 10]>"],["&'b [B]","implements","PartialEq<[A; 11]>"],["&'b [B]","implements","PartialEq<[A; 12]>"],["&'b [B]","implements","PartialEq<[A; 13]>"],["&'b [B]","implements","PartialEq<[A; 14]>"],["&'b [B]","implements","PartialEq<[A; 16]>"],["&'b [B]","implements","PartialEq<[A; 18]>"],["&'b [B]","implements","PartialEq<[A; 19]>"],["&'b [B]","implements","PartialEq<[A; 20]>"],["&'b [B]","implements","PartialEq<[A; 23]>"],["&'b [B]","implements","PartialEq<[A; 24]>"],["&'b [B]","implements","PartialEq<[A; 26]>"],["&'b [B]","implements","PartialEq<[A; 27]>"],["&'b [B]","implements","PartialEq<[A; 28]>"],["&'b [B]","implements","PartialEq<[A; 29]>"],["&'b [B]","implements","PartialEq<[A; 2]>"],["&'b [B]","implements","PartialEq<[A; 32]>"],["&'b [B]","implements","PartialEq<[A; 3]>"],["&'b [B]","implements","PartialEq<[A; 4]>"],["&'b [B]","implements","PartialEq<[A; 5]>"],["&'b [B]","implements","PartialEq<[A; 6]>"],["&'b [B]","implements","PartialEq<[A; 8]>"],["&'b [B]","implements","PartialEq<[A; 9]>"],["&'b [char]","implements","Pattern<'a>"],["&'b mut [B]","has method","eq"],["&'b mut [B]","has method","ne"],["&'b mut [B]","implements","PartialEq<[A; 10]>"],["&'b mut [B]","implements","PartialEq<[A; 12]>"],["&'b mut [B]","implements","PartialEq<[A; 14]>"],["&'b mut [B]","implements","PartialEq<[A; 15]>"],["&'b mut [B]","implements","PartialEq<[A; 18]>"],["&'b mut [B]","implements","PartialEq<[A; 19]>"],["&'b mut [B]","implements","PartialEq<[A; 1]>"],["&'b mut [B]","implements","PartialEq<[A; 21]>"],["&'b mut [B]","implements","PartialEq<[A; 22]>"],["&'b mut [B]","implements","PartialEq<[A; 23]>"],["&'b mut [B]","implements","PartialEq<[A; 24]>"],["&'b mut [B]","implements","PartialEq<[A; 26]>"],["&'b mut [B]","implements","PartialEq<[A; 27]>"],["&'b mut [B]","implements","PartialEq<[A; 28]>"],["&'b mut [B]","implements","PartialEq<[A; 30]>"],["&'b mut [B]","implements","PartialEq<[A; 31]>"],["&'b mut [B]","implements","PartialEq<[A; 32]>"],["&'b mut [B]","implements","PartialEq<[A; 3]>"],["&'b mut [B]","implements","PartialEq<[A; 5]>"],["&'b mut [B]","implements","PartialEq<[A; 8]>"],["&'b mut [B]","implements","PartialEq<[A; 9]>"],["&mut [B]","has method","eq"],["&mut [B]","has method","ne"],["&mut [B]","implements","PartialEq<[A; 17]>"],["AsciiExt for [u8]","has associated type","Owned = Vec<u8>"],["B","implements","Ord"],["B","requires trait","PartialEq<A>"],["BufRead for &'a [u8]","has method","fill_buf"],["BufRead","has method","lines"],["BufRead","has method","read_line"],["BufRead","has method","read_until"],["BufRead","has method","split"],["Chunks","defined in module","std::slice"],["ChunksExact","is a","struct"],["IntoIterator for &'a [T]","has associated type","IntoIter = Iter<'a, T>"],["IntoIterator for &'a [T]","has associated type","Item = &'a T"],["IntoIterator for &'a mut [T]","has associated type","IntoIter = IterMut<'a, T>"],["IntoIterator for &'a mut [T]","has associated type","Item = &'a mut T"],["Iter","has type","Cloned<Iter<'a, SocketAddr>>"],["Lines","implements","Iterator"],["PartialEq<[A; 0]>","has method","eq"],["PartialEq<[A; 0]>","has method","ne"],["PartialEq<[A; 11]>","defined in module","../src/core/array.rs.html"],["PartialEq<[A; 13]>","defined in module","../src/core/array.rs.html"],["PartialEq<[A; 15]>","defined in module","../src/core/array.rs.html"],["PartialEq<[A; 20]>","defined in module","../src/core/array.rs.html"],["PartialEq<[A; 24]>","defined in module","../src/core/array.rs.html"],["PartialEq<[A; 26]>","defined in module","../src/core/array.rs.html"],["PartialEq<[A; 27]>","has method","eq"],["PartialEq<[A; 27]>","has method","ne"],["PartialEq<[A; 2]>","defined in module","../src/core/array.rs.html"],["PartialEq<[A; 30]>","defined in module","../src/core/array.rs.html"],["PartialEq<[A; 31]>","defined in module","../src/core/array.rs.html"],["PartialEq<[A; 4]>","defined in module","../src/core/array.rs.html"],["PartialEq<[A; 5]>","defined in module","../src/core/array.rs.html"],["PartialEq<[A; 6]>","defined in module","../src/core/array.rs.html"],["PartialEq<[A; 9]>","defined in module","../src/core/array.rs.html"],["PartialEq<[B]>","defined in module","../src/core/slice/mod.rs.html"],["RChunks","is a","struct"],["RChunksMut","is a","struct"],["RSplit","implements","Iterator"],["RSplitMut","implements","Iterator"],["RSplitN","is a","struct"],["RSplitNMut","is a","struct"],["Read for &'a [u8]","has method","read"],["SliceConcatExt<T>","has associated type","Output = Vec<T>"],["SliceConcatExt<T>","requires where clause","T: Clone"],["SliceConcatExt<T>","requires where clause","V: Borrow<[T]>"],["SliceConcatExt<str>","has associated type","Output = String"],["Split","implements","Iterator"],["SplitMut","implements","Iterator"],["SplitNMut","is a","struct"],["T","implements","Ord"],["T","implements","PartialEq"],["ToOwned for [T]","has associated type","Owned = Vec<T>"],["ToSocketAddrs","has associated type","Iter"],["ToSocketAddrs","has method","to_socket_addrs"],["ToSocketAddrs","stable since","1.8.0"],["Windows","defined in module","std::slice"],["Write for &'a mut [u8]","has method","write"],["[B]","has method","eq"],["[B]","has method","ne"],["[B]","implements","PartialEq<[A; 0]>"],["[B]","implements","PartialEq<[A; 10]>"],["[B]","implements","PartialEq<[A; 12]>"],["[B]","implements","PartialEq<[A; 13]>"],["[B]","implements","PartialEq<[A; 16]>"],["[B]","implements","PartialEq<[A; 17]>"],["[B]","implements","PartialEq<[A; 18]>"],["[B]","implements","PartialEq<[A; 19]>"],["[B]","implements","PartialEq<[A; 20]>"],["[B]","implements","PartialEq<[A; 21]>"],["[B]","implements","PartialEq<[A; 24]>"],["[B]","implements","PartialEq<[A; 26]>"],["[B]","implements","PartialEq<[A; 29]>"],["[B]","implements","PartialEq<[A; 2]>"],["[B]","implements","PartialEq<[A; 30]>"],["[B]","implements","PartialEq<[A; 31]>"],["[B]","implements","PartialEq<[A; 3]>"],["[B]","implements","PartialEq<[A; 4]>"],["[B]","implements","PartialEq<[A; 5]>"],["[B]","implements","PartialEq<[A; 6]>"],["[B]","implements","PartialEq<[A; 7]>"],["[B]","implements","PartialEq<[A; 8]>"],["[B]","implements","PartialEq<[A; 9]>"],["[T]","implements","AsMut<[T]>"],["[T]","implements","AsRef<[T]>"],["[T]","implements","Debug"],["[T]","implements","Eq"],["[T]","implements","Hash"],["[T]","implements","Index<I>"],["[T]","implements","IndexMut<I>"],["[T]","implements","Ord"],["[T]","implements","PartialOrd"],["align_to","has attribute","unsafe"],["align_to","has declaration","pub unsafe fn align_to<U>(&self) -> (&[T], &[U], &[T])"],["align_to","has description","Transmutes slice to another type while maintaining alignment"],["align_to","is a","method"],["align_to","stable since","1.30.0"],["align_to_mut","has attribute","unsafe"],["align_to_mut","has declaration","pub unsafe fn align_to_mut<U>(&mut self) -> (&mut [T], &mut [U], &mut [T])"],["align_to_mut","is a","method"],["align_to_mut","stable since","1.30.0"],["binary_search","has example","let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]; assert_eq!(s.binary_search(&13), Ok(9));"],["binary_search","has method","binary_search"],["binary_search","has parameter","x"],["binary_search","has return type","Result<usize, usize>"],["binary_search_by","has method","binary_search_by"],["binary_search_by","has parameter","f"],["binary_search_by_key","has method","binary_search_by_key"],["binary_search_by_key","has parameter","b"],["binary_search_by_key","has parameter","f"],["buf","has type","String"],["buf","has type","Vec<u8>"],["byte","has type","u8"],["chunk_size","has type","usize"],["chunks","has description","Returns an iterator over chunk_size elements of the slice at a time, starting at the beginning of the slice. The chunks do not overlap. If chunk_size does not divide the length, the last chunk will not have length chunk_size."],["chunks","has example","let slice = ['l', 'o', 'r', 'e', 'm']; let mut iter = slice.chunks(2); assert_eq!(iter.next().unwrap(), &['l', 'o']); assert_eq!(iter.next().unwrap(), &['r', 'e']); assert_eq!(iter.next().unwrap(), &['m']); assert!(iter.next().is_none());"],["chunks","has parameter","chunk_size"],["chunks","has return type","Chunks<T>"],["chunks","is a","method"],["chunks_exact","has return type","ChunksExact<T>"],["chunks_exact","stable since","1.31.0"],["chunks_mut","has example","let v = &mut [0, 0, 0, 0, 0]; let mut count = 1; for chunk in v.chunks_mut(2) { ... }"],["chunks_mut","has parameter","chunk_size"],["chunks_mut","has return type","ChunksMut<T>"],["chunks_mut","is a","method"],["clone_from_slice","has example","let src = [1, 2, 3, 4]; let mut dst = [0, 0]; dst.clone_from_slice(&src[2..]);"],["clone_from_slice","requires trait","Clone"],["clone_into","has description","Uses borrowed data to replace owned data, usually by cloning."],["clone_into","has stability","nightly-only experimental API: toowned_clone_into #41263"],["cmp","has description","This method returns an Ordering between self and other."],["cmp","returns","Ordering"],["compare","has type","FnMut(&T, &T) -> Ordering"],["concat","returns","String"],["connect","has attribute","deprecated"],["connect","has parameter","self"],["connect","has parameter","sep: &T"],["connect","has stability","Deprecated since 1.3.0: renamed to join"],["connect","returns","Vec<T>"],["consume","has description","Tells this buffer that amt bytes have been consumed from the buffer."],["contains","has example","let v = [10, 40, 30]; assert!(v.contains(&30)); assert!(!v.contains(&50));"],["contains","has method","contains"],["contains","has parameter","x"],["contains","has return type","bool"],["copy_from_slice","has example","let src = [1, 2, 3, 4]; let mut dst = [0, 0]; dst.copy_from_slice(&src[2..]);"],["copy_from_slice","requires trait","Copy"],["copy_within","has declaration","pub fn copy_within<R>(&mut self, src: R, dest: usize) where R: RangeBounds<usize>, T: Copy"],["copy_within","has description","Copies elements from one part of the slice to another part of itself using memmove"],["copy_within","has parameter","dest"],["copy_within","has parameter","src"],["copy_within","has stability","nightly-only experimental API (copy_within #54236)"],["copy_within","is a","method"],["copy_within","requires trait","Copy"],["copy_within","requires trait","RangeBounds<usize>"],["dest","has type","usize"],["ends_with","has example","let v = [10, 40, 30]; assert!(v.ends_with(&[30])); assert!(v.ends_with(&[40, 30]));"],["ends_with","has method","ends_with"],["ends_with","has parameter","needle"],["ends_with","has return type","bool"],["eq","has argument","other"],["eq","has argument","self"],["eq","has description","This method tests for self and other values to be equal"],["eq","has description","This method tests for self and other values to be equal, and is used by =="],["eq","has description","This method tests for self and other values to be equal, and is used by ==. Read more"],["eq","has parameter","&self"],["eq","has parameter","other"],["eq","has parameter","other: &[A; 0]"],["eq","has parameter","other: &[A; 10]"],["eq","has parameter","other: &[A; 11]"],["eq","has parameter","other: &[A; 12]"],["eq","has parameter","other: &[A; 13]"],["eq","has parameter","other: &[A; 14]"],["eq","has parameter","other: &[A; 18]"],["eq","has parameter","other: &[A; 19]"],["eq","has parameter","other: &[A; 21]"],["eq","has parameter","other: &[A; 22]"],["eq","has parameter","other: &[A; 26]"],["eq","has parameter","other: &[A; 29]"],["eq","has parameter","other: &[A; 32]"],["eq","has parameter","other: &[A; 3]"],["eq","has parameter","other: &[A; 4]"],["eq","has parameter","other: &[A; N]"],["eq","has parameter","self"],["eq","has return type","bool"],["eq::other","has type","&[A; 16]"],["eq::self","has type","&'b [B]"],["eq_ignore_ascii_case","has stability","Deprecated since 1.26.0: use inherent methods instead"],["f","has type","FnMut(&T) -> K"],["f","implements","FnMut(&T) -> B"],["f","implements","FnMut(&T) -> Ordering"],["fill_buf","returns","Result<&[u8]>"],["first","has description","Returns the first element of the slice, or None if it is empty."],["first","returns","Option<&T>"],["first_mut","has description","Returns a mutable pointer to the first element of the slice, or None if it is empty."],["first_mut","returns","Option<&mut T>"],["flush","has description","Flush this output stream, ensuring that all intermediately buffered contents reach their destination."],["fmt","has argument","f: &mut Formatter"],["fmt","returns","Result<(), Error>"],["into_iter","has description","Creates an iterator from a value."],["into_iter","returns","Iter<'a, T>"],["into_iter","returns","IterMut<'a, T>"],["into_vec","has description","Converts self into a vector without clones or allocation."],["into_vec","has example","let s: Box<[i32]> = Box::new([10, 40, 30]); let x = s.into_vec(); assert_eq!(x, vec![10, 40, 30]);"],["is_ascii","has description","Checks if all bytes in slice are ASCII"],["is_ascii","has stability","Deprecated since 1.26.0: use inherent methods instead"],["is_ascii","is a","method"],["is_ascii","stable since","1.23.0"],["is_empty","has description","Returns true if the slice has a length of 0."],["is_empty","returns","bool"],["join","returns","String"],["last","has description","Returns the last element of the slice, or None if it is empty."],["last","has example","let v = [10, 40, 30]; assert_eq!(Some(&30), v.last()); let w: &[i32] = &[]; assert_eq!(None, w.last());"],["last","has parameter","last::self"],["last","has return type","Option<&T>"],["last::self","has type","&Self"],["last_mut","has description","Returns a mutable pointer to the last item in the slice."],["last_mut","has example","let x = &mut [0, 1, 2]; if let Some(last) = x.last_mut() { *last = 10; } assert_eq!(x, &[0, 1, 10]);"],["last_mut","has parameter","last_mut::self"],["last_mut","has return type","Option<&mut T>"],["last_mut::self","has type","&mut Self"],["len","has description","Returns the number of elements in the slice."],["len","returns","usize"],["lines","has description","Returns an iterator over the lines of this reader."],["lines","returns","Lines<B>"],["make_ascii_lowercase","has stability","Deprecated since 1.26.0: use inherent methods instead"],["make_ascii_uppercase","has stability","Deprecated since 1.26.0: use inherent methods instead"],["mid","has type","usize"],["n","has type","usize"],["ne","has argument","other"],["ne","has argument","self"],["ne","has description","This method tests for !="],["ne","has description","This method tests for !=."],["ne","has parameter","&self"],["ne","has parameter","other"],["ne","has parameter","other: &[A; 10]"],["ne","has parameter","other: &[A; 11]"],["ne","has parameter","other: &[A; 12]"],["ne","has parameter","other: &[A; 13]"],["ne","has parameter","other: &[A; 14]"],["ne","has parameter","other: &[A; 18]"],["ne","has parameter","other: &[A; 19]"],["ne","has parameter","other: &[A; 21]"],["ne","has parameter","other: &[A; 22]"],["ne","has parameter","other: &[A; 26]"],["ne","has parameter","other: &[A; 29]"],["ne","has parameter","other: &[A; 32]"],["ne","has parameter","other: &[A; 3]"],["ne","has parameter","other: &[A; 4]"],["ne","has parameter","other: &[A; N]"],["ne","has parameter","self"],["ne","has return type","bool"],["ne::other","has type","&[A; 16]"],["ne::self","has type","&'b [B]"],["needle","has type","&[T]"],["other","has type","&[A; 17]"],["other","has type","&[A; 24]"],["other","has type","&mut [T]"],["other","has type","[A; 0]"],["other","has type","[A; 27]"],["partial_cmp","has argument","other: &[T]"],["partial_cmp","has description","This method returns an ordering between self and other values if one exists."],["partial_cmp","returns","Option<Ordering>"],["partition_dedup","has description","Moves all consecutive repeated elements to the end of the slice according to the PartialEq trait implementation."],["partition_dedup","has example","#![feature(slice_partition_dedup)] let mut slice = [1, 2, 2, 3, 3, 2, 1, 1]; let (dedup, duplicates) = slice.partition_dedup();"],["partition_dedup","has stability","nightly-only experimental (slice_partition_dedup #54279)"],["partition_dedup","returns","(&mut [T], &mut [T])"],["partition_dedup_by","has example","#![feature(slice_partition_dedup)] let mut slice = [\"foo\", \"Foo\", \"BAZ\", \"Bar\", \"bar\", \"baz\", \"BAZ\"];"],["partition_dedup_by","has parameter","same_bucket"],["partition_dedup_by","has stability","nightly-only experimental (slice_partition_dedup #54279)"],["partition_dedup_by_key","has example","#![feature(slice_partition_dedup)] let mut slice = [10, 20, 21, 30, 30, 20, 11, 13];"],["partition_dedup_by_key","has stability","nightly-only experimental (slice_partition_dedup #54279)"],["pred","implements","FnMut"],["read","has description","Pull some bytes from this source into the specified buffer, returning how many bytes were read."],["read","has parameter","buf: &mut [u8]"],["read","has parameter","self"],["read","returns","Result<usize>"],["read_exact","has description","Read the exact number of bytes required to fill buf."],["read_line","has description","Read all bytes until a newline (the 0xA byte) is reached, and append them to the provided buffer."],["read_line","has parameter","buf"],["read_line","has return type","Result<usize>"],["read_to_end","has description","Read all bytes until EOF in this source, placing them into buf."],["read_until","has description","Read all bytes into buf until the delimiter byte or EOF is reached."],["read_until","has parameter","buf"],["read_until","has parameter","byte"],["read_until","has return type","Result<usize>"],["repeat","has argument","n"],["repeat","has description","Creates a vector by repeating a slice n times."],["repeat","has return type","Vec<T>"],["repeat","has stability","This is a nightly-only experimental API. (repeat_generic_slice #48784)"],["repeat","requires trait","Copy"],["repeat::n","has type","usize"],["rotate_left","has description","Rotates the slice in-place such that the first mid elements of the slice move to the end while the last self.len() - mid elements move to the front."],["rotate_left","has example","let mut a = ['a', 'b', 'c', 'd', 'e', 'f']; a.rotate_left(2); assert_eq!(a, ['c', 'd', 'e', 'f', 'a', 'b']);"],["rotate_left","stable since","1.26.0"],["rotate_right","has example","let mut a = ['a', 'b', 'c', 'd', 'e', 'f']; a.rotate_right(2); assert_eq!(a, ['e', 'f', 'a', 'b', 'c', 'd']);"],["rotate_right","stable since","1.26.0"],["rsplit","has description","Returns reverse iterator over subslices separated by elements that match pred."],["rsplit","returns","RSplit<T, F>"],["rsplit_mut","returns","RSplitMut<T, F>"],["rsplitn","has description","Returns an iterator over subslices separated by elements that match pred limited to returning at most n items. This starts at the end of the slice and works backwards. The matched element is not contained in the subslices. The last element returned, if any, will contain the remainder of the slice."],["rsplitn","has method","rsplitn"],["rsplitn","has parameter","n"],["rsplitn","has parameter","pred"],["rsplitn","has return type","RSplitN<T, F>"],["rsplitn_mut","has description","Returns an iterator over subslices separated by elements that match pred limited to returning at most n items. This starts at the end of the slice and works backwards. The matched element is not contained in the subslices. The last element returned, if any, will contain the remainder of the slice."],["rsplitn_mut","has example","let mut s = [10, 40, 30, 20, 60, 50]; for group in s.rsplitn_mut(2, |num| *num % 3 == 0) { group[0] = 1; } assert_eq!(s, [1, 40, 30, 20, 60, 1]);"],["rsplitn_mut","has method","rsplitn_mut"],["rsplitn_mut","has parameter","n"],["rsplitn_mut","has parameter","pred"],["rsplitn_mut","has return type","RSplitNMut<T, F>"],["same_bucket","has type","FnMut(&mut T, &mut T) -> bool"],["self","has type","&[B]"],["self","has type","&mut [B]"],["size","has type","usize"],["slice","has method","chunks"],["slice","has method","chunks_mut"],["slice","has method","first"],["slice","has method","first_mut"],["slice","has method","is_empty"],["slice","has method","last"],["slice","has method","last_mut"],["slice","has method","len"],["slice","has method","split_first"],["slice","has method","split_first_mut"],["slice","has method","split_last"],["slice","has method","split_last_mut"],["slice","has method","windows"],["slice","implements","AsMut<[T]>"],["slice","implements","AsRef<[T]>"],["slice","implements","Debug"],["slice","implements","Default"],["slice","implements","Eq"],["slice","implements","Hash"],["slice","implements","Index<I>"],["slice","implements","IndexMut<I>"],["slice","implements","IntoIterator"],["slice","implements","Ord"],["slice","implements","PartialOrd<[T]>"],["slice","is a","primitive type"],["slice","stable since","1.0.0"],["sort","has description","Stable sort using adaptive merge sort algorithm"],["sort","is a","method"],["sort_unstable","has method","sort_unstable"],["sort_unstable_by","has description","Sorts the slice with a comparator function, but may not preserve the order of equal elements."],["sort_unstable_by","has example","let mut v = [5, 4, 1, 3, 2]; v.sort_unstable_by(|a, b| a.cmp(b)); assert!(v == [1, 2, 3, 4, 5]);"],["sort_unstable_by","has parameter","compare"],["sort_unstable_by","stable since","1.20.0"],["sort_unstable_by_key","has description","Sorts the slice with a key extraction function, but may not preserve the order of equal elements."],["sort_unstable_by_key","has example","let mut v = [-5i32, 4, 1, -3, 2]; v.sort_unstable_by_key(|k| k.abs()); assert!(v == [1, 2, -3, 4, -5]);"],["sort_unstable_by_key","has parameter","f"],["sort_unstable_by_key","requires trait","Ord"],["sort_unstable_by_key","stable since","1.20.0"],["split","has description","Returns an iterator over subslices separated by elements that match pred."],["split","has description","Returns an iterator over the contents of this reader split on the byte byte."],["split","has example","let slice = [10, 40, 33, 20]; let mut iter = slice.split(|num| num % 3 == 0);"],["split","has parameter","byte"],["split","returns","Split<B>"],["split","returns","Split<T, F>"],["split_at","has description","Divides one slice into two at an index. Panics if mid > len."],["split_at","has example","let v = [1, 2, 3, 4, 5, 6]; { let (left, right) = v.split_at(0); assert!(left == []); assert!(right == [1, 2, 3, 4, 5, 6]); }"],["split_at","has parameter","mid"],["split_at","has return type","(&[T], &[T])"],["split_at","is a","method"],["split_at_mut","has description","Divides one mutable slice into two at an index. Panics if mid > len."],["split_at_mut","has parameter","mid"],["split_at_mut","has return type","(&mut [T], &mut [T])"],["split_at_mut","is a","method"],["split_first","has description","Returns the first and all the rest of the elements of the slice, or None if it is empty."],["split_first","returns","Option<(&T, &[T])>"],["split_first_mut","has description","Returns the first and all the rest of the elements of the slice, or None if it is empty."],["split_first_mut","has example","let x = &mut [0, 1, 2]; if let Some((first, elements)) = x.split_first_mut() { *first = 3; elements[0] = 4; elements[1] = 5; } assert_eq!(x, &[3, 4, 5]);"],["split_first_mut","has parameter","split_first_mut::self"],["split_first_mut","has return type","Option<(&mut T, &mut [T])>"],["split_first_mut","returns","Option<(&mut T, &mut [T])>"],["split_first_mut","stable since","1.5.0"],["split_first_mut::self","has type","&mut Self"],["split_last","has description","Returns the last and all the rest of the elements of the slice, or None if it is empty."],["split_last","has example","let x = &[0, 1, 2]; if let Some((last, elements)) = x.split_last() { assert_eq!(last, &2); assert_eq!(elements, &[0, 1]); }"],["split_last","has parameter","split_last::self"],["split_last","has return type","Option<(&T, &[T])>"],["split_last","stable since","1.5.0"],["split_last::self","has type","&Self"],["split_last_mut","has description","Returns the last and all the rest of the elements of the slice, or None if it is empty."],["split_last_mut","has example","let x = &mut [0, 1, 2]; if let Some((last, elements)) = x.split_last_mut() { *last = 3; elements[0] = 4; elements[1] = 5; } assert_eq!(x, &[4, 5, 3]);"],["split_last_mut","has parameter","split_last_mut::self"],["split_last_mut","has return type","Option<(&mut T, &mut [T])>"],["split_last_mut","stable since","1.5.0"],["split_last_mut::self","has type","&mut Self"],["split_mut","returns","SplitMut<T, F>"],["splitn_mut","has description","Returns an iterator over subslices separated by elements that match pred, limited to returning at most n items. The matched element is not contained in the subslices. The last element returned, if any, will contain the remainder of the slice."],["splitn_mut","has example","let mut v = [10, 40, 30, 20, 60, 50]; for group in v.splitn_mut(2, |num| *num % 3 == 0) { group[0] = 1; } assert_eq!(v, [1, 40, 30, 1, 60, 50]);"],["splitn_mut","has method","splitn_mut"],["splitn_mut","has parameter","n"],["splitn_mut","has parameter","pred"],["splitn_mut","has return type","SplitNMut<T, F>"],["src","has type","R"],["starts_with","has example","let v = [10, 40, 30]; assert!(v.starts_with(&[10])); assert!(v.starts_with(&[10, 40])); assert!(!v.starts_with(&[50]));"],["starts_with","has method","starts_with"],["starts_with","has parameter","needle"],["starts_with","has return type","bool"],["swap_with_slice","has declaration","pub fn swap_with_slice(&mut self, other: &mut [T])"],["swap_with_slice","has example","let mut slice1 = [0, 0]; let mut slice2 = [1, 2, 3, 4]; slice1.swap_with_slice(&mut slice2[2..])"],["swap_with_slice","has parameter","other"],["swap_with_slice","is a","method"],["swap_with_slice","stable since","1.27.0"],["to_ascii_lowercase","has description","Returns a vector containing a copy of this slice where each byte is mapped to its ASCII lower case equivalent."],["to_ascii_lowercase","has return type","Vec<u8>"],["to_ascii_lowercase","has stability","Deprecated since 1.26.0: use inherent methods instead"],["to_ascii_lowercase","stable since","1.23.0"],["to_ascii_uppercase","has description","Returns a vector containing a copy of this slice where each byte is mapped to its ASCII upper case equivalent."],["to_ascii_uppercase","has return type","Vec<u8>"],["to_ascii_uppercase","has stability","Deprecated since 1.26.0: use inherent methods instead"],["to_ascii_uppercase","stable since","1.23.0"],["to_owned","has description","Creates owned data from borrowed data, usually by cloning."],["to_owned","returns","Vec<T>"],["to_socket_addrs","has description","Converts this object to an iterator of resolved SocketAddrs."],["to_socket_addrs","returns","Result<Iter>"],["windows","has description","Returns an iterator over all contiguous windows of length size. The windows overlap. If the slice is shorter than size, the iterator returns no values. Panics if size is 0."],["windows","has example","let slice = ['r', 'u', 's', 't']; let mut iter = slice.windows(2); assert_eq!(iter.next().unwrap(), &['r', 'u']); assert_eq!(iter.next().unwrap(), &['u', 's']); assert_eq!(iter.next().unwrap(), &['s', 't']); assert!(iter.next().is_none());"],["windows","has parameter","size"],["windows","has return type","Windows<T>"],["windows","is a","method"],["write","has parameter","data: &[u8]"],["write","has parameter","self"],["write","returns","Result<usize>"],["write_all","has description","Attempts to write an entire buffer into this write."],["x","has type","&T"]],"links":["../../../../std/process/struct.Command.html","../../std/process/struct.Command.html","../alloc/index.html","../src/alloc/slice.rs.html","../src/alloc/str.rs.html","../src/core/array.rs.html","../src/core/cmp.rs.html","../src/core/fmt/mod.rs.html","../src/core/slice/mod.rs.html","../src/std/ascii.rs.html","../src/std/io/impls.rs.html","../src/std/io/mod.rs.html","../src/std/net/addr.rs.html","../std/borrow/trait.Borrow.html","../std/clone/trait.Clone.html","../std/cmp/enum.Ordering.html","../std/cmp/trait.Eq.html","../std/cmp/trait.Ord.html","../std/cmp/trait.PartialEq.html","../std/cmp/trait.PartialOrd.html","../std/convert/trait.AsMut.html","../std/convert/trait.AsRef.html","../std/default/trait.Default.html","../std/fmt/trait.Debug.html","../std/hash/trait.Hash.html","../std/index.html","../std/io/struct.Lines.html","../std/io/struct.Split.html","../std/io/trait.Write.html","../std/iter/struct.Cloned.html","../std/iter/trait.IntoIterator.html","../std/marker/trait.Copy.html","../std/net/enum.SocketAddr.html","../std/net/trait.ToSocketAddrs.html","../std/ops/trait.FnMut.html","../std/ops/trait.Index.html","../std/ops/trait.IndexMut.html","../std/primitive.bool.html","../std/primitive.reference.html","../std/primitive.slice.html","../std/primitive.tuple.html","../std/primitive.u32.html","../std/primitive.usize.html","../std/slice/struct.Chunks.html","../std/slice/struct.ChunksExact.html","../std/slice/struct.ChunksMut.html","../std/slice/struct.Iter.html","../std/slice/struct.RChunks.html","../std/slice/struct.RChunksMut.html","../std/slice/struct.RSplit.html","../std/slice/struct.RSplitMut.html","../std/slice/struct.RSplitN.html","../std/slice/struct.RSplitNMut.html","../std/slice/struct.Split.html","../std/slice/struct.SplitMut.html","../std/slice/struct.SplitNMut.html","../std/slice/trait.SliceIndex.html","../std/str/pattern/trait.Pattern.html","../std/string/struct.String.html","../std/vec/struct.Vec.html","https://play.rust-lang.org/","https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20slice%20%3D%20%5B'l'%2C%20'o'%2C%20'r'%2C%20'e'%2C%20'm'%5D%3B%0Alet%20mut%20iter%20%3D%20slice.chunks(2)%3B%0A...","https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20slice%20%3D%20%5B'r'%2C%20'u'%2C%20's'%2C%20't'%5D%3B%0Alet%20mut%20iter%20%3D%20slice.windows(2)%3B%0Aassert_eq!(iter.next().unwrap()%2C%20%26%5B'r'%2C%20'u'%5D)%3B%0A...","primitive.array.html","primitive.bool.html","primitive.reference.html","primitive.slice.html","primitive.tuple.html","primitive.usize.html","slice/index.html","std/option/enum.Option.html"],"metrics":{"escapeCount":1,"costTime":3155733,"totalUsage":{"prompt_tokens":286091,"completion_tokens":81714,"cached_tokens":0,"reasoning_tokens":66317},"chunkLength":18,"chunksInfo":[{"contextLength":0,"contentLength":39000,"costTime":180938},{"contextLength":500,"contentLength":39000,"costTime":272278},{"contextLength":500,"contentLength":39000,"costTime":245190},{"contextLength":500,"contentLength":39000,"costTime":107990},{"contextLength":500,"contentLength":39000,"costTime":302884},{"contextLength":500,"contentLength":39000,"costTime":234378},{"contextLength":500,"contentLength":39000,"costTime":66092},{"contextLength":500,"contentLength":39000,"costTime":230478},{"contextLength":500,"contentLength":39000,"costTime":101239},{"contextLength":500,"contentLength":39000,"costTime":108147},{"contextLength":500,"contentLength":39000,"costTime":263425},{"contextLength":500,"contentLength":39000,"costTime":272656},{"contextLength":500,"contentLength":39000,"costTime":380746},{"contextLength":500,"contentLength":39000,"costTime":72957},{"contextLength":500,"contentLength":39000,"costTime":90652},{"contextLength":500,"contentLength":39000,"costTime":61043},{"contextLength":500,"contentLength":39000,"costTime":95919},{"contextLength":500,"contentLength":10259,"costTime":68721}]},"model":"deepseek-r1-250120","extraInfo":{"startTime":"2025-03-23T07:43:00.912Z","examGroup":"split","examParams":{"windowLength":39000}}}