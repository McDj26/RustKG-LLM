{"create_time":"2025-04-05T09:45:11.419Z","id":"d72afb93-f9cf-4993-b222-75694e2d84cf","source_url":"file:///C:/Users/Dj/.rustup/toolchains/1.70-x86_64-pc-windows-msvc/share/doc/rust/html/std/sync/mpsc/index.html","previous_url":"D:\\Lessons\\projects\\rustKG\\rustkg_be\\sandbox\\exams\\effective\\output\\zero-shot-with-rules\\std_sync_mpsc-index\\merged_34dd9312-4f91-474e-a148-772320be81f3.json","relations":[],"delete_triples":[{"triples":[],"startIndex":21210,"endIndex":61519},{"triples":[["std::sync::mpsc::Receiver::recv","has_description","Blocks until a message is available while there is at least one Sender alive (including clones)."],["std::sync::mpsc::sync_channel","has_description","Creates a new synchronous, bounded channel."],["mpsc","contains","Sender"],["mpsc","contains","SyncSender"],["mpsc","contains","Receiver"],["mpsc","contains","IntoIter"],["mpsc","contains","Iter"],["mpsc","contains","RecvError"],["mpsc","contains","SendError"],["mpsc","contains","Handle"],["mpsc","contains","Select"],["mpsc","contains","TryRecvError"],["mpsc","contains","TrySendError"],["mpsc","contains","channel"],["mpsc","contains","sync_channel"],["channel","returns","Sender"],["channel","returns","Receiver"],["sync_channel","returns","SyncSender"],["sync_channel","returns","Receiver"],["channel","creates","asynchronous channel"],["sync_channel","creates","synchronous, bounded channel"],["mpsc","has description","Multi-producer, single-consumer FIFO queue communication primitives."],["mpsc","provides","message-based communication over channels"],["Handle","has attribute","unstable"],["Select","has attribute","unstable"],["Receiver","is a","struct"],["Sender","is a","struct"],["SyncSender","is a","struct"],["TryRecvError","is a","enum"],["TrySendError","is a","enum"],["channel","is a","function"],["sync_channel","is a","function"],["Receiver","has description","The receiving-half of Rust's channel type. This half can only be owned by one thread"],["Sender","has description","The sending-half of Rust's asynchronous channel type. This half can only be owned by one thread, but it can be cloned to send to other threads."],["SyncSender","has description","The sending-half of Rust's synchronous channel type. This half can only be owned by one thread, but it can be cloned to send to other threads."],["TryRecvError","has description","This enumeration is the list of the possible reasons that try_recv could not return data when called."],["TrySendError","has description","This enumeration is the list of the possible error outcomes for the SyncSender::try_send method."],["channel","has description","Creates a new asynchronous channel, returning the sender/receiver halves."],["sync_channel","has description","Creates a new synchronous, bounded channel."],["std::sync::mpsc","has description","Multi-producer, single-consumer FIFO queue communication primitives."],["std::sync::mpsc","provides","message-based communication over channels"],["std::sync::mpsc","defines","Sender"],["std::sync::mpsc","defines","SyncSender"],["std::sync::mpsc","defines","Receiver"],["Sender","can be cloned","to send to other threads"],["SyncSender","can be cloned","to send to other threads"]],"startIndex":22484,"endIndex":24478}],"add_triples":[{"triples":[],"startIndex":21210,"endIndex":61519},{"triples":[["std::sync::mpsc::Receiver::recv","has_description","recv will block until a message is available while there is at least one Sender alive (including clones)."],["std::sync::mpsc::sync_channel","has_description","Creates a new synchronous, bounded channel. All data sent on the SyncSender will become available on the Receiver in the same order as it was sent. Like asynchronous channels, the Receiver will block until a message becomes available. sync_channel differs greatly in the semantics of the sender, however."]],"startIndex":22484,"endIndex":24478}],"metrics":{"escapeCount":0,"costTime":473837,"totalUsage":{"prompt_tokens":23081,"completion_tokens":13506,"cached_tokens":0,"reasoning_tokens":12503},"chunkLength":2,"chunksInfo":[{"chunkIndex":0,"strLength":40309,"costTime":88874},{"chunkIndex":1,"strLength":1994,"costTime":384963}]},"model":"deepseek-r1-250120","extraInfo":{},"changes_info_triples":[["mpsc","moved to","std::sync::mpsc"],["Sender","moved to","std::sync::mpsc::Sender"],["SyncSender","moved to","std::sync::mpsc::SyncSender"],["Receiver","moved to","std::sync::mpsc::Receiver"],["IntoIter","moved to","std::sync::mpsc::IntoIter"],["Iter","moved to","std::sync::mpsc::Iter"],["RecvError","moved to","std::sync::mpsc::RecvError"],["SendError","moved to","std::sync::mpsc::SendError"],["Handle","moved to","std::sync::mpsc::Handle"],["Select","moved to","std::sync::mpsc::Select"],["TryRecvError","moved to","std::sync::mpsc::TryRecvError"],["TrySendError","moved to","std::sync::mpsc::TrySendError"],["channel","moved to","std::sync::mpsc::channel"],["sync_channel","moved to","std::sync::mpsc::sync_channel"],["std::sync::mpsc::Receiver::recv","updates description","recv will block until a message is available while there is at least one Sender alive (including clones)."],["std::sync::mpsc::sync_channel","updates description","Creates a new synchronous, bounded channel. All data sent on the SyncSender will become available on the Receiver in the same order as it was sent. Like asynchronous channels, the Receiver will block until a message becomes available. sync_channel differs greatly in the semantics of the sender, however."]]}