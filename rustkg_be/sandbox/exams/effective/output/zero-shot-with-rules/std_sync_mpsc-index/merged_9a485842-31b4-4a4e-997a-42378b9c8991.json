{"create_time":"2025-04-05T12:02:16.549Z","id":"merged_9a485842-31b4-4a4e-997a-42378b9c8991","source_url":"file:///C:/Users/Dj/.rustup/toolchains/1.80-x86_64-pc-windows-msvc/share/doc/rust/html/std/sync/mpsc/index.html","merged_triples":[{"triples":[["std::sync","contains","atomic"],["std::sync","contains","mpsc"],["std::sync::atomic","has_description","Atomic types"],["std::sync::mpsc","has_description","Multi-producer, single-consumer FIFO queue communication primitives."],["std::sync::mpsc","stable_since","1.0.0"],["std::sync::mpsc","contains","std::sync::mpsc::IntoIter"],["std::sync::mpsc::IntoIter","is_a","struct"],["std::sync::mpsc::IntoIter","has_description","An owning iterator over messages on a receiver, this iterator will block whenever next is called, waiting for a new message, and None will be returned when the corresponding channel has hung up."],["std::sync::mpsc","contains","std::sync::mpsc::Iter"],["std::sync::mpsc::Iter","is_a","struct"],["std::sync::mpsc::Iter","has_description","An iterator over messages on a receiver, this iterator will block whenever next is called, waiting for a new message, and None will be returned when the corresponding channel has hung up."],["std::sync::mpsc","contains","std::sync::mpsc::Receiver"],["std::sync::mpsc::Receiver","is_a","struct"],["std::sync::mpsc::Receiver","has_description","The receiving-half of Rust's channel type. This half can only be owned by one thread"],["std::sync::mpsc","contains","std::sync::mpsc::RecvError"],["std::sync::mpsc::RecvError","is_a","struct"],["std::sync::mpsc::RecvError","has_description","An error returned from the recv function on a Receiver."],["std::sync::mpsc::RecvError","is_returned_by","std::sync::mpsc::Receiver::recv"],["std::sync::mpsc","contains","std::sync::mpsc::SendError"],["std::sync::mpsc::SendError","is_a","struct"],["std::sync::mpsc::SendError","has_description","An error returned from the send function on channels."],["std::sync::mpsc::SendError","is_returned_by","std::sync::mpsc::Sender::send"],["std::sync::mpsc","contains","std::sync::mpsc::Sender"],["std::sync::mpsc::Sender","is_a","struct"],["std::sync::mpsc::Sender","has_description","The sending-half of Rust's asynchronous channel type. This half can only be owned by one thread, but it can be cloned to send to other threads."],["std::sync::mpsc","contains","std::sync::mpsc::SyncSender"],["std::sync::mpsc::SyncSender","is_a","struct"],["std::sync::mpsc::SyncSender","has_description","The sending-half of Rust's synchronous channel type. This half can only be owned by one thread, but it can be cloned to send to other threads."],["std::sync::mpsc","contains","std::sync::mpsc::TryRecvError"],["std::sync::mpsc::TryRecvError","is_a","enum"],["std::sync::mpsc::TryRecvError","has_description","This enumeration is the list of the possible reasons that try_recv could not return data when called."],["std::sync::mpsc::TryRecvError","is_returned_by","std::sync::mpsc::Receiver::try_recv"],["std::sync::mpsc","contains","std::sync::mpsc::TrySendError"],["std::sync::mpsc::TrySendError","is_a","enum"],["std::sync::mpsc::TrySendError","has_description","This enumeration is the list of the possible error outcomes for the SyncSender::try_send method."],["std::sync::mpsc::TrySendError","is_returned_by","std::sync::mpsc::SyncSender::try_send"],["std::sync::mpsc","contains","std::sync::mpsc::channel"],["std::sync::mpsc::channel","is_a","function"],["std::sync::mpsc::channel","has_description","Creates a new asynchronous channel, returning the sender/receiver halves."],["std::sync::mpsc::channel","returns","std::sync::mpsc::Sender"],["std::sync::mpsc::channel","returns","std::sync::mpsc::Receiver"],["std::sync::mpsc","contains","std::sync::mpsc::sync_channel"],["std::sync::mpsc::sync_channel","is_a","function"],["std::sync::mpsc::sync_channel","has_description","Creates a new synchronous, bounded channel."],["std::sync::mpsc::sync_channel","returns","std::sync::mpsc::SyncSender"],["std::sync::mpsc::sync_channel","returns","std::sync::mpsc::Receiver"],["std::sync::mpsc","contains","std::sync::mpsc::Handle"],["std::sync::mpsc::Handle","is_a","struct"],["std::sync::mpsc::Handle","has_stability","unstable"],["std::sync::mpsc","contains","std::sync::mpsc::Select"],["std::sync::mpsc::Select","is_a","struct"],["std::sync::mpsc::Select","has_stability","unstable"],["mpsc","contains","Sender"],["mpsc","contains","SyncSender"],["mpsc","contains","Receiver"],["mpsc","contains","IntoIter"],["mpsc","contains","Iter"],["mpsc","contains","RecvError"],["mpsc","contains","SendError"],["mpsc","contains","Handle"],["mpsc","contains","Select"],["mpsc","contains","TryRecvError"],["mpsc","contains","TrySendError"],["mpsc","contains","channel"],["mpsc","contains","sync_channel"],["channel","returns","Sender"],["channel","returns","Receiver"],["sync_channel","returns","SyncSender"],["sync_channel","returns","Receiver"],["channel","creates","asynchronous channel"],["sync_channel","creates","synchronous, bounded channel"],["mpsc","has description","Multi-producer, single-consumer FIFO queue communication primitives."],["mpsc","provides","message-based communication over channels"],["Handle","has attribute","unstable"],["Select","has attribute","unstable"],["std::sync::mpsc","contains","Receiver"],["std::sync::mpsc","contains","Sender"],["std::sync::mpsc","contains","SyncSender"],["std::sync::mpsc","contains","TryRecvError"],["std::sync::mpsc","contains","TrySendError"],["std::sync::mpsc","contains","channel"],["std::sync::mpsc","contains","sync_channel"],["Receiver","is a","struct"],["Sender","is a","struct"],["SyncSender","is a","struct"],["TryRecvError","is a","enum"],["TrySendError","is a","enum"],["channel","is a","function"],["sync_channel","is a","function"],["Receiver","has description","The receiving-half of Rust's channel type. This half can only be owned by one thread"],["Sender","has description","The sending-half of Rust's asynchronous channel type. This half can only be owned by one thread, but it can be cloned to send to other threads."],["SyncSender","has description","The sending-half of Rust's synchronous channel type. This half can only be owned by one thread, but it can be cloned to send to other threads."],["TryRecvError","has description","This enumeration is the list of the possible reasons that try_recv could not return data when called."],["TrySendError","has description","This enumeration is the list of the possible error outcomes for the SyncSender::try_send method."],["channel","has description","Creates a new asynchronous channel, returning the sender/receiver halves."],["sync_channel","has description","Creates a new synchronous, bounded channel."],["std::sync::mpsc","has description","Multi-producer, single-consumer FIFO queue communication primitives."],["std::sync::mpsc","provides","message-based communication over channels"],["std::sync::mpsc","defines","Sender"],["std::sync::mpsc","defines","SyncSender"],["std::sync::mpsc","defines","Receiver"],["Sender","can be cloned","to send to other threads"],["SyncSender","can be cloned","to send to other threads"],["std::sync::mpsc","contains","std::sync::mpsc::TryIter"],["std::sync::mpsc::TryIter","is_a","struct"],["std::sync::mpsc::TryIter","has_description","An iterator that attempts to yield all pending values for a Receiver, created by try_iter."],["std::sync::mpsc","contains","std::sync::mpsc::RecvTimeoutError"],["std::sync::mpsc::RecvTimeoutError","is_a","enum"],["std::sync::mpsc::RecvTimeoutError","has_description","This enumeration is the list of possible errors that made recv_timeout unable to return data when called."],["std::sync::mpsc::IntoIter","has_description","An owning iterator over messages on a Receiver created by Receiver::into_iter."],["std::sync::mpsc::Iter","has_description","An iterator over messages on a Receiver created by Receiver::iter."],["std::sync::mpsc::Handle","has_stability","Experimental"],["std::sync::mpsc::Select","has_stability","Experimental"],["std::sync::mpsc::Receiver","has_method","into_iter"],["std::sync::mpsc::Receiver","has_method","iter"],["std::sync::mpsc","contains","WaitTimeoutResult"],["std::sync::mpsc::WaitTimeoutResult","is_a","struct"],["std::sync::mpsc::WaitTimeoutResult","has_description","A type indicating whether a timed wait on a condition variable returned due to a time out or not"],["std::sync::mpsc","contains","Weak"],["std::sync::mpsc::Weak","is_a","struct"],["std::sync::mpsc::Weak","has_description","A version of Arc that holds a non-owning reference to the managed value."],["std::sync::mpsc","contains","TryIter"],["std::sync::mpsc","contains","RecvTimeoutError"],["std::sync::mpsc","contains","LockResult"],["std::sync::mpsc::LockResult","is_a","type"],["std::sync::mpsc::LockResult","has_description","A type alias for the result of a lock method which can be poisoned."],["std::sync::mpsc::Receiver","creates","std::sync::mpsc::IntoIter"],["std::sync::mpsc::Receiver","creates","std::sync::mpsc::Iter"],["std::sync::mpsc::Receiver","creates","std::sync::mpsc::TryIter"],["std::sync::Arc","has_description","A thread-safe reference-counting pointer. 'Arc' stands for 'Atomically Reference Counted'."],["std::sync::BarrierWaitResult","has_description","A `BarrierWaitResult` is returned by [`wait`] when all threads in the [`Barrier`] have rendezvoused."],["std::sync","contains","WaitTimeoutResult"],["std::sync::WaitTimeoutResult","is_a","struct"],["std::sync::WaitTimeoutResult","has_description","A type indicating whether a timed wait on a condition variable returned due to a time out or not."],["std::sync","contains","Weak"],["std::sync::Weak","is_a","struct"],["std::sync::Weak","has_description","A version of Arc that holds a non-owning reference to the managed value. The value is accessed by calling upgrade on the Weak pointer, which returns an Option<Arc<T>>."],["std::sync::TryLockError","is_returned_by","std::sync::Mutex::try_lock"],["std::sync::TryLockError","is_returned_by","std::sync::RwLock::try_read"],["std::sync::TryLockError","is_returned_by","std::sync::RwLock::try_write"],["std::sync::mpsc::Weak","has_description","A version of Arc that holds a non-owning reference to the managed allocation. The allocation is accessed by calling upgrade on the Weak pointer, which returns an Option<Arc<T>>."],["std::sync::mpsc::SendError","is_returned_by","std::sync::mpsc::SyncSender::send"],["std::sync::BarrierWaitResult","is_returned_by","std::sync::Barrier::wait"],["std::sync::mpsc::RecvTimeoutError","is_returned_by","std::sync::mpsc::Receiver::recv_timeout"],["std::sync::mpsc::Receiver::recv","has_description","recv will block until a message is available while there is at least one Sender alive (including clones)."],["std::sync::mpsc::Receiver::recv","has_description","Blocks until a message is available while there is at least one Sender alive (including clones)."],["std::sync::mpsc::Iter","has_description","An iterator over messages on a Receiver, created by iter."],["std::sync::mpsc::sync_channel","has_description","Creates a new synchronous, bounded channel. All data sent on the SyncSender will become available on the Receiver in the same order as it was sent. Like asynchronous channels, the Receiver will block until a message becomes available. sync_channel differs greatly in the semantics of the sender, however."],["std::sync::mpsc::Receiver","has_method","try_iter"],["std::sync::mpsc::Receiver","has_method","recv"],["std::sync::mpsc","stable_since","1.80.1"],["std::sync::mpsc::Sender","has_description","The sending-half of Rust's asynchronous channel type."],["std::sync::mpsc::SyncSender","has_description","The sending-half of Rust's synchronous sync_channel type."]],"startIndex":0,"endIndex":39000}],"changes_info_triples":[["std::sync::mpsc","stable_since updated to","1.80.1"],["std::sync::mpsc::Handle","stability changed to","unstable"],["std::sync::mpsc::Select","stability changed to","unstable"],["Sender","removes feature","can be cloned to send to other threads"],["SyncSender","removes feature","can be cloned to send to other threads"],["std::sync::mpsc::Receiver","removes method","into_iter"],["std::sync::mpsc::Receiver","removes method","iter"],["std::sync::mpsc","contains","std::sync::mpsc::RecvTimeoutError"],["std::sync::mpsc::RecvTimeoutError","is_a","enum"],["std::sync::mpsc::Receiver","adds method","try_iter"]],"model":"deepseek-r1-250120"}