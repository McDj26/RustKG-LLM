{"stability":{"stable since":"1.9.0"},"apiName":"std::ptr::read_volatile","apiType":"function","apiDocumentation":{"apiDescription":["Performs a volatile read of the value from src without moving it. This leaves the memory in src unchanged.","Volatile operations are intended to act on I/O memory, and are guaranteed to not be elided or reordered by the compiler across other volatile operations.","Notes","Rust does not currently have a rigorously and formally defined memory model, so the precise semantics of what \"volatile\" means here is subject to change over time. That being said, the semantics will almost always end up pretty similar to C11's definition of volatile.","The compiler shouldn't change the relative order or number of volatile memory operations. However, volatile memory operations on zero-sized types (e.g. if a zero-sized type is passed to read_volatile) are no-ops and may be ignored.","Safety","Beyond accepting a raw pointer, this is unsafe because it semantically moves the value out of src without preventing further usage of src. If T is not Copy, then care must be taken to ensure that the value at src is not used before the data is overwritten again (e.g. with write, write_bytes, or copy). Note that *src = foo counts as a use because it will attempt to drop the value previously at *src.","Just like in C, whether an operation is volatile has no bearing whatsoever on questions involving concurrent access from multiple threads. Volatile accesses behave exactly like non-atomic accesses in that regard. In particular, a race between a read_volatile and any write operation to the same location is undefined behavior."],"examples":["Basic usage:","let x = 12;\nlet y = &x as *const i32;\n\nunsafe {\n    assert_eq!(std::ptr::read_volatile(y), 12);\n}"]}}