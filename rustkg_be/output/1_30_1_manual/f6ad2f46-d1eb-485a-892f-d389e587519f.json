{"stability":{"stable since":"1.0.0"},"apiName":"std::path::Path","apiType":"struct","apiDocumentation":{"apiDescription":["A slice of a path (akin to str).","This type supports a number of operations for inspecting a path, including breaking the path into its components (separated by / on Unix and by either / or \\ on Windows), extracting the file name, determining whether the path is absolute, and so on.","This is an unsized type, meaning that it must always be used behind a pointer like & or Box. For an owned version of this type, see PathBuf.","More details about the overall approach can be found in the module documentation."],"examples":["use std::path::Path;\nuse std::ffi::OsStr;\n\n// Note: this example does work on Windows\nlet path = Path::new(\"./foo/bar.txt\");\n\nlet parent = path.parent();\nassert_eq!(parent, Some(Path::new(\"./foo\")));\n\nlet file_stem = path.file_stem();\nassert_eq!(file_stem, Some(OsStr::new(\"bar\")));\n\nlet extension = path.extension();\nassert_eq!(extension, Some(OsStr::new(\"txt\")));"]},"trait implementations":[{"name":"impl<'a> std::convert::AsRef<std::path::Path> for std::path::Component<'a>","stable since":"1.25.0"},{"name":"impl<'a> std::convert::AsRef<std::path::Path> for std::path::Components<'a>","stable since":"1.0.0"},{"name":"impl<'a> std::convert::AsRef<std::path::Path> for std::path::Iter<'a>","stable since":"1.0.0"},{"name":"impl<'a> std::convert::From<&'a std::path::Path> for std::boxed::Box<std::path::Path>","stable since":"1.17.0"},{"name":"impl std::borrow::Borrow<std::path::Path> for std::path::PathBuf","stable since":"1.0.0"},{"name":"impl<'a> std::convert::From<&'a std::path::Path> for std::borrow::Cow<'a, std::path::Path>","stable since":"1.6.0"},{"name":"impl<'a> std::convert::From<&'a std::path::Path> for std::sync::Arc<std::path::Path>","stable since":"1.24.0"},{"name":"impl<'a> std::convert::From<&'a std::path::Path> for std::rc::Rc<std::path::Path>","stable since":"1.24.0"},{"name":"impl std::borrow::ToOwned for std::path::Path","stable since":"1.0.0"},{"name":"impl std::convert::AsRef<std::ffi::OsStr> for std::path::Path","stable since":"1.0.0"},{"name":"impl std::fmt::Debug for std::path::Path","stable since":"1.0.0"},{"name":"impl std::cmp::PartialEq for std::path::Path","stable since":"1.0.0"},{"name":"impl std::hash::Hash for std::path::Path","stable since":"1.0.0"},{"name":"impl std::cmp::Eq for std::path::Path","stable since":"1.0.0"},{"name":"impl std::cmp::PartialOrd for std::path::Path","stable since":"1.0.0"},{"name":"impl std::cmp::Ord for std::path::Path","stable since":"1.0.0"},{"name":"impl std::convert::AsRef<std::path::Path> for std::path::Path","stable since":"1.0.0"},{"name":"impl std::convert::AsRef<std::path::Path> for std::ffi::OsStr","stable since":"1.0.0"},{"name":"impl<'a> std::convert::AsRef<std::path::Path> for std::borrow::Cow<'a, std::ffi::OsStr>","stable since":"1.8.0"},{"name":"impl std::convert::AsRef<std::path::Path> for std::ffi::OsString","stable since":"1.0.0"},{"name":"impl std::convert::AsRef<std::path::Path> for str","stable since":"1.0.0"},{"name":"impl std::convert::AsRef<std::path::Path> for std::string::String","stable since":"1.0.0"},{"name":"impl std::convert::AsRef<std::path::Path> for std::path::PathBuf","stable since":"1.0.0"},{"name":"impl<'a> std::iter::IntoIterator for &'a std::path::Path","stable since":"1.6.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<std::path::Path> for std::path::PathBuf","stable since":"1.6.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<std::path::PathBuf> for std::path::Path","stable since":"1.6.0"},{"name":"impl<'a, 'b> std::cmp::PartialOrd<std::path::Path> for std::path::PathBuf","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialOrd<std::path::PathBuf> for std::path::Path","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<&'a std::path::Path> for std::path::PathBuf","stable since":"1.6.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<std::path::PathBuf> for &'a std::path::Path","stable since":"1.6.0"},{"name":"impl<'a, 'b> std::cmp::PartialOrd<&'a std::path::Path> for std::path::PathBuf","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialOrd<std::path::PathBuf> for &'a std::path::Path","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<std::path::Path> for std::borrow::Cow<'a, std::path::Path>","stable since":"1.6.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<std::borrow::Cow<'a, std::path::Path>> for std::path::Path","stable since":"1.6.0"},{"name":"impl<'a, 'b> std::cmp::PartialOrd<std::path::Path> for std::borrow::Cow<'a, std::path::Path>","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialOrd<std::borrow::Cow<'a, std::path::Path>> for std::path::Path","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<&'b std::path::Path> for std::borrow::Cow<'a, std::path::Path>","stable since":"1.6.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<std::borrow::Cow<'a, std::path::Path>> for &'b std::path::Path","stable since":"1.6.0"},{"name":"impl<'a, 'b> std::cmp::PartialOrd<&'b std::path::Path> for std::borrow::Cow<'a, std::path::Path>","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialOrd<std::borrow::Cow<'a, std::path::Path>> for &'b std::path::Path","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<std::ffi::OsStr> for std::path::Path","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<std::path::Path> for std::ffi::OsStr","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialOrd<std::ffi::OsStr> for std::path::Path","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialOrd<std::path::Path> for std::ffi::OsStr","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<&'a std::ffi::OsStr> for std::path::Path","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<std::path::Path> for &'a std::ffi::OsStr","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialOrd<&'a std::ffi::OsStr> for std::path::Path","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialOrd<std::path::Path> for &'a std::ffi::OsStr","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<std::borrow::Cow<'a, std::ffi::OsStr>> for std::path::Path","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<std::path::Path> for std::borrow::Cow<'a, std::ffi::OsStr>","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialOrd<std::borrow::Cow<'a, std::ffi::OsStr>> for std::path::Path","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialOrd<std::path::Path> for std::borrow::Cow<'a, std::ffi::OsStr>","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<std::ffi::OsString> for std::path::Path","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<std::path::Path> for std::ffi::OsString","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialOrd<std::ffi::OsString> for std::path::Path","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialOrd<std::path::Path> for std::ffi::OsString","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<std::ffi::OsStr> for &'a std::path::Path","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<&'a std::path::Path> for std::ffi::OsStr","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialOrd<std::ffi::OsStr> for &'a std::path::Path","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialOrd<&'a std::path::Path> for std::ffi::OsStr","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<std::borrow::Cow<'b, std::ffi::OsStr>> for &'a std::path::Path","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<&'a std::path::Path> for std::borrow::Cow<'b, std::ffi::OsStr>","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialOrd<std::borrow::Cow<'b, std::ffi::OsStr>> for &'a std::path::Path","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialOrd<&'a std::path::Path> for std::borrow::Cow<'b, std::ffi::OsStr>","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<std::ffi::OsString> for &'a std::path::Path","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<&'a std::path::Path> for std::ffi::OsString","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialOrd<std::ffi::OsString> for &'a std::path::Path","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::cmp::PartialOrd<&'a std::path::Path> for std::ffi::OsString","stable since":"1.8.0"},{"name":"impl std::marker::Send for std::path::Path","stable since":"1.0.0"},{"name":"impl std::marker::Sync for std::path::Path","stable since":"1.0.0"}],"methods":[{"name":"pub fn new<S: AsRef<OsStr> + ?Sized>(s: &S) -> &Path","details":{"description":["Directly wraps a string slice as a Path slice.","This is a cost-free conversion."],"example":["use std::path::Path;\n\nPath::new(\"foo.txt\");","You can create Paths from Strings, or even other Paths:","use std::path::Path;\n\nlet string = String::from(\"foo.txt\");\nlet from_string = Path::new(&string);\nlet from_path = Path::new(&from_string);\nassert_eq!(from_string, from_path);"]}},{"name":"pub fn as_os_str(&self) -> &OsStr","details":{"description":["Yields the underlying OsStr slice."],"example":["use std::path::Path;\n\nlet os_str = Path::new(\"foo.txt\").as_os_str();\nassert_eq!(os_str, std::ffi::OsStr::new(\"foo.txt\"));"]}},{"name":"pub fn to_str(&self) -> Option<&str>","details":{"description":["Yields a &str slice if the Path is valid unicode.","This conversion may entail doing a check for UTF-8 validity."],"example":["use std::path::Path;\n\nlet path = Path::new(\"foo.txt\");\nassert_eq!(path.to_str(), Some(\"foo.txt\"));"]}},{"name":"pub fn to_string_lossy(&self) -> Cow<str>","details":{"description":["Converts a Path to a Cow<str>.","Any non-Unicode sequences are replaced with U+FFFD REPLACEMENT CHARACTER."],"example":["Calling to_string_lossy on a Path with valid unicode:","use std::path::Path;\n\nlet path = Path::new(\"foo.txt\");\nassert_eq!(path.to_string_lossy(), \"foo.txt\");","Had path contained invalid unicode, the to_string_lossy call might\nhave returned \"foï¿½.txt\"."]}},{"name":"pub fn to_path_buf(&self) -> PathBuf","details":{"description":["Converts a Path to an owned PathBuf."],"example":["use std::path::Path;\n\nlet path_buf = Path::new(\"foo.txt\").to_path_buf();\nassert_eq!(path_buf, std::path::PathBuf::from(\"foo.txt\"));"]}},{"name":"pub fn is_absolute(&self) -> bool","details":{"description":["Returns true if the Path is absolute, i.e. if it is independent of the current directory.","On Unix, a path is absolute if it starts with the root, so is_absolute and has_root are equivalent. On Windows, a path is absolute if it has a prefix and starts with the root: c:\\windows is absolute, while c:temp and \\temp are not."],"example":["use std::path::Path;\n\nassert!(!Path::new(\"foo.txt\").is_absolute());"]}},{"name":"pub fn is_relative(&self) -> bool","details":{"description":["Returns true if the Path is relative, i.e. not absolute.","See is_absolute's documentation for more details."],"example":["use std::path::Path;\n\nassert!(Path::new(\"foo.txt\").is_relative());"]}},{"name":"pub fn has_root(&self) -> bool","details":{"description":["Returns true if the Path has a root.","On Unix, a path has a root if it begins with /. On Windows, a path has a root if it: has no prefix and begins with a separator, e.g. \\windows has a prefix followed by a separator, e.g. c:\\windows but not c:windows has any non-disk prefix, e.g. \\\\server\\share"],"example":["use std::path::Path;\n\nassert!(Path::new(\"/etc/passwd\").has_root());"]}},{"name":"pub fn parent(&self) -> Option<&Path>","details":{"description":["Returns the Path without its final component, if there is one.","Returns None if the path terminates in a root or prefix."],"example":["use std::path::Path;\n\nlet path = Path::new(\"/foo/bar\");\nlet parent = path.parent().unwrap();\nassert_eq!(parent, Path::new(\"/foo\"));\n\nlet grand_parent = parent.parent().unwrap();\nassert_eq!(grand_parent, Path::new(\"/\"));\nassert_eq!(grand_parent.parent(), None);"]}},{"name":"pub fn ancestors(&self) -> Ancestors","details":{"description":["Produces an iterator over Path and its ancestors.","The iterator will yield the Path that is returned if the parent method is used zero or more times. That means, the iterator will yield &self, &self.parent().unwrap(), &self.parent().unwrap().parent().unwrap() and so on. If the parent method returns None, the iterator will do likewise. The iterator will always yield at least one value, namely &self."],"example":["use std::path::Path;\n\nlet mut ancestors = Path::new(\"/foo/bar\").ancestors();\nassert_eq!(ancestors.next(), Some(Path::new(\"/foo/bar\")));\nassert_eq!(ancestors.next(), Some(Path::new(\"/foo\")));\nassert_eq!(ancestors.next(), Some(Path::new(\"/\")));\nassert_eq!(ancestors.next(), None);"]}},{"name":"pub fn file_name(&self) -> Option<&OsStr>","details":{"description":["Returns the final component of the Path, if there is one.","If the path is a normal file, this is the file name. If it's the path of a directory, this is the directory name.","Returns None if the path terminates in ..."],"example":["use std::path::Path;\nuse std::ffi::OsStr;\n\nassert_eq!(Some(OsStr::new(\"bin\")), Path::new(\"/usr/bin/\").file_name());\nassert_eq!(Some(OsStr::new(\"foo.txt\")), Path::new(\"tmp/foo.txt\").file_name());\nassert_eq!(Some(OsStr::new(\"foo.txt\")), Path::new(\"foo.txt/.\").file_name());\nassert_eq!(Some(OsStr::new(\"foo.txt\")), Path::new(\"foo.txt/.//\").file_name());\nassert_eq!(None, Path::new(\"foo.txt/..\").file_name());\nassert_eq!(None, Path::new(\"/\").file_name());"]}},{"name":"pub fn strip_prefix<P>(&self, base: P) -> Result<&Path, StripPrefixError> where P: AsRef<Path>","details":{"description":["Returns a path that, when joined onto base, yields self.","Errors","If base is not a prefix of self (i.e. starts_with returns false), returns Err."],"example":["use std::path::{Path, PathBuf};\n\nlet path = Path::new(\"/test/haha/foo.txt\");\n\nassert_eq!(path.strip_prefix(\"/\"), Ok(Path::new(\"test/haha/foo.txt\")));\nassert_eq!(path.strip_prefix(\"/test\"), Ok(Path::new(\"haha/foo.txt\")));\nassert_eq!(path.strip_prefix(\"/test/\"), Ok(Path::new(\"haha/foo.txt\")));\nassert_eq!(path.strip_prefix(\"/test/haha/foo.txt\"), Ok(Path::new(\"\")));\nassert_eq!(path.strip_prefix(\"/test/haha/foo.txt/\"), Ok(Path::new(\"\")));\nassert_eq!(path.strip_prefix(\"test\").is_ok(), false);\nassert_eq!(path.strip_prefix(\"/haha\").is_ok(), false);\n\nlet prefix = PathBuf::from(\"/test/\");\nassert_eq!(path.strip_prefix(prefix), Ok(Path::new(\"haha/foo.txt\")));"]}},{"name":"pub fn starts_with<P: AsRef<Path>>(&self, base: P) -> bool","details":{"description":["Determines whether base is a prefix of self.","Only considers whole path components to match."],"example":["use std::path::Path;\n\nlet path = Path::new(\"/etc/passwd\");\n\nassert!(path.starts_with(\"/etc\"));\nassert!(path.starts_with(\"/etc/\"));\nassert!(path.starts_with(\"/etc/passwd\"));\nassert!(path.starts_with(\"/etc/passwd/\"));\n\nassert!(!path.starts_with(\"/e\"));"]}},{"name":"pub fn ends_with<P: AsRef<Path>>(&self, child: P) -> bool","details":{"description":["Determines whether child is a suffix of self.","Only considers whole path components to match."],"example":["use std::path::Path;\n\nlet path = Path::new(\"/etc/passwd\");\n\nassert!(path.ends_with(\"passwd\"));"]}},{"name":"pub fn file_stem(&self) -> Option<&OsStr>","details":{"description":["Extracts the stem (non-extension) portion of self.file_name.","The stem is:","None, if there is no file name; The entire file name if there is no embedded .; The entire file name if the file name begins with . and has no other .s within; Otherwise, the portion of the file name before the final ."],"example":["use std::path::Path;\n\nlet path = Path::new(\"foo.rs\");\n\nassert_eq!(\"foo\", path.file_stem().unwrap());"]}},{"name":"pub fn extension(&self) -> Option<&OsStr>","details":{"description":["Extracts the extension of self.file_name, if possible.","The extension is:","None, if there is no file name; None, if there is no embedded .; None, if the file name begins with . and has no other .s within; Otherwise, the portion of the file name after the final ."],"example":["use std::path::Path;\n\nlet path = Path::new(\"foo.rs\");\n\nassert_eq!(\"rs\", path.extension().unwrap());"]}},{"name":"pub fn join<P: AsRef<Path>>(&self, path: P) -> PathBuf","details":{"description":["Creates an owned PathBuf with path adjoined to self.","See PathBuf::push for more details on what it means to adjoin a path."],"example":["use std::path::{Path, PathBuf};\n\nassert_eq!(Path::new(\"/etc\").join(\"passwd\"), PathBuf::from(\"/etc/passwd\"));"]}},{"name":"pub fn with_file_name<S: AsRef<OsStr>>(&self, file_name: S) -> PathBuf","details":{"description":["Creates an owned PathBuf like self but with the given file name.","See PathBuf::set_file_name for more details."],"example":["use std::path::{Path, PathBuf};\n\nlet path = Path::new(\"/tmp/foo.txt\");\nassert_eq!(path.with_file_name(\"bar.txt\"), PathBuf::from(\"/tmp/bar.txt\"));\n\nlet path = Path::new(\"/tmp\");\nassert_eq!(path.with_file_name(\"var\"), PathBuf::from(\"/var\"));"]}},{"name":"pub fn with_extension<S: AsRef<OsStr>>(&self, extension: S) -> PathBuf","details":{"description":["Creates an owned PathBuf like self but with the given extension.","See PathBuf::set_extension for more details."],"example":["use std::path::{Path, PathBuf};\n\nlet path = Path::new(\"foo.rs\");\nassert_eq!(path.with_extension(\"txt\"), PathBuf::from(\"foo.txt\"));"]}},{"name":"pub fn components(&self) -> Components","details":{"description":["Produces an iterator over the Components of the path.","When parsing the path, there is a small amount of normalization:","Repeated separators are ignored, so a/b and a//b both have a and b as components. Occurrences of . are normalized away, except if they are at the beginning of the path. For example, a/./b, a/b/, a/b/. and a/b all have a and b as components, but ./a/b starts with an additional CurDir component.","Note that no other normalization takes place; in particular, a/c and a/b/../c are distinct, to account for the possibility that b is a symbolic link (so its parent isn't a)."],"example":["use std::path::{Path, Component};\nuse std::ffi::OsStr;\n\nlet mut components = Path::new(\"/tmp/foo.txt\").components();\n\nassert_eq!(components.next(), Some(Component::RootDir));\nassert_eq!(components.next(), Some(Component::Normal(OsStr::new(\"tmp\"))));\nassert_eq!(components.next(), Some(Component::Normal(OsStr::new(\"foo.txt\"))));\nassert_eq!(components.next(), None)"]}},{"name":"pub fn iter(&self) -> Iter","details":{"description":["Produces an iterator over the path's components viewed as OsStr slices.","For more information about the particulars of how the path is separated into components, see components."],"example":["use std::path::{self, Path};\nuse std::ffi::OsStr;\n\nlet mut it = Path::new(\"/tmp/foo.txt\").iter();\nassert_eq!(it.next(), Some(OsStr::new(&path::MAIN_SEPARATOR.to_string())));\nassert_eq!(it.next(), Some(OsStr::new(\"tmp\")));\nassert_eq!(it.next(), Some(OsStr::new(\"foo.txt\")));\nassert_eq!(it.next(), None)"]}},{"name":"pub fn display(&self) -> Display","details":{"description":["Returns an object that implements Display for safely printing paths that may contain non-Unicode data."],"example":["use std::path::Path;\n\nlet path = Path::new(\"/tmp/foo.rs\");\n\nprintln!(\"{}\", path.display());"]}},{"name":"pub fn metadata(&self) -> Result<Metadata>","details":{"description":["Queries the file system to get information about a file, directory, etc.","This function will traverse symbolic links to query information about the destination file.","This is an alias to fs::metadata."],"example":["use std::path::Path;\n\nlet path = Path::new(\"/Minas/tirith\");\nlet metadata = path.metadata().expect(\"metadata call failed\");\nprintln!(\"{:?}\", metadata.file_type());"]}},{"name":"pub fn symlink_metadata(&self) -> Result<Metadata>","details":{"description":["Queries the metadata about a file without following symlinks.","This is an alias to fs::symlink_metadata."],"example":["use std::path::Path;\n\nlet path = Path::new(\"/Minas/tirith\");\nlet metadata = path.symlink_metadata().expect(\"symlink_metadata call failed\");\nprintln!(\"{:?}\", metadata.file_type());"]}},{"name":"pub fn canonicalize(&self) -> Result<PathBuf>","details":{"description":["Returns the canonical, absolute form of the path with all intermediate components normalized and symbolic links resolved.","This is an alias to fs::canonicalize."],"example":["use std::path::{Path, PathBuf};\n\nlet path = Path::new(\"/foo/test/../test/bar.rs\");\nassert_eq!(path.canonicalize().unwrap(), PathBuf::from(\"/foo/test/bar.rs\"));"]}},{"name":"pub fn read_link(&self) -> Result<PathBuf>","details":{"description":["Reads a symbolic link, returning the file that the link points to.","This is an alias to fs::read_link."],"example":["use std::path::Path;\n\nlet path = Path::new(\"/laputa/sky_castle.rs\");\nlet path_link = path.read_link().expect(\"read_link call failed\");"]}},{"name":"pub fn read_dir(&self) -> Result<ReadDir>","details":{"description":["Returns an iterator over the entries within a directory.","The iterator will yield instances of io::Result<DirEntry>. New errors may be encountered after an iterator is initially constructed.","This is an alias to fs::read_dir."],"example":["use std::path::Path;\n\nlet path = Path::new(\"/laputa\");\nfor entry in path.read_dir().expect(\"read_dir call failed\") {\n    if let Ok(entry) = entry {\n        println!(\"{:?}\", entry.path());\n    }\n}"]}},{"name":"pub fn exists(&self) -> bool","details":{"description":["Returns whether the path points at an existing entity.","This function will traverse symbolic links to query information about the destination file. In case of broken symbolic links this will return false.","If you cannot access the directory containing the file, e.g. because of a permission error, this will return false."],"example":["use std::path::Path;\nassert_eq!(Path::new(\"does_not_exist.txt\").exists(), false);","See Also","This is a convenience function that coerces errors to false. If you want to\ncheck errors, call fs::metadata."]}},{"name":"pub fn is_file(&self) -> bool","details":{"description":["Returns whether the path exists on disk and is pointing at a regular file.","This function will traverse symbolic links to query information about the destination file. In case of broken symbolic links this will return false.","If you cannot access the directory containing the file, e.g. because of a permission error, this will return false."],"example":["use std::path::Path;\nassert_eq!(Path::new(\"./is_a_directory/\").is_file(), false);\nassert_eq!(Path::new(\"a_file.txt\").is_file(), true);","See Also","This is a convenience function that coerces errors to false. If you want to\ncheck errors, call fs::metadata and handle its Result. Then call\nfs::Metadata::is_file if it was Ok."]}},{"name":"pub fn is_dir(&self) -> bool","details":{"description":["Returns whether the path exists on disk and is pointing at a directory.","This function will traverse symbolic links to query information about the destination file. In case of broken symbolic links this will return false.","If you cannot access the directory containing the file, e.g. because of a permission error, this will return false."],"example":["use std::path::Path;\nassert_eq!(Path::new(\"./is_a_directory/\").is_dir(), true);\nassert_eq!(Path::new(\"a_file.txt\").is_dir(), false);","See Also","This is a convenience function that coerces errors to false. If you want to\ncheck errors, call fs::metadata and handle its Result. Then call\nfs::Metadata::is_dir if it was Ok."]}},{"name":"pub fn into_path_buf(self: Box<Path>) -> PathBuf","details":{"description":["Converts a Box<Path> into a PathBuf without copying or allocating."]}}]}