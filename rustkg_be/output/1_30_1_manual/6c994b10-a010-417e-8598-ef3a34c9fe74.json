{"stability":{"stable since":"1.0.0"},"apiName":"std::ops::Deref","apiType":"trait","apiDocumentation":{"apiDescription":["Used for immutable dereferencing operations, like *v.","In addition to being used for explicit dereferencing operations with the (unary) * operator in immutable contexts, Deref is also used implicitly by the compiler in many circumstances. This mechanism is called 'Deref coercion'. In mutable contexts, DerefMut is used.","Implementing Deref for smart pointers makes accessing the data behind them convenient, which is why they implement Deref. On the other hand, the rules regarding Deref and DerefMut were designed specifically to accommodate smart pointers. Because of this, Deref should only be implemented for smart pointers to avoid confusion.","For similar reasons, this trait should never fail. Failure during dereferencing can be extremely confusing when Deref is invoked implicitly.","More on Deref coercion","If T implements Deref<Target = U>, and x is a value of type T, then:","In immutable contexts, *x on non-pointer types is equivalent to *Deref::deref(&x). Values of type &T are coerced to values of type &U T implicitly implements all the (immutable) methods of the type U.","For more details, visit the chapter in The Rust Programming Language as well as the reference sections on the dereference operator, method resolution and type coercions."],"examples":["A struct with a single field which is accessible by dereferencing the\nstruct.","use std::ops::Deref;\n\nstruct DerefExample<T> {\n    value: T\n}\n\nimpl<T> Deref for DerefExample<T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        &self.value\n    }\n}\n\nlet x = DerefExample { value: 'a' };\nassert_eq!('a', *x);"]},"trait required methods":[{"name":"[+] Expand attributes#[must_use] fn deref(&self) -> &Self::Target","details":{"description":"Dereferences the value."}}]}