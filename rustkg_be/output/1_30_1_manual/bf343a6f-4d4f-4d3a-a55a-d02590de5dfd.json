{"stability":{"stable since":"1.0.0"},"apiName":"std::iter::repeat","apiType":"function","apiDocumentation":{"apiDescription":["Creates a new iterator that endlessly repeats a single element.","The repeat() function repeats a single value over and over and over and over and over and 🔁.","Infinite iterators like repeat() are often used with adapters like take, in order to make them finite.","If the element type of the iterator you need does not implement Clone, or if you do not want to keep the repeated element in memory, you can instead use the repeat_with function."],"examples":["Basic usage:","use std::iter;\n\n// the number four 4ever:\nlet mut fours = iter::repeat(4);\n\nassert_eq!(Some(4), fours.next());\nassert_eq!(Some(4), fours.next());\nassert_eq!(Some(4), fours.next());\nassert_eq!(Some(4), fours.next());\nassert_eq!(Some(4), fours.next());\n\n// yup, still four\nassert_eq!(Some(4), fours.next());","Going finite with take:","use std::iter;\n\n// that last example was too many fours. Let's only have four fours.\nlet mut four_fours = iter::repeat(4).take(4);\n\nassert_eq!(Some(4), four_fours.next());\nassert_eq!(Some(4), four_fours.next());\nassert_eq!(Some(4), four_fours.next());\nassert_eq!(Some(4), four_fours.next());\n\n// ... and now we're done\nassert_eq!(None, four_fours.next());"]}}