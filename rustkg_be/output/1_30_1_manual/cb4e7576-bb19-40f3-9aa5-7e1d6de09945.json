{"stability":{"stable since":"1.9.0"},"apiName":"std::panic::AssertUnwindSafe","apiType":"struct","apiDocumentation":{"apiDescription":["A simple wrapper around a type to assert that it is unwind safe.","When using catch_unwind it may be the case that some of the closed over variables are not unwind safe. For example if &mut T is captured the compiler will generate a warning indicating that it is not unwind safe. It may not be the case, however, that this is actually a problem due to the specific usage of catch_unwind if unwind safety is specifically taken into account. This wrapper struct is useful for a quick and lightweight annotation that a variable is indeed unwind safe."],"examples":["One way to use AssertUnwindSafe is to assert that the entire closure\nitself is unwind safe, bypassing all checks for all variables:","use std::panic::{self, AssertUnwindSafe};\n\nlet mut variable = 4;\n\n// This code will not compile because the closure captures `&mut variable`\n// which is not considered unwind safe by default.\n\n// panic::catch_unwind(|| {\n//     variable += 3;\n// });\n\n// This, however, will compile due to the `AssertUnwindSafe` wrapper\nlet result = panic::catch_unwind(AssertUnwindSafe(|| {\n    variable += 3;\n}));\n// ...","Wrapping the entire closure amounts to a blanket assertion that all captured\nvariables are unwind safe. This has the downside that if new captures are\nadded in the future, they will also be considered unwind safe. Therefore,\nyou may prefer to just wrap individual captures, as shown below. This is\nmore annotation, but it ensures that if a new capture is added which is not\nunwind safe, you will get a compilation error at that time, which will\nallow you to consider whether that new capture in fact represent a bug or\nnot.","use std::panic::{self, AssertUnwindSafe};\n\nlet mut variable = 4;\nlet other_capture = 3;\n\nlet result = {\n    let mut wrapper = AssertUnwindSafe(&mut variable);\n    panic::catch_unwind(move || {\n        **wrapper += other_capture;\n    })\n};\n// ..."]},"trait implementations":[{"name":"impl<T> std::panic::UnwindSafe for std::panic::AssertUnwindSafe<T>","stable since":"1.0.0"},{"name":"impl<T> std::panic::RefUnwindSafe for std::panic::AssertUnwindSafe<T>","stable since":"1.0.0"},{"name":"impl<T> std::ops::Deref for std::panic::AssertUnwindSafe<T>","stable since":"1.0.0"},{"name":"impl<T> std::ops::DerefMut for std::panic::AssertUnwindSafe<T>","stable since":"1.0.0"},{"name":"impl<R, F: std::ops::FnOnce() -> R> std::ops::FnOnce<()> for std::panic::AssertUnwindSafe<F>","stable since":"1.0.0"},{"name":"impl<T: std::fmt::Debug> std::fmt::Debug for std::panic::AssertUnwindSafe<T>","stable since":"1.16.0"},{"name":"impl<'a, F: std::future::Future> std::future::Future for std::panic::AssertUnwindSafe<F>","stable since":"1.0.0"},{"name":"impl<T> std::marker::Send for std::panic::AssertUnwindSafe<T> where T: std::marker::Send","stable since":"1.0.0"},{"name":"impl<T> std::marker::Sync for std::panic::AssertUnwindSafe<T> where T: std::marker::Sync","stable since":"1.0.0"}]}