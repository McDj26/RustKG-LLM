{"stability":{"stable since":"1.0.0"},"apiName":"std::slice::from_raw_parts","apiType":"function","apiDocumentation":{"apiDescription":["Forms a slice from a pointer and a length.","The len argument is the number of elements, not the number of bytes.","Safety","This function is unsafe as there is no guarantee that the given pointer is valid for len elements, nor whether the lifetime inferred is a suitable lifetime for the returned slice.","data must be non-null and aligned, even for zero-length slices. One reason for this is that enum layout optimizations may rely on references (including slices of any length) being aligned and non-null to distinguish them from other data. You can obtain a pointer that is usable as data for zero-length slices using NonNull::dangling().","Caveat","The lifetime for the returned slice is inferred from its usage. To prevent accidental misuse, it's suggested to tie the lifetime to whichever source lifetime is safe in the context, such as by providing a helper function taking the lifetime of a host value for the slice, or by explicit annotation."],"examples":["use std::slice;\n\n// manifest a slice for a single element\nlet x = 42;\nlet ptr = &x as *const _;\nlet slice = unsafe { slice::from_raw_parts(ptr, 1) };\nassert_eq!(slice[0], 42);"]}}