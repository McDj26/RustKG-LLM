{"stability":{"stable since":"1.0.0"},"apiName":"std::net::Ipv6Addr","apiType":"struct","apiDocumentation":{"apiDescription":["An IPv6 address.","IPv6 addresses are defined as 128-bit integers in IETF RFC 4291. They are usually represented as eight 16-bit segments.","See IpAddr for a type encompassing both IPv4 and IPv6 addresses.","The size of an Ipv6Addr struct may vary depending on the target operating system.","Textual representation","Ipv6Addr provides a FromStr implementation. There are many ways to represent an IPv6 address in text, but in general, each segments is written in hexadecimal notation, and segments are separated by :. For more information, see IETF RFC 5952."],"examples":["use std::net::Ipv6Addr;\n\nlet localhost = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1);\nassert_eq!(\"::1\".parse(), Ok(localhost));\nassert_eq!(localhost.is_loopback(), true);"]},"trait implementations":[{"name":"impl std::marker::Copy for std::net::Ipv6Addr","stable since":"1.0.0"},{"name":"impl std::convert::From<std::net::Ipv6Addr> for std::net::IpAddr","stable since":"1.16.0"},{"name":"impl std::fmt::Display for std::net::Ipv6Addr","stable since":"1.0.0"},{"name":"impl std::fmt::Debug for std::net::Ipv6Addr","stable since":"1.0.0"},{"name":"impl std::clone::Clone for std::net::Ipv6Addr","stable since":"1.0.0"},{"name":"impl std::cmp::PartialEq for std::net::Ipv6Addr","stable since":"1.0.0"},{"name":"impl std::cmp::PartialEq<std::net::IpAddr> for std::net::Ipv6Addr","stable since":"1.16.0"},{"name":"impl std::cmp::PartialEq<std::net::Ipv6Addr> for std::net::IpAddr","stable since":"1.16.0"},{"name":"impl std::cmp::Eq for std::net::Ipv6Addr","stable since":"1.0.0"},{"name":"impl std::hash::Hash for std::net::Ipv6Addr","stable since":"1.0.0"},{"name":"impl std::cmp::PartialOrd for std::net::Ipv6Addr","stable since":"1.0.0"},{"name":"impl std::cmp::PartialOrd<std::net::Ipv6Addr> for std::net::IpAddr","stable since":"1.16.0"},{"name":"impl std::cmp::PartialOrd<std::net::IpAddr> for std::net::Ipv6Addr","stable since":"1.16.0"},{"name":"impl std::cmp::Ord for std::net::Ipv6Addr","stable since":"1.0.0"},{"name":"impl std::convert::From<std::net::Ipv6Addr> for u128","stable since":"1.26.0"},{"name":"impl std::convert::From<u128> for std::net::Ipv6Addr","stable since":"1.26.0"},{"name":"impl std::convert::From<[u8; 16]> for std::net::Ipv6Addr","stable since":"1.9.0"},{"name":"impl std::convert::From<[u16; 8]> for std::net::Ipv6Addr","stable since":"1.16.0"},{"name":"impl std::str::FromStr for std::net::Ipv6Addr","stable since":"1.0.0"},{"name":"impl std::marker::Send for std::net::Ipv6Addr","stable since":"1.0.0"},{"name":"impl std::marker::Sync for std::net::Ipv6Addr","stable since":"1.0.0"}],"methods":[{"name":"pub const fn new( a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16, h: u16) -> Ipv6Addr","details":{"description":["Creates a new IPv6 address from eight 16-bit segments.","The result will represent the IP address a:b:c:d:e:f:g:h."],"example":["use std::net::Ipv6Addr;\n\nlet addr = Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff);"]}},{"name":"pub fn segments(&self) -> [u16; 8]","details":{"description":["Returns the eight 16-bit segments that make up this address."],"example":["use std::net::Ipv6Addr;\n\nassert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).segments(),\n           [0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff]);"]}},{"name":"pub fn is_unspecified(&self) -> bool","details":{"description":["Returns true for the special 'unspecified' address (::).","This property is defined in IETF RFC 4291."],"example":["use std::net::Ipv6Addr;\n\nassert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unspecified(), false);\nassert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0).is_unspecified(), true);"]}},{"name":"pub fn is_loopback(&self) -> bool","details":{"description":["Returns true if this is a loopback address (::1).","This property is defined in IETF RFC 4291."],"example":["use std::net::Ipv6Addr;\n\nassert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_loopback(), false);\nassert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0x1).is_loopback(), true);"]}},{"name":"pub fn is_global(&self) -> bool","stability":["ðŸ”¬ This is a nightly-only experimental API.  (ip #27709)extra functionality has not been scrutinized to the level that it should be to be stable\n"]},{"name":"pub fn is_unique_local(&self) -> bool","stability":["ðŸ”¬ This is a nightly-only experimental API.  (ip #27709)extra functionality has not been scrutinized to the level that it should be to be stable\n"]},{"name":"pub fn is_unicast_link_local(&self) -> bool","stability":["ðŸ”¬ This is a nightly-only experimental API.  (ip #27709)extra functionality has not been scrutinized to the level that it should be to be stable\n"]},{"name":"pub fn is_unicast_site_local(&self) -> bool","stability":["ðŸ”¬ This is a nightly-only experimental API.  (ip #27709)extra functionality has not been scrutinized to the level that it should be to be stable\n"]},{"name":"pub fn is_documentation(&self) -> bool","stability":["ðŸ”¬ This is a nightly-only experimental API.  (ip #27709)extra functionality has not been scrutinized to the level that it should be to be stable\n"]},{"name":"pub fn is_unicast_global(&self) -> bool","stability":["ðŸ”¬ This is a nightly-only experimental API.  (ip #27709)extra functionality has not been scrutinized to the level that it should be to be stable\n"]},{"name":"pub fn multicast_scope(&self) -> Option<Ipv6MulticastScope>","stability":["ðŸ”¬ This is a nightly-only experimental API.  (ip #27709)extra functionality has not been scrutinized to the level that it should be to be stable\n"]},{"name":"pub fn is_multicast(&self) -> bool","details":{"description":["Returns true if this is a multicast address (ff00::/8).","This property is defined by IETF RFC 4291."],"example":["use std::net::Ipv6Addr;\n\nassert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).is_multicast(), true);\nassert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_multicast(), false);"]}},{"name":"pub fn to_ipv4(&self) -> Option<Ipv4Addr>","details":{"description":["Converts this address to an IPv4 address. Returns None if this address is neither IPv4-compatible or IPv4-mapped.","::a.b.c.d and ::ffff:a.b.c.d become a.b.c.d"],"example":["use std::net::{Ipv4Addr, Ipv6Addr};\n\nassert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).to_ipv4(), None);\nassert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).to_ipv4(),\n           Some(Ipv4Addr::new(192, 10, 2, 255)));\nassert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_ipv4(),\n           Some(Ipv4Addr::new(0, 0, 0, 1)));"]}},{"name":"pub fn octets(&self) -> [u8; 16]","details":{"description":["Returns the sixteen eight-bit integers the IPv6 address consists of.","use std::net::Ipv6Addr; assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).octets(), [255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);"]}}]}