{"stability":{"stable since":"1.0.0"},"apiName":"std::thread::park","apiType":"function","apiDocumentation":{"apiDescription":["Blocks unless or until the current thread's token is made available.","A call to park does not guarantee that the thread will remain parked forever, and callers should be prepared for this possibility.","park and unpark","Every thread is equipped with some basic low-level blocking support, via the thread::park function and thread::Thread::unpark method. park blocks the current thread, which can then be resumed from another thread by calling the unpark method on the blocked thread's handle.","Conceptually, each Thread handle has an associated token, which is initially not present:","The thread::park function blocks the current thread unless or until the token is available for its thread handle, at which point it atomically consumes the token. It may also return spuriously, without consuming the token. thread::park_timeout does the same, but allows specifying a maximum time to block the thread for. The unpark method on a Thread atomically makes the token available if it wasn't already. Because the token is initially absent, unpark followed by park will result in the second call returning immediately.","In other words, each Thread acts a bit like a spinlock that can be locked and unlocked using park and unpark.","The API is typically used by acquiring a handle to the current thread, placing that handle in a shared data structure so that other threads can find it, and then parking. When some desired condition is met, another thread calls unpark on the handle.","The motivation for this design is twofold:","It avoids the need to allocate mutexes and condvars when building new synchronization primitives; the threads already provide basic blocking/signaling. It can be implemented very efficiently on many platforms."],"examples":["use std::thread;\nuse std::time::Duration;\n\nlet parked_thread = thread::Builder::new()\n    .spawn(|| {\n        println!(\"Parking thread\");\n        thread::park();\n        println!(\"Thread unparked\");\n    })\n    .unwrap();\n\n// Let some time pass for the thread to be spawned.\nthread::sleep(Duration::from_millis(10));\n\n// There is no race condition here, if `unpark`\n// happens first, `park` will return immediately.\nprintln!(\"Unpark the thread\");\nparked_thread.thread().unpark();\n\nparked_thread.join().unwrap();"]}}