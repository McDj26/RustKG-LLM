{"stability":{"stable since":"1.0.0"},"apiName":"std::fmt::Formatter","apiType":"struct","apiDocumentation":{"apiDescription":["A struct to represent both where to emit formatting strings to and how they should be formatted. A mutable version of this is passed to all formatting traits."]},"trait implementations":[{"name":"impl<'a> std::fmt::Write for std::fmt::Formatter<'a>","stable since":"1.2.0"},{"name":"impl<'a> !std::marker::Send for std::fmt::Formatter<'a>","stable since":"1.0.0"},{"name":"impl<'a> !std::marker::Sync for std::fmt::Formatter<'a>","stable since":"1.0.0"}],"methods":[{"name":"pub fn pad_integral( &mut self, is_nonnegative: bool, prefix: &str, buf: &str) -> Result<(), Error>","details":{"description":["Performs the correct padding for an integer which has already been emitted into a str. The str should not contain the sign for the integer, that will be added by this method.","Arguments","is_nonnegative - whether the original integer was either positive or zero. prefix - if the '#' character (Alternate) is provided, this is the prefix to put in front of the number. buf - the byte array that the number has been formatted into","This function will correctly account for the flags provided as well as the minimum width. It will not take precision into account."],"example":["use std::fmt;\n\nstruct Foo { nb: i32 };\n\nimpl Foo {\n    fn new(nb: i32) -> Foo {\n        Foo {\n            nb,\n        }\n    }\n}\n\nimpl fmt::Display for Foo {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        // We need to remove \"-\" from the number output.\n        let tmp = self.nb.abs().to_string();\n\n        formatter.pad_integral(self.nb > 0, \"Foo \", &tmp)\n    }\n}\n\nassert_eq!(&format!(\"{}\", Foo::new(2)), \"2\");\nassert_eq!(&format!(\"{}\", Foo::new(-1)), \"-1\");\nassert_eq!(&format!(\"{:#}\", Foo::new(-1)), \"-Foo 1\");\nassert_eq!(&format!(\"{:0>#8}\", Foo::new(-1)), \"00-Foo 1\");"]}},{"name":"pub fn pad(&mut self, s: &str) -> Result<(), Error>","details":{"description":["This function takes a string slice and emits it to the internal buffer after applying the relevant formatting flags specified. The flags recognized for generic strings are:","width - the minimum width of what to emit fill/align - what to emit and where to emit it if the string provided needs to be padded precision - the maximum length to emit, the string is truncated if it is longer than this length","Notably this function ignores the flag parameters."],"example":["use std::fmt;\n\nstruct Foo;\n\nimpl fmt::Display for Foo {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.pad(\"Foo\")\n    }\n}\n\nassert_eq!(&format!(\"{:<4}\", Foo), \"Foo \");\nassert_eq!(&format!(\"{:0>4}\", Foo), \"0Foo\");"]}},{"name":"pub fn write_str(&mut self, data: &str) -> Result<(), Error>","details":{"description":["Writes some data to the underlying buffer contained within this formatter."],"example":["use std::fmt;\n\nstruct Foo;\n\nimpl fmt::Display for Foo {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"Foo\")\n        // This is equivalent to:\n        // write!(formatter, \"Foo\")\n    }\n}\n\nassert_eq!(&format!(\"{}\", Foo), \"Foo\");\nassert_eq!(&format!(\"{:0>8}\", Foo), \"Foo\");"]}},{"name":"pub fn write_fmt(&mut self, fmt: Arguments) -> Result<(), Error>","details":{"description":["Writes some formatted information into this instance."],"example":["use std::fmt;\n\nstruct Foo(i32);\n\nimpl fmt::Display for Foo {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_fmt(format_args!(\"Foo {}\", self.0))\n    }\n}\n\nassert_eq!(&format!(\"{}\", Foo(-1)), \"Foo -1\");\nassert_eq!(&format!(\"{:0>8}\", Foo(2)), \"Foo 2\");"]}},{"name":"pub fn flags(&self) -> u32","stability":["Deprecated since 1.24.0: use the sign_plus, sign_minus, alternate, or sign_aware_zero_pad methods instead\n"]},{"name":"pub fn fill(&self) -> char","details":{"description":["Character used as 'fill' whenever there is alignment."],"example":["use std::fmt;\n\nstruct Foo;\n\nimpl fmt::Display for Foo {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        let c = formatter.fill();\n        if let Some(width) = formatter.width() {\n            for _ in 0..width {\n                write!(formatter, \"{}\", c)?;\n            }\n            Ok(())\n        } else {\n            write!(formatter, \"{}\", c)\n        }\n    }\n}\n\n// We set alignment to the left with \">\".\nassert_eq!(&format!(\"{:G>3}\", Foo), \"GGG\");\nassert_eq!(&format!(\"{:t>6}\", Foo), \"tttttt\");"]}},{"name":"pub fn align(&self) -> Option<Alignment>","details":{"description":["Flag indicating what form of alignment was requested."],"example":["extern crate core;\n\nuse std::fmt::{self, Alignment};\n\nstruct Foo;\n\nimpl fmt::Display for Foo {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        let s = if let Some(s) = formatter.align() {\n            match s {\n                Alignment::Left    => \"left\",\n                Alignment::Right   => \"right\",\n                Alignment::Center  => \"center\",\n            }\n        } else {\n            \"into the void\"\n        };\n        write!(formatter, \"{}\", s)\n    }\n}\n\nfn main() {\n    assert_eq!(&format!(\"{:<}\", Foo), \"left\");\n    assert_eq!(&format!(\"{:>}\", Foo), \"right\");\n    assert_eq!(&format!(\"{:^}\", Foo), \"center\");\n    assert_eq!(&format!(\"{}\", Foo), \"into the void\");\n}"]}},{"name":"pub fn width(&self) -> Option<usize>","details":{"description":["Optionally specified integer width that the output should be."],"example":["use std::fmt;\n\nstruct Foo(i32);\n\nimpl fmt::Display for Foo {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        if let Some(width) = formatter.width() {\n            // If we received a width, we use it\n            write!(formatter, \"{:width$}\", &format!(\"Foo({})\", self.0), width = width)\n        } else {\n            // Otherwise we do nothing special\n            write!(formatter, \"Foo({})\", self.0)\n        }\n    }\n}\n\nassert_eq!(&format!(\"{:10}\", Foo(23)), \"Foo(23)   \");\nassert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");"]}},{"name":"pub fn precision(&self) -> Option<usize>","details":{"description":["Optionally specified precision for numeric types."],"example":["use std::fmt;\n\nstruct Foo(f32);\n\nimpl fmt::Display for Foo {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        if let Some(precision) = formatter.precision() {\n            // If we received a precision, we use it.\n            write!(formatter, \"Foo({1:.*})\", precision, self.0)\n        } else {\n            // Otherwise we default to 2.\n            write!(formatter, \"Foo({:.2})\", self.0)\n        }\n    }\n}\n\nassert_eq!(&format!(\"{:.4}\", Foo(23.2)), \"Foo(23.2000)\");\nassert_eq!(&format!(\"{}\", Foo(23.2)), \"Foo(23.20)\");"]}},{"name":"pub fn sign_plus(&self) -> bool","details":{"description":["Determines if the + flag was specified."],"example":["use std::fmt;\n\nstruct Foo(i32);\n\nimpl fmt::Display for Foo {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        if formatter.sign_plus() {\n            write!(formatter,\n                   \"Foo({}{})\",\n                   if self.0 < 0 { '-' } else { '+' },\n                   self.0)\n        } else {\n            write!(formatter, \"Foo({})\", self.0)\n        }\n    }\n}\n\nassert_eq!(&format!(\"{:+}\", Foo(23)), \"Foo(+23)\");\nassert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");"]}},{"name":"pub fn sign_minus(&self) -> bool","details":{"description":["Determines if the - flag was specified."],"example":["use std::fmt;\n\nstruct Foo(i32);\n\nimpl fmt::Display for Foo {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        if formatter.sign_minus() {\n            // You want a minus sign? Have one!\n            write!(formatter, \"-Foo({})\", self.0)\n        } else {\n            write!(formatter, \"Foo({})\", self.0)\n        }\n    }\n}\n\nassert_eq!(&format!(\"{:-}\", Foo(23)), \"-Foo(23)\");\nassert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");"]}},{"name":"pub fn alternate(&self) -> bool","details":{"description":["Determines if the # flag was specified."],"example":["use std::fmt;\n\nstruct Foo(i32);\n\nimpl fmt::Display for Foo {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        if formatter.alternate() {\n            write!(formatter, \"Foo({})\", self.0)\n        } else {\n            write!(formatter, \"{}\", self.0)\n        }\n    }\n}\n\nassert_eq!(&format!(\"{:#}\", Foo(23)), \"Foo(23)\");\nassert_eq!(&format!(\"{}\", Foo(23)), \"23\");"]}},{"name":"pub fn sign_aware_zero_pad(&self) -> bool","details":{"description":["Determines if the 0 flag was specified."],"example":["use std::fmt;\n\nstruct Foo(i32);\n\nimpl fmt::Display for Foo {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        assert!(formatter.sign_aware_zero_pad());\n        assert_eq!(formatter.width(), Some(4));\n        // We ignore the formatter's options.\n        write!(formatter, \"{}\", self.0)\n    }\n}\n\nassert_eq!(&format!(\"{:04}\", Foo(23)), \"23\");"]}},{"name":"pub fn debug_struct(&'b mut self, name: &str) -> DebugStruct<'b, 'a>","details":{"description":["Creates a DebugStruct builder designed to assist with creation of fmt::Debug implementations for structs."],"example":["use std::fmt;\nuse std::net::Ipv4Addr;\n\nstruct Foo {\n    bar: i32,\n    baz: String,\n    addr: Ipv4Addr,\n}\n\nimpl fmt::Debug for Foo {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        fmt.debug_struct(\"Foo\")\n            .field(\"bar\", &self.bar)\n            .field(\"baz\", &self.baz)\n            .field(\"addr\", &format_args!(\"{}\", self.addr))\n            .finish()\n    }\n}\n\nassert_eq!(\n    \"Foo { bar: 10, baz: \\\"Hello World\\\", addr: 127.0.0.1 }\",\n    format!(\"{:?}\", Foo {\n        bar: 10,\n        baz: \"Hello World\".to_string(),\n        addr: Ipv4Addr::new(127, 0, 0, 1),\n    })\n);"]}},{"name":"pub fn debug_tuple(&'b mut self, name: &str) -> DebugTuple<'b, 'a>","details":{"description":["Creates a DebugTuple builder designed to assist with creation of fmt::Debug implementations for tuple structs."],"example":["use std::fmt;\nuse std::marker::PhantomData;\n\nstruct Foo<T>(i32, String, PhantomData<T>);\n\nimpl<T> fmt::Debug for Foo<T> {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        fmt.debug_tuple(\"Foo\")\n            .field(&self.0)\n            .field(&self.1)\n            .field(&format_args!(\"_\"))\n            .finish()\n    }\n}\n\nassert_eq!(\n    \"Foo(10, \\\"Hello\\\", _)\",\n    format!(\"{:?}\", Foo(10, \"Hello\".to_string(), PhantomData::<u8>))\n);"]}},{"name":"pub fn debug_list(&'b mut self) -> DebugList<'b, 'a>","details":{"description":["Creates a DebugList builder designed to assist with creation of fmt::Debug implementations for list-like structures."],"example":["use std::fmt;\n\nstruct Foo(Vec<i32>);\n\nimpl fmt::Debug for Foo {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        fmt.debug_list().entries(self.0.iter()).finish()\n    }\n}\n\n// prints \"[10, 11]\"\nprintln!(\"{:?}\", Foo(vec![10, 11]));"]}},{"name":"pub fn debug_set(&'b mut self) -> DebugSet<'b, 'a>","details":{"description":["Creates a DebugSet builder designed to assist with creation of fmt::Debug implementations for set-like structures."],"example":["use std::fmt;\n\nstruct Foo(Vec<i32>);\n\nimpl fmt::Debug for Foo {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        fmt.debug_set().entries(self.0.iter()).finish()\n    }\n}\n\n// prints \"{10, 11}\"\nprintln!(\"{:?}\", Foo(vec![10, 11]));","In this more complex example, we use format_args! and .debug_set()\nto build a list of match arms:","use std::fmt;\n\nstruct Arm<'a, L: 'a, R: 'a>(&'a (L, R));\nstruct Table<'a, K: 'a, V: 'a>(&'a [(K, V)], V);\n\nimpl<'a, L, R> fmt::Debug for Arm<'a, L, R>\nwhere\n    L: 'a + fmt::Debug, R: 'a + fmt::Debug\n{\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        L::fmt(&(self.0).0, fmt)?;\n        fmt.write_str(\" => \")?;\n        R::fmt(&(self.0).1, fmt)\n    }\n}\n\nimpl<'a, K, V> fmt::Debug for Table<'a, K, V>\nwhere\n    K: 'a + fmt::Debug, V: 'a + fmt::Debug\n{\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        fmt.debug_set()\n        .entries(self.0.iter().map(Arm))\n        .entry(&Arm(&(format_args!(\"_\"), &self.1)))\n        .finish()\n    }\n}"]}},{"name":"pub fn debug_map(&'b mut self) -> DebugMap<'b, 'a>","details":{"description":["Creates a DebugMap builder designed to assist with creation of fmt::Debug implementations for map-like structures."],"example":["use std::fmt;\n\nstruct Foo(Vec<(String, i32)>);\n\nimpl fmt::Debug for Foo {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        fmt.debug_map().entries(self.0.iter().map(|&(ref k, ref v)| (k, v))).finish()\n    }\n}\n\n// prints \"{\"A\": 10, \"B\": 11}\"\nprintln!(\"{:?}\", Foo(vec![(\"A\".to_string(), 10), (\"B\".to_string(), 11)]));"]}}]}