{"stability":{"stable since":"1.0.0"},"apiName":"str","apiType":"primitive","apiDocumentation":{"apiDescription":["String slices.","See also the std::str module.","The str type, also called a 'string slice', is the most primitive string type. It is usually seen in its borrowed form, &str. It is also the type of string literals, &'static str.","String slices are always valid UTF-8.","A &str is made up of two components: a pointer to some bytes, and a length. You can look at these with the as_ptr and len methods:","use std::slice; use std::str; let story = \"Once upon a time...\"; let ptr = story.as_ptr(); let len = story.len(); // story has nineteen bytes assert_eq!(19, len); // We can re-build a str out of ptr and len. This is all unsafe because // we are responsible for making sure the two components are valid: let s = unsafe { // First, we build a &[u8]... let slice = slice::from_raw_parts(ptr, len); // ... and then convert that slice into a string slice str::from_utf8(slice) }; assert_eq!(s, Ok(story));","Note: This example shows the internals of &str. unsafe should not be used to get a string slice under normal circumstances. Use as_slice instead."],"examples":["String literals are string slices:","let hello = \"Hello, world!\";\n\n// with an explicit type annotation\nlet hello: &'static str = \"Hello, world!\";","They are 'static because they're stored directly in the final binary, and\nso will be valid for the 'static duration."]},"trait implementations":[{"name":"impl std::hash::Hash for str","stable since":"1.0.0"},{"name":"impl std::cmp::PartialOrd<str> for str","stable since":"1.0.0"},{"name":"impl std::ops::IndexMut<std::ops::RangeInclusive<usize>> for str","stable since":"1.26.0"},{"name":"impl std::ops::IndexMut<std::ops::RangeFrom<usize>> for str","stable since":"1.3.0"},{"name":"impl std::ops::IndexMut<std::ops::Range<usize>> for str","stable since":"1.3.0"},{"name":"impl std::ops::IndexMut<std::ops::RangeTo<usize>> for str","stable since":"1.3.0"},{"name":"impl std::ops::IndexMut<std::ops::RangeFull> for str","stable since":"1.3.0"},{"name":"impl std::ops::IndexMut<std::ops::RangeToInclusive<usize>> for str","stable since":"1.26.0"},{"name":"impl std::ops::Index<std::ops::RangeFrom<usize>> for str","stable since":"1.0.0"},{"name":"impl std::ops::Index<std::ops::RangeToInclusive<usize>> for str","stable since":"1.26.0"},{"name":"impl std::ops::Index<std::ops::RangeTo<usize>> for str","stable since":"1.0.0"},{"name":"impl std::ops::Index<std::ops::RangeFull> for str","stable since":"1.0.0"},{"name":"impl std::ops::Index<std::ops::Range<usize>> for str","stable since":"1.0.0"},{"name":"impl std::ops::Index<std::ops::RangeInclusive<usize>> for str","stable since":"1.26.0"},{"name":"impl std::cmp::Ord for str","stable since":"1.0.0"},{"name":"impl std::fmt::Debug for str","stable since":"1.0.0"},{"name":"impl std::cmp::Eq for str","stable since":"1.0.0"},{"name":"impl std::cmp::PartialEq<str> for str","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::str::pattern::Pattern<'a> for &'b str","stable since":"1.0.0"},{"name":"impl std::convert::AsRef<str> for str","stable since":"1.0.0"},{"name":"impl std::convert::AsRef<[u8]> for str","stable since":"1.0.0"},{"name":"impl<'a> std::default::Default for &'a str","stable since":"1.0.0"},{"name":"impl<'a> std::default::Default for &'a mut str","stable since":"1.28.0"},{"name":"impl std::fmt::Display for str","stable since":"1.0.0"},{"name":"impl std::borrow::ToOwned for str","stable since":"1.0.0"},{"name":"impl std::string::ToString for str","stable since":"1.9.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<std::borrow::Cow<'a, str>> for &'b str","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<std::string::String> for str","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<std::string::String> for &'a str","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<std::borrow::Cow<'a, str>> for str","stable since":"1.0.0"},{"name":"impl std::ascii::AsciiExt for str","stable since":"1.0.0"},{"name":"impl std::cmp::PartialEq<std::ffi::OsString> for str","stable since":"1.0.0"},{"name":"impl<'a> std::cmp::PartialEq<std::ffi::OsString> for &'a str","stable since":"1.29.0"},{"name":"impl std::cmp::PartialEq<std::ffi::OsStr> for str","stable since":"1.0.0"},{"name":"impl std::convert::AsRef<std::ffi::OsStr> for str","stable since":"1.0.0"},{"name":"impl std::net::ToSocketAddrs for str","stable since":"1.0.0"},{"name":"impl std::convert::AsRef<std::path::Path> for str","stable since":"1.0.0"},{"name":"impl std::marker::Send for str","stable since":"1.0.0"},{"name":"impl std::marker::Sync for str","stable since":"1.0.0"},{"name":"impl std::marker::Send for str","stable since":"1.0.0"},{"name":"impl std::marker::Sync for str","stable since":"1.0.0"}],"methods":[{"name":"pub const fn len(&self) -> usize","details":{"description":["Returns the length of self.","This length is in bytes, not chars or graphemes. In other words, it may not be what a human considers the length of the string."],"example":["Basic usage:","let len = \"foo\".len();\nassert_eq!(3, len);\n\nlet len = \"∆íoo\".len(); // fancy f!\nassert_eq!(4, len);"]}},{"name":"pub const fn is_empty(&self) -> bool","details":{"description":["Returns true if self has a length of zero bytes."],"example":["Basic usage:","let s = \"\";\nassert!(s.is_empty());\n\nlet s = \"not empty\";\nassert!(!s.is_empty());"]}},{"name":"pub fn is_char_boundary(&self, index: usize) -> bool","details":{"description":["Checks that index-th byte lies at the start and/or end of a UTF-8 code point sequence.","The start and end of the string (when index == self.len()) are considered to be boundaries.","Returns false if index is greater than self.len()."],"example":["let s = \"L√∂we ËÄÅËôé L√©opard\";\nassert!(s.is_char_boundary(0));\n// start of `ËÄÅ`\nassert!(s.is_char_boundary(6));\nassert!(s.is_char_boundary(s.len()));\n\n// second byte of `√∂`\nassert!(!s.is_char_boundary(2));\n\n// third byte of `ËÄÅ`\nassert!(!s.is_char_boundary(8));"]}},{"name":"pub const fn as_bytes(&self) -> &[u8]","details":{"description":["Converts a string slice to a byte slice. To convert the byte slice back into a string slice, use the str::from_utf8 function."],"example":["Basic usage:","let bytes = \"bors\".as_bytes();\nassert_eq!(b\"bors\", bytes);"]}},{"name":"pub unsafe fn as_bytes_mut(&mut self) -> &mut [u8]","details":{"description":["Converts a mutable string slice to a mutable byte slice. To convert the mutable byte slice back into a mutable string slice, use the str::from_utf8_mut function."],"example":["Basic usage:","let mut s = String::from(\"Hello\");\nlet bytes = unsafe { s.as_bytes_mut() };\n\nassert_eq!(b\"Hello\", bytes);","Mutability:","let mut s = String::from(\"üóª‚ààüåè\");\n\nunsafe {\n    let bytes = s.as_bytes_mut();\n\n    bytes[0] = 0xF0;\n    bytes[1] = 0x9F;\n    bytes[2] = 0x8D;\n    bytes[3] = 0x94;\n}\n\nassert_eq!(\"üçî‚ààüåè\", s);"]}},{"name":"pub const fn as_ptr(&self) -> *const u8","details":{"description":["Converts a string slice to a raw pointer.","As string slices are a slice of bytes, the raw pointer points to a u8. This pointer will be pointing to the first byte of the string slice."],"example":["Basic usage:","let s = \"Hello\";\nlet ptr = s.as_ptr();"]}},{"name":"pub fn get<I>(&self, i: I) -> Option<&<I as SliceIndex<str>>::Output> where I: SliceIndex<str>","details":{"description":["Returns a subslice of str.","This is the non-panicking alternative to indexing the str. Returns None whenever equivalent indexing operation would panic."],"example":["let v = String::from(\"üóª‚ààüåè\");\n\nassert_eq!(Some(\"üóª\"), v.get(0..4));\n\n// indices not on UTF-8 sequence boundaries\nassert!(v.get(1..).is_none());\nassert!(v.get(..8).is_none());\n\n// out of bounds\nassert!(v.get(..42).is_none());"]}},{"name":"pub fn get_mut<I>( &mut self, i: I) -> Option<&mut <I as SliceIndex<str>>::Output> where I: SliceIndex<str>","details":{"description":["Returns a mutable subslice of str.","This is the non-panicking alternative to indexing the str. Returns None whenever equivalent indexing operation would panic."],"example":["let mut v = String::from(\"hello\");\n// correct length\nassert!(v.get_mut(0..5).is_some());\n// out of bounds\nassert!(v.get_mut(..42).is_none());\nassert_eq!(Some(\"he\"), v.get_mut(0..2).map(|v| &*v));\n\nassert_eq!(\"hello\", v);\n{\n    let s = v.get_mut(0..2);\n    let s = s.map(|s| {\n        s.make_ascii_uppercase();\n        &*s\n    });\n    assert_eq!(Some(\"HE\"), s);\n}\nassert_eq!(\"HEllo\", v);"]}},{"name":"pub unsafe fn get_unchecked<I>(&self, i: I) -> &<I as SliceIndex<str>>::Output where I: SliceIndex<str>","details":{"description":["Returns a unchecked subslice of str.","This is the unchecked alternative to indexing the str.","Safety","Callers of this function are responsible that these preconditions are satisfied:","The starting index must come before the ending index; Indexes must be within bounds of the original slice; Indexes must lie on UTF-8 sequence boundaries.","Failing that, the returned string slice may reference invalid memory or violate the invariants communicated by the str type."],"example":["let v = \"üóª‚ààüåè\";\nunsafe {\n    assert_eq!(\"üóª\", v.get_unchecked(0..4));\n    assert_eq!(\"‚àà\", v.get_unchecked(4..7));\n    assert_eq!(\"üåè\", v.get_unchecked(7..11));\n}"]}},{"name":"pub unsafe fn get_unchecked_mut<I>( &mut self, i: I) -> &mut <I as SliceIndex<str>>::Output where I: SliceIndex<str>","details":{"description":["Returns a mutable, unchecked subslice of str.","This is the unchecked alternative to indexing the str.","Safety","Callers of this function are responsible that these preconditions are satisfied:","The starting index must come before the ending index; Indexes must be within bounds of the original slice; Indexes must lie on UTF-8 sequence boundaries.","Failing that, the returned string slice may reference invalid memory or violate the invariants communicated by the str type."],"example":["let mut v = String::from(\"üóª‚ààüåè\");\nunsafe {\n    assert_eq!(\"üóª\", v.get_unchecked_mut(0..4));\n    assert_eq!(\"‚àà\", v.get_unchecked_mut(4..7));\n    assert_eq!(\"üåè\", v.get_unchecked_mut(7..11));\n}"]}},{"name":"pub unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str","stability":["Deprecated since 1.29.0: use get_unchecked(begin..end) instead\n"]},{"name":"pub unsafe fn slice_mut_unchecked( &mut self, begin: usize, end: usize) -> &mut str","stability":["Deprecated since 1.29.0: use get_unchecked_mut(begin..end) instead\n"]},{"name":"pub fn split_at(&self, mid: usize) -> (&str, &str)","details":{"description":["Divide one string slice into two at an index.","The argument, mid, should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point.","The two slices returned go from the start of the string slice to mid, and from mid to the end of the string slice.","To get mutable string slices instead, see the split_at_mut method.","Panics","Panics if mid is not on a UTF-8 code point boundary, or if it is beyond the last code point of the string slice."],"example":["Basic usage:","let s = \"Per Martin-L√∂f\";\n\nlet (first, last) = s.split_at(3);\n\nassert_eq!(\"Per\", first);\nassert_eq!(\" Martin-L√∂f\", last);"]}},{"name":"pub fn split_at_mut(&mut self, mid: usize) -> (&mut str, &mut str)","details":{"description":["Divide one mutable string slice into two at an index.","The argument, mid, should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point.","The two slices returned go from the start of the string slice to mid, and from mid to the end of the string slice.","To get immutable string slices instead, see the split_at method.","Panics","Panics if mid is not on a UTF-8 code point boundary, or if it is beyond the last code point of the string slice."],"example":["Basic usage:","let mut s = \"Per Martin-L√∂f\".to_string();\n{\n    let (first, last) = s.split_at_mut(3);\n    first.make_ascii_uppercase();\n    assert_eq!(\"PER\", first);\n    assert_eq!(\" Martin-L√∂f\", last);\n}\nassert_eq!(\"PER Martin-L√∂f\", s);"]}},{"name":"pub fn chars(&self) -> Chars","details":{"description":["Returns an iterator over the chars of a string slice.","As a string slice consists of valid UTF-8, we can iterate through a string slice by char. This method returns such an iterator.","It's important to remember that char represents a Unicode Scalar Value, and may not match your idea of what a 'character' is. Iteration over grapheme clusters may be what you actually want."],"example":["Basic usage:","let word = \"goodbye\";\n\nlet count = word.chars().count();\nassert_eq!(7, count);\n\nlet mut chars = word.chars();\n\nassert_eq!(Some('g'), chars.next());\nassert_eq!(Some('o'), chars.next());\nassert_eq!(Some('o'), chars.next());\nassert_eq!(Some('d'), chars.next());\nassert_eq!(Some('b'), chars.next());\nassert_eq!(Some('y'), chars.next());\nassert_eq!(Some('e'), chars.next());\n\nassert_eq!(None, chars.next());","Remember, chars may not match your human intuition about characters:","let y = \"yÃÜ\";\n\nlet mut chars = y.chars();\n\nassert_eq!(Some('y'), chars.next()); // not 'yÃÜ'\nassert_eq!(Some('\\u{0306}'), chars.next());\n\nassert_eq!(None, chars.next());"]}},{"name":"pub fn char_indices(&self) -> CharIndices","details":{"description":["Returns an iterator over the chars of a string slice, and their positions.","As a string slice consists of valid UTF-8, we can iterate through a string slice by char. This method returns an iterator of both these chars, as well as their byte positions.","The iterator yields tuples. The position is first, the char is second."],"example":["Basic usage:","let word = \"goodbye\";\n\nlet count = word.char_indices().count();\nassert_eq!(7, count);\n\nlet mut char_indices = word.char_indices();\n\nassert_eq!(Some((0, 'g')), char_indices.next());\nassert_eq!(Some((1, 'o')), char_indices.next());\nassert_eq!(Some((2, 'o')), char_indices.next());\nassert_eq!(Some((3, 'd')), char_indices.next());\nassert_eq!(Some((4, 'b')), char_indices.next());\nassert_eq!(Some((5, 'y')), char_indices.next());\nassert_eq!(Some((6, 'e')), char_indices.next());\n\nassert_eq!(None, char_indices.next());","Remember, chars may not match your human intuition about characters:","let yes = \"yÃÜes\";\n\nlet mut char_indices = yes.char_indices();\n\nassert_eq!(Some((0, 'y')), char_indices.next()); // not (0, 'yÃÜ')\nassert_eq!(Some((1, '\\u{0306}')), char_indices.next());\n\n// note the 3 here - the last character took up two bytes\nassert_eq!(Some((3, 'e')), char_indices.next());\nassert_eq!(Some((4, 's')), char_indices.next());\n\nassert_eq!(None, char_indices.next());"]}},{"name":"pub fn bytes(&self) -> Bytes","details":{"description":["An iterator over the bytes of a string slice.","As a string slice consists of a sequence of bytes, we can iterate through a string slice by byte. This method returns such an iterator."],"example":["Basic usage:","let mut bytes = \"bors\".bytes();\n\nassert_eq!(Some(b'b'), bytes.next());\nassert_eq!(Some(b'o'), bytes.next());\nassert_eq!(Some(b'r'), bytes.next());\nassert_eq!(Some(b's'), bytes.next());\n\nassert_eq!(None, bytes.next());"]}},{"name":"pub fn split_whitespace(&self) -> SplitWhitespace","details":{"description":["Split a string slice by whitespace.","The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of whitespace.","'Whitespace' is defined according to the terms of the Unicode Derived Core Property White_Space. If you only want to split on ASCII whitespace instead, use split_ascii_whitespace."],"example":["Basic usage:","let mut iter = \"A few words\".split_whitespace();\n\nassert_eq!(Some(\"A\"), iter.next());\nassert_eq!(Some(\"few\"), iter.next());\nassert_eq!(Some(\"words\"), iter.next());\n\nassert_eq!(None, iter.next());","All kinds of whitespace are considered:","let mut iter = \" Mary   had\\ta\\u{2009}little  \\n\\t lamb\".split_whitespace();\nassert_eq!(Some(\"Mary\"), iter.next());\nassert_eq!(Some(\"had\"), iter.next());\nassert_eq!(Some(\"a\"), iter.next());\nassert_eq!(Some(\"little\"), iter.next());\nassert_eq!(Some(\"lamb\"), iter.next());\n\nassert_eq!(None, iter.next());"]}},{"name":"pub fn split_ascii_whitespace(&self) -> SplitAsciiWhitespace","stability":["üî¨ This is a nightly-only experimental API.  (split_ascii_whitespace #48656)"]},{"name":"pub fn lines(&self) -> Lines","details":{"description":["An iterator over the lines of a string, as string slices.","Lines are ended with either a newline (\\n) or a carriage return with a line feed (\\r\\n).","The final line ending is optional."],"example":["Basic usage:","let text = \"foo\\r\\nbar\\n\\nbaz\\n\";\nlet mut lines = text.lines();\n\nassert_eq!(Some(\"foo\"), lines.next());\nassert_eq!(Some(\"bar\"), lines.next());\nassert_eq!(Some(\"\"), lines.next());\nassert_eq!(Some(\"baz\"), lines.next());\n\nassert_eq!(None, lines.next());","The final line ending isn't required:","let text = \"foo\\nbar\\n\\r\\nbaz\";\nlet mut lines = text.lines();\n\nassert_eq!(Some(\"foo\"), lines.next());\nassert_eq!(Some(\"bar\"), lines.next());\nassert_eq!(Some(\"\"), lines.next());\nassert_eq!(Some(\"baz\"), lines.next());\n\nassert_eq!(None, lines.next());"]}},{"name":"pub fn lines_any(&self) -> LinesAny","stability":["Deprecated since 1.4.0: use lines() instead now\n"]},{"name":"pub fn encode_utf16(&self) -> EncodeUtf16","details":{"description":["Returns an iterator of u16 over the string encoded as UTF-16."],"example":["Basic usage:","let text = \"Za≈º√≥≈Çƒá gƒô≈õlƒÖ ja≈∫≈Ñ\";\n\nlet utf8_len = text.len();\nlet utf16_len = text.encode_utf16().count();\n\nassert!(utf16_len <= utf8_len);"]}},{"name":"pub fn contains<'a, P>(&'a self, pat: P) -> bool where P: Pattern<'a>","details":{"description":["Returns true if the given pattern matches a sub-slice of this string slice.","Returns false if it does not."],"example":["Basic usage:","let bananas = \"bananas\";\n\nassert!(bananas.contains(\"nana\"));\nassert!(!bananas.contains(\"apples\"));"]}},{"name":"pub fn starts_with<'a, P>(&'a self, pat: P) -> bool where P: Pattern<'a>","details":{"description":["Returns true if the given pattern matches a prefix of this string slice.","Returns false if it does not."],"example":["Basic usage:","let bananas = \"bananas\";\n\nassert!(bananas.starts_with(\"bana\"));\nassert!(!bananas.starts_with(\"nana\"));"]}},{"name":"pub fn ends_with<'a, P>(&'a self, pat: P) -> bool where P: Pattern<'a>, <P as Pattern<'a>>::Searcher: ReverseSearcher<'a>","details":{"description":["Returns true if the given pattern matches a suffix of this string slice.","Returns false if it does not."],"example":["Basic usage:","let bananas = \"bananas\";\n\nassert!(bananas.ends_with(\"anas\"));\nassert!(!bananas.ends_with(\"nana\"));"]}},{"name":"pub fn find<'a, P>(&'a self, pat: P) -> Option<usize> where P: Pattern<'a>","details":{"description":["Returns the byte index of the first character of this string slice that matches the pattern.","Returns None if the pattern doesn't match.","The pattern can be a &str, char, or a closure that determines if a character matches."],"example":["Simple patterns:","let s = \"L√∂we ËÄÅËôé L√©opard\";\n\nassert_eq!(s.find('L'), Some(0));\nassert_eq!(s.find('√©'), Some(14));\nassert_eq!(s.find(\"L√©opard\"), Some(13));","More complex patterns using point-free style and closures:","let s = \"L√∂we ËÄÅËôé L√©opard\";\n\nassert_eq!(s.find(char::is_whitespace), Some(5));\nassert_eq!(s.find(char::is_lowercase), Some(1));\nassert_eq!(s.find(|c: char| c.is_whitespace() || c.is_lowercase()), Some(1));\nassert_eq!(s.find(|c: char| (c < 'o') && (c > 'a')), Some(4));","Not finding the pattern:","let s = \"L√∂we ËÄÅËôé L√©opard\";\nlet x: &[_] = &['1', '2'];\n\nassert_eq!(s.find(x), None);"]}},{"name":"pub fn rfind<'a, P>(&'a self, pat: P) -> Option<usize> where P: Pattern<'a>, <P as Pattern<'a>>::Searcher: ReverseSearcher<'a>","details":{"description":["Returns the byte index of the last character of this string slice that matches the pattern.","Returns None if the pattern doesn't match.","The pattern can be a &str, char, or a closure that determines if a character matches."],"example":["Simple patterns:","let s = \"L√∂we ËÄÅËôé L√©opard\";\n\nassert_eq!(s.rfind('L'), Some(13));\nassert_eq!(s.rfind('√©'), Some(14));","More complex patterns with closures:","let s = \"L√∂we ËÄÅËôé L√©opard\";\n\nassert_eq!(s.rfind(char::is_whitespace), Some(12));\nassert_eq!(s.rfind(char::is_lowercase), Some(20));","Not finding the pattern:","let s = \"L√∂we ËÄÅËôé L√©opard\";\nlet x: &[_] = &['1', '2'];\n\nassert_eq!(s.rfind(x), None);"]}},{"name":"pub fn split<'a, P>(&'a self, pat: P) -> Split<'a, P> where P: Pattern<'a>","details":{"description":["An iterator over substrings of this string slice, separated by characters matched by a pattern.","The pattern can be a &str, char, or a closure that determines the split.","Iterator behavior","The returned iterator will be a DoubleEndedIterator if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, eg, char but not for &str.","If the pattern allows a reverse search but its results might differ from a forward search, the rsplit method can be used."],"example":["Simple patterns:","let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\nassert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n\nlet v: Vec<&str> = \"\".split('X').collect();\nassert_eq!(v, [\"\"]);\n\nlet v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\nassert_eq!(v, [\"lion\", \"\", \"tiger\", \"leopard\"]);\n\nlet v: Vec<&str> = \"lion::tiger::leopard\".split(\"::\").collect();\nassert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n\nlet v: Vec<&str> = \"abc1def2ghi\".split(char::is_numeric).collect();\nassert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n\nlet v: Vec<&str> = \"lionXtigerXleopard\".split(char::is_uppercase).collect();\nassert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);","A more complex pattern, using a closure:","let v: Vec<&str> = \"abc1defXghi\".split(|c| c == '1' || c == 'X').collect();\nassert_eq!(v, [\"abc\", \"def\", \"ghi\"]);","If a string contains multiple contiguous separators, you will end up\nwith empty strings in the output:","let x = \"||||a||b|c\".to_string();\nlet d: Vec<_> = x.split('|').collect();\n\nassert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);","Contiguous separators are separated by the empty string.","let x = \"(///)\".to_string();\nlet d: Vec<_> = x.split('/').collect();\n\nassert_eq!(d, &[\"(\", \"\", \"\", \")\"]);","Separators at the start or end of a string are neighbored\nby empty strings.","let d: Vec<_> = \"010\".split(\"0\").collect();\nassert_eq!(d, &[\"\", \"1\", \"\"]);","When the empty string is used as a separator, it separates\nevery character in the string, along with the beginning\nand end of the string.","let f: Vec<_> = \"rust\".split(\"\").collect();\nassert_eq!(f, &[\"\", \"r\", \"u\", \"s\", \"t\", \"\"]);","Contiguous separators can lead to possibly surprising behavior\nwhen whitespace is used as the separator. This code is correct:","let x = \"    a  b c\".to_string();\nlet d: Vec<_> = x.split(' ').collect();\n\nassert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);","It does not give you:","‚ìòThis example is not tested","assert_eq!(d, &[\"a\", \"b\", \"c\"]);","Use split_whitespace for this behavior."]}},{"name":"pub fn rsplit<'a, P>(&'a self, pat: P) -> RSplit<'a, P> where P: Pattern<'a>, <P as Pattern<'a>>::Searcher: ReverseSearcher<'a>","details":{"description":["An iterator over substrings of the given string slice, separated by characters matched by a pattern and yielded in reverse order.","The pattern can be a &str, char, or a closure that determines the split.","Iterator behavior","The returned iterator requires that the pattern supports a reverse search, and it will be a DoubleEndedIterator if a forward/reverse search yields the same elements.","For iterating from the front, the split method can be used."],"example":["Simple patterns:","let v: Vec<&str> = \"Mary had a little lamb\".rsplit(' ').collect();\nassert_eq!(v, [\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n\nlet v: Vec<&str> = \"\".rsplit('X').collect();\nassert_eq!(v, [\"\"]);\n\nlet v: Vec<&str> = \"lionXXtigerXleopard\".rsplit('X').collect();\nassert_eq!(v, [\"leopard\", \"tiger\", \"\", \"lion\"]);\n\nlet v: Vec<&str> = \"lion::tiger::leopard\".rsplit(\"::\").collect();\nassert_eq!(v, [\"leopard\", \"tiger\", \"lion\"]);","A more complex pattern, using a closure:","let v: Vec<&str> = \"abc1defXghi\".rsplit(|c| c == '1' || c == 'X').collect();\nassert_eq!(v, [\"ghi\", \"def\", \"abc\"]);"]}},{"name":"pub fn split_terminator<'a, P>(&'a self, pat: P) -> SplitTerminator<'a, P> where P: Pattern<'a>","details":{"description":["An iterator over substrings of the given string slice, separated by characters matched by a pattern.","The pattern can be a &str, char, or a closure that determines the split.","Equivalent to split, except that the trailing substring is skipped if empty.","This method can be used for string data that is terminated, rather than separated by a pattern.","Iterator behavior","The returned iterator will be a DoubleEndedIterator if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, eg, char but not for &str.","If the pattern allows a reverse search but its results might differ from a forward search, the rsplit_terminator method can be used."],"example":["Basic usage:","let v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\nassert_eq!(v, [\"A\", \"B\"]);\n\nlet v: Vec<&str> = \"A..B..\".split_terminator(\".\").collect();\nassert_eq!(v, [\"A\", \"\", \"B\", \"\"]);"]}},{"name":"pub fn rsplit_terminator<'a, P>(&'a self, pat: P) -> RSplitTerminator<'a, P> where P: Pattern<'a>, <P as Pattern<'a>>::Searcher: ReverseSearcher<'a>","details":{"description":["An iterator over substrings of self, separated by characters matched by a pattern and yielded in reverse order.","The pattern can be a simple &str, char, or a closure that determines the split. Additional libraries might provide more complex patterns like regular expressions.","Equivalent to split, except that the trailing substring is skipped if empty.","This method can be used for string data that is terminated, rather than separated by a pattern.","Iterator behavior","The returned iterator requires that the pattern supports a reverse search, and it will be double ended if a forward/reverse search yields the same elements.","For iterating from the front, the split_terminator method can be used."],"example":["let v: Vec<&str> = \"A.B.\".rsplit_terminator('.').collect();\nassert_eq!(v, [\"B\", \"A\"]);\n\nlet v: Vec<&str> = \"A..B..\".rsplit_terminator(\".\").collect();\nassert_eq!(v, [\"\", \"B\", \"\", \"A\"]);"]}},{"name":"pub fn splitn<'a, P>(&'a self, n: usize, pat: P) -> SplitN<'a, P> where P: Pattern<'a>","details":{"description":["An iterator over substrings of the given string slice, separated by a pattern, restricted to returning at most n items.","If n substrings are returned, the last substring (the nth substring) will contain the remainder of the string.","The pattern can be a &str, char, or a closure that determines the split.","Iterator behavior","The returned iterator will not be double ended, because it is not efficient to support.","If the pattern allows a reverse search, the rsplitn method can be used."],"example":["Simple patterns:","let v: Vec<&str> = \"Mary had a little lambda\".splitn(3, ' ').collect();\nassert_eq!(v, [\"Mary\", \"had\", \"a little lambda\"]);\n\nlet v: Vec<&str> = \"lionXXtigerXleopard\".splitn(3, \"X\").collect();\nassert_eq!(v, [\"lion\", \"\", \"tigerXleopard\"]);\n\nlet v: Vec<&str> = \"abcXdef\".splitn(1, 'X').collect();\nassert_eq!(v, [\"abcXdef\"]);\n\nlet v: Vec<&str> = \"\".splitn(1, 'X').collect();\nassert_eq!(v, [\"\"]);","A more complex pattern, using a closure:","let v: Vec<&str> = \"abc1defXghi\".splitn(2, |c| c == '1' || c == 'X').collect();\nassert_eq!(v, [\"abc\", \"defXghi\"]);"]}},{"name":"pub fn rsplitn<'a, P>(&'a self, n: usize, pat: P) -> RSplitN<'a, P> where P: Pattern<'a>, <P as Pattern<'a>>::Searcher: ReverseSearcher<'a>","details":{"description":["An iterator over substrings of this string slice, separated by a pattern, starting from the end of the string, restricted to returning at most n items.","If n substrings are returned, the last substring (the nth substring) will contain the remainder of the string.","The pattern can be a &str, char, or a closure that determines the split.","Iterator behavior","The returned iterator will not be double ended, because it is not efficient to support.","For splitting from the front, the splitn method can be used."],"example":["Simple patterns:","let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(3, ' ').collect();\nassert_eq!(v, [\"lamb\", \"little\", \"Mary had a\"]);\n\nlet v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(3, 'X').collect();\nassert_eq!(v, [\"leopard\", \"tiger\", \"lionX\"]);\n\nlet v: Vec<&str> = \"lion::tiger::leopard\".rsplitn(2, \"::\").collect();\nassert_eq!(v, [\"leopard\", \"lion::tiger\"]);","A more complex pattern, using a closure:","let v: Vec<&str> = \"abc1defXghi\".rsplitn(2, |c| c == '1' || c == 'X').collect();\nassert_eq!(v, [\"ghi\", \"abc1def\"]);"]}},{"name":"pub fn matches<'a, P>(&'a self, pat: P) -> Matches<'a, P> where P: Pattern<'a>","details":{"description":["An iterator over the disjoint matches of a pattern within the given string slice.","The pattern can be a &str, char, or a closure that determines if a character matches.","Iterator behavior","The returned iterator will be a DoubleEndedIterator if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, eg, char but not for &str.","If the pattern allows a reverse search but its results might differ from a forward search, the rmatches method can be used."],"example":["Basic usage:","let v: Vec<&str> = \"abcXXXabcYYYabc\".matches(\"abc\").collect();\nassert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n\nlet v: Vec<&str> = \"1abc2abc3\".matches(char::is_numeric).collect();\nassert_eq!(v, [\"1\", \"2\", \"3\"]);"]}},{"name":"pub fn rmatches<'a, P>(&'a self, pat: P) -> RMatches<'a, P> where P: Pattern<'a>, <P as Pattern<'a>>::Searcher: ReverseSearcher<'a>","details":{"description":["An iterator over the disjoint matches of a pattern within this string slice, yielded in reverse order.","The pattern can be a &str, char, or a closure that determines if a character matches.","Iterator behavior","The returned iterator requires that the pattern supports a reverse search, and it will be a DoubleEndedIterator if a forward/reverse search yields the same elements.","For iterating from the front, the matches method can be used."],"example":["Basic usage:","let v: Vec<&str> = \"abcXXXabcYYYabc\".rmatches(\"abc\").collect();\nassert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n\nlet v: Vec<&str> = \"1abc2abc3\".rmatches(char::is_numeric).collect();\nassert_eq!(v, [\"3\", \"2\", \"1\"]);"]}},{"name":"pub fn match_indices<'a, P>(&'a self, pat: P) -> MatchIndices<'a, P> where P: Pattern<'a>","details":{"description":["An iterator over the disjoint matches of a pattern within this string slice as well as the index that the match starts at.","For matches of pat within self that overlap, only the indices corresponding to the first match are returned.","The pattern can be a &str, char, or a closure that determines if a character matches.","Iterator behavior","The returned iterator will be a DoubleEndedIterator if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, eg, char but not for &str.","If the pattern allows a reverse search but its results might differ from a forward search, the rmatch_indices method can be used."],"example":["Basic usage:","let v: Vec<_> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\nassert_eq!(v, [(0, \"abc\"), (6, \"abc\"), (12, \"abc\")]);\n\nlet v: Vec<_> = \"1abcabc2\".match_indices(\"abc\").collect();\nassert_eq!(v, [(1, \"abc\"), (4, \"abc\")]);\n\nlet v: Vec<_> = \"ababa\".match_indices(\"aba\").collect();\nassert_eq!(v, [(0, \"aba\")]); // only the first `aba`"]}},{"name":"pub fn rmatch_indices<'a, P>(&'a self, pat: P) -> RMatchIndices<'a, P> where P: Pattern<'a>, <P as Pattern<'a>>::Searcher: ReverseSearcher<'a>","details":{"description":["An iterator over the disjoint matches of a pattern within self, yielded in reverse order along with the index of the match.","For matches of pat within self that overlap, only the indices corresponding to the last match are returned.","The pattern can be a &str, char, or a closure that determines if a character matches.","Iterator behavior","The returned iterator requires that the pattern supports a reverse search, and it will be a DoubleEndedIterator if a forward/reverse search yields the same elements.","For iterating from the front, the match_indices method can be used."],"example":["Basic usage:","let v: Vec<_> = \"abcXXXabcYYYabc\".rmatch_indices(\"abc\").collect();\nassert_eq!(v, [(12, \"abc\"), (6, \"abc\"), (0, \"abc\")]);\n\nlet v: Vec<_> = \"1abcabc2\".rmatch_indices(\"abc\").collect();\nassert_eq!(v, [(4, \"abc\"), (1, \"abc\")]);\n\nlet v: Vec<_> = \"ababa\".rmatch_indices(\"aba\").collect();\nassert_eq!(v, [(2, \"aba\")]); // only the last `aba`"]}},{"name":"pub fn trim(&self) -> &str","details":{"description":["Returns a string slice with leading and trailing whitespace removed.","'Whitespace' is defined according to the terms of the Unicode Derived Core Property White_Space."],"example":["Basic usage:","let s = \" Hello\\tworld\\t\";\n\nassert_eq!(\"Hello\\tworld\", s.trim());"]}},{"name":"pub fn trim_start(&self) -> &str","details":{"description":["Returns a string slice with leading whitespace removed.","'Whitespace' is defined according to the terms of the Unicode Derived Core Property White_Space.","Text directionality","A string is a sequence of bytes. start in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side; and for right-to-left languages like like Arabic or Hebrew, this will be the right side."],"example":["Basic usage:","let s = \" Hello\\tworld\\t\";\nassert_eq!(\"Hello\\tworld\\t\", s.trim_start());","Directionality:","let s = \"  English  \";\nassert!(Some('E') == s.trim_start().chars().next());\n\nlet s = \"  ◊¢◊ë◊®◊ô◊™  \";\nassert!(Some('◊¢') == s.trim_start().chars().next());"]}},{"name":"pub fn trim_end(&self) -> &str","details":{"description":["Returns a string slice with trailing whitespace removed.","'Whitespace' is defined according to the terms of the Unicode Derived Core Property White_Space.","Text directionality","A string is a sequence of bytes. end in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side; and for right-to-left languages like like Arabic or Hebrew, this will be the left side."],"example":["Basic usage:","let s = \" Hello\\tworld\\t\";\nassert_eq!(\" Hello\\tworld\", s.trim_end());","Directionality:","let s = \"  English  \";\nassert!(Some('h') == s.trim_end().chars().rev().next());\n\nlet s = \"  ◊¢◊ë◊®◊ô◊™  \";\nassert!(Some('◊™') == s.trim_end().chars().rev().next());"]}},{"name":"pub fn trim_left(&self) -> &str","stability":["Deprecating in 1.33.0: superseded by trim_start\n"]},{"name":"pub fn trim_right(&self) -> &str","stability":["Deprecating in 1.33.0: superseded by trim_end\n"]},{"name":"pub fn trim_matches<'a, P>(&'a self, pat: P) -> &'a str where P: Pattern<'a>, <P as Pattern<'a>>::Searcher: DoubleEndedSearcher<'a>","details":{"description":["Returns a string slice with all prefixes and suffixes that match a pattern repeatedly removed.","The pattern can be a char or a closure that determines if a character matches."],"example":["Simple patterns:","assert_eq!(\"11foo1bar11\".trim_matches('1'), \"foo1bar\");\nassert_eq!(\"123foo1bar123\".trim_matches(char::is_numeric), \"foo1bar\");\n\nlet x: &[_] = &['1', '2'];\nassert_eq!(\"12foo1bar12\".trim_matches(x), \"foo1bar\");","A more complex pattern, using a closure:","assert_eq!(\"1foo1barXX\".trim_matches(|c| c == '1' || c == 'X'), \"foo1bar\");"]}},{"name":"pub fn trim_start_matches<'a, P>(&'a self, pat: P) -> &'a str where P: Pattern<'a>","details":{"description":["Returns a string slice with all prefixes that match a pattern repeatedly removed.","The pattern can be a &str, char, or a closure that determines if a character matches.","Text directionality","A string is a sequence of bytes. 'Left' in this context means the first position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the right side, not the left."],"example":["Basic usage:","assert_eq!(\"11foo1bar11\".trim_start_matches('1'), \"foo1bar11\");\nassert_eq!(\"123foo1bar123\".trim_start_matches(char::is_numeric), \"foo1bar123\");\n\nlet x: &[_] = &['1', '2'];\nassert_eq!(\"12foo1bar12\".trim_start_matches(x), \"foo1bar12\");"]}},{"name":"pub fn trim_end_matches<'a, P>(&'a self, pat: P) -> &'a str where P: Pattern<'a>, <P as Pattern<'a>>::Searcher: ReverseSearcher<'a>","details":{"description":["Returns a string slice with all suffixes that match a pattern repeatedly removed.","The pattern can be a &str, char, or a closure that determines if a character matches.","Text directionality","A string is a sequence of bytes. 'Right' in this context means the last position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the left side, not the right."],"example":["Simple patterns:","assert_eq!(\"11foo1bar11\".trim_end_matches('1'), \"11foo1bar\");\nassert_eq!(\"123foo1bar123\".trim_end_matches(char::is_numeric), \"123foo1bar\");\n\nlet x: &[_] = &['1', '2'];\nassert_eq!(\"12foo1bar12\".trim_end_matches(x), \"12foo1bar\");","A more complex pattern, using a closure:","assert_eq!(\"1fooX\".trim_end_matches(|c| c == '1' || c == 'X'), \"1foo\");"]}},{"name":"pub fn trim_left_matches<'a, P>(&'a self, pat: P) -> &'a str where P: Pattern<'a>","stability":["Deprecating in 1.33.0: superseded by trim_start_matches\n"]},{"name":"pub fn trim_right_matches<'a, P>(&'a self, pat: P) -> &'a str where P: Pattern<'a>, <P as Pattern<'a>>::Searcher: ReverseSearcher<'a>","stability":["Deprecating in 1.33.0: superseded by trim_end_matches\n"]},{"name":"pub fn parse<F>(&self) -> Result<F, <F as FromStr>::Err> where F: FromStr","details":{"description":["Parses this string slice into another type.","Because parse is so general, it can cause problems with type inference. As such, parse is one of the few times you'll see the syntax affectionately known as the 'turbofish': ::<>. This helps the inference algorithm understand specifically which type you're trying to parse into.","parse can parse any type that implements the FromStr trait.","Errors","Will return Err if it's not possible to parse this string slice into the desired type."],"example":["Basic usage","let four: u32 = \"4\".parse().unwrap();\n\nassert_eq!(4, four);","Using the 'turbofish' instead of annotating four:","let four = \"4\".parse::<u32>();\n\nassert_eq!(Ok(4), four);","Failing to parse:","let nope = \"j\".parse::<u32>();\n\nassert!(nope.is_err());"]}},{"name":"pub fn is_ascii(&self) -> bool","details":{"description":["Checks if all characters in this string are within the ASCII range."],"example":["let ascii = \"hello!\\n\";\nlet non_ascii = \"Gr√º√üe, J√ºrgen ‚ù§\";\n\nassert!(ascii.is_ascii());\nassert!(!non_ascii.is_ascii());"]}},{"name":"pub fn eq_ignore_ascii_case(&self, other: &str) -> bool","details":{"description":["Checks that two strings are an ASCII case-insensitive match.","Same as to_ascii_lowercase(a) == to_ascii_lowercase(b), but without allocating and copying temporaries."],"example":["assert!(\"Ferris\".eq_ignore_ascii_case(\"FERRIS\"));\nassert!(\"Ferr√∂s\".eq_ignore_ascii_case(\"FERR√∂S\"));\nassert!(!\"Ferr√∂s\".eq_ignore_ascii_case(\"FERR√ñS\"));"]}},{"name":"pub fn make_ascii_uppercase(&mut self)","details":{"description":["Converts this string to its ASCII upper case equivalent in-place.","ASCII letters 'a' to 'z' are mapped to 'A' to 'Z', but non-ASCII letters are unchanged.","To return a new uppercased value without modifying the existing one, use to_ascii_uppercase."]}},{"name":"pub fn make_ascii_lowercase(&mut self)","details":{"description":["Converts this string to its ASCII lower case equivalent in-place.","ASCII letters 'A' to 'Z' are mapped to 'a' to 'z', but non-ASCII letters are unchanged.","To return a new lowercased value without modifying the existing one, use to_ascii_lowercase."]}},{"name":"pub fn into_boxed_bytes(self: Box<str>) -> Box<[u8]>","details":{"description":["Converts a Box<str> into a Box<[u8]> without copying or allocating."],"example":["Basic usage:","let s = \"this is a string\";\nlet boxed_str = s.to_owned().into_boxed_str();\nlet boxed_bytes = boxed_str.into_boxed_bytes();\nassert_eq!(*boxed_bytes, *s.as_bytes());"]}},{"name":"[+] Expand attributes#[must_use = \"this returns the replaced string as a new allocation, without modifying the original\"] pub fn replace<'a, P>(&'a self, from: P, to: &str) -> String where P: Pattern<'a>","details":{"description":["Replaces all matches of a pattern with another string.","replace creates a new String, and copies the data from this string slice into it. While doing so, it attempts to find matches of a pattern. If it finds any, it replaces them with the replacement string slice."],"example":["Basic usage:","let s = \"this is old\";\n\nassert_eq!(\"this is new\", s.replace(\"old\", \"new\"));","When the pattern doesn't match:","let s = \"this is old\";\nassert_eq!(s, s.replace(\"cookie monster\", \"little lamb\"));"]}},{"name":"[+] Expand attributes#[must_use = \"this returns the replaced string as a new allocation, without modifying the original\"] pub fn replacen<'a, P>(&'a self, pat: P, to: &str, count: usize) -> String where P: Pattern<'a>","details":{"description":["Replaces first N matches of a pattern with another string.","replacen creates a new String, and copies the data from this string slice into it. While doing so, it attempts to find matches of a pattern. If it finds any, it replaces them with the replacement string slice at most count times."],"example":["Basic usage:","let s = \"foo foo 123 foo\";\nassert_eq!(\"new new 123 foo\", s.replacen(\"foo\", \"new\", 2));\nassert_eq!(\"faa fao 123 foo\", s.replacen('o', \"a\", 3));\nassert_eq!(\"foo foo new23 foo\", s.replacen(char::is_numeric, \"new\", 1));","When the pattern doesn't match:","let s = \"this is old\";\nassert_eq!(s, s.replacen(\"cookie monster\", \"little lamb\", 10));"]}},{"name":"pub fn to_lowercase(&self) -> String","details":{"description":["Returns the lowercase equivalent of this string slice, as a new String.","'Lowercase' is defined according to the terms of the Unicode Derived Core Property Lowercase.","Since some characters can expand into multiple characters when changing the case, this function returns a String instead of modifying the parameter in-place."],"example":["Basic usage:","let s = \"HELLO\";\n\nassert_eq!(\"hello\", s.to_lowercase());","A tricky example, with sigma:","let sigma = \"Œ£\";\n\nassert_eq!(\"œÉ\", sigma.to_lowercase());\n\n// but at the end of a word, it's œÇ, not œÉ:\nlet odysseus = \"·ΩàŒîŒ•Œ£Œ£ŒïŒéŒ£\";\n\nassert_eq!(\"·ΩÄŒ¥œÖœÉœÉŒµœçœÇ\", odysseus.to_lowercase());","Languages without case are not changed:","let new_year = \"ÂÜúÂéÜÊñ∞Âπ¥\";\n\nassert_eq!(new_year, new_year.to_lowercase());"]}},{"name":"pub fn to_uppercase(&self) -> String","details":{"description":["Returns the uppercase equivalent of this string slice, as a new String.","'Uppercase' is defined according to the terms of the Unicode Derived Core Property Uppercase.","Since some characters can expand into multiple characters when changing the case, this function returns a String instead of modifying the parameter in-place."],"example":["Basic usage:","let s = \"hello\";\n\nassert_eq!(\"HELLO\", s.to_uppercase());","Scripts without case are not changed:","let new_year = \"ÂÜúÂéÜÊñ∞Âπ¥\";\n\nassert_eq!(new_year, new_year.to_uppercase());"]}},{"name":"pub fn escape_debug(&self) -> String","stability":["üî¨ This is a nightly-only experimental API.  (str_escape #27791)return type may change to be an iterator\n"]},{"name":"pub fn escape_default(&self) -> String","stability":["üî¨ This is a nightly-only experimental API.  (str_escape #27791)return type may change to be an iterator\n"]},{"name":"pub fn escape_unicode(&self) -> String","stability":["üî¨ This is a nightly-only experimental API.  (str_escape #27791)return type may change to be an iterator\n"]},{"name":"pub fn into_string(self: Box<str>) -> String","details":{"description":["Converts a Box<str> into a String without copying or allocating."],"example":["Basic usage:","let string = String::from(\"birthday gift\");\nlet boxed_str = string.clone().into_boxed_str();\n\nassert_eq!(boxed_str.into_string(), string);"]}},{"name":"pub fn repeat(&self, n: usize) -> String","details":{"description":["Creates a new String by repeating a string n times.","Panics","This function will panic if the capacity would overflow."],"example":["Basic usage:","assert_eq!(\"abc\".repeat(4), String::from(\"abcabcabcabc\"));","A panic upon overflow:","fn main() {\n    // this will panic at runtime\n    \"0123456789abcdef\".repeat(usize::max_value());\n}"]}},{"name":"pub fn to_ascii_uppercase(&self) -> String","details":{"description":["Returns a copy of this string where each character is mapped to its ASCII upper case equivalent.","ASCII letters 'a' to 'z' are mapped to 'A' to 'Z', but non-ASCII letters are unchanged.","To uppercase the value in-place, use make_ascii_uppercase.","To uppercase ASCII characters in addition to non-ASCII characters, use to_uppercase."],"example":["let s = \"Gr√º√üe, J√ºrgen ‚ù§\";\n\nassert_eq!(\"GR√º√üE, J√ºRGEN ‚ù§\", s.to_ascii_uppercase());"]}},{"name":"pub fn to_ascii_lowercase(&self) -> String","details":{"description":["Returns a copy of this string where each character is mapped to its ASCII lower case equivalent.","ASCII letters 'A' to 'Z' are mapped to 'a' to 'z', but non-ASCII letters are unchanged.","To lowercase the value in-place, use make_ascii_lowercase.","To lowercase ASCII characters in addition to non-ASCII characters, use to_lowercase."],"example":["let s = \"Gr√º√üe, J√ºrgen ‚ù§\";\n\nassert_eq!(\"gr√º√üe, j√ºrgen ‚ù§\", s.to_ascii_lowercase());"]}}]}