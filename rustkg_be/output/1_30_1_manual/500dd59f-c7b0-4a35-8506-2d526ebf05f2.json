{"stability":{"stable since":"1.0.0"},"apiName":"std::vec::Vec","apiType":"struct","apiDocumentation":{"apiDescription":["A contiguous growable array type, written Vec<T> but pronounced 'vector'.","The Vec type allows to access values by index, because it implements the Index trait. An example will be more explicit:","let v = vec![0, 2, 4, 6]; println!(\"{}\", v[1]); // it will display '2'","However be careful: if you try to access an index which isn't in the Vec, your software will panic! You cannot do this:","let v = vec![0, 2, 4, 6]; println!(\"{}\", v[6]); // it will panic!","In conclusion: always check if the index you want to get really exists before doing it.","Slicing","A Vec can be mutable. Slices, on the other hand, are read-only objects. To get a slice, use &. Example:","fn read_slice(slice: &[usize]) { // ... } let v = vec![0, 1]; read_slice(&v); // ... and that's all! // you can also do it like this: let x : &[usize] = &v;","In Rust, it's more common to pass slices as arguments rather than vectors when you just want to provide a read access. The same goes for String and &str.","Capacity and reallocation","The capacity of a vector is the amount of space allocated for any future elements that will be added onto the vector. This is not to be confused with the length of a vector, which specifies the number of actual elements within the vector. If a vector's length exceeds its capacity, its capacity will automatically be increased, but its elements will have to be reallocated.","For example, a vector with capacity 10 and length 0 would be an empty vector with space for 10 more elements. Pushing 10 or fewer elements onto the vector will not change its capacity or cause reallocation to occur. However, if the vector's length is increased to 11, it will have to reallocate, which can be slow. For this reason, it is recommended to use Vec::with_capacity whenever possible to specify how big the vector is expected to get.","Guarantees","Due to its incredibly fundamental nature, Vec makes a lot of guarantees about its design. This ensures that it's as low-overhead as possible in the general case, and can be correctly manipulated in primitive ways by unsafe code. Note that these guarantees refer to an unqualified Vec<T>. If additional type parameters are added (e.g. to support custom allocators), overriding their defaults may change the behavior.","Most fundamentally, Vec is and always will be a (pointer, capacity, length) triplet. No more, no less. The order of these fields is completely unspecified, and you should use the appropriate methods to modify these. The pointer will never be null, so this type is null-pointer-optimized.","However, the pointer may not actually point to allocated memory. In particular, if you construct a Vec with capacity 0 via Vec::new, vec![], Vec::with_capacity(0), or by calling shrink_to_fit on an empty Vec, it will not allocate memory. Similarly, if you store zero-sized types inside a Vec, it will not allocate space for them. Note that in this case the Vec may not report a capacity of 0. Vec will allocate if and only if mem::size_of::<T>() * capacity() > 0. In general, Vec's allocation details are very subtle â€” if you intend to allocate memory using a Vec and use it for something else (either to pass to unsafe code, or to build your own memory-backed collection), be sure to deallocate this memory by using from_raw_parts to recover the Vec and then dropping it.","If a Vec has allocated memory, then the memory it points to is on the heap (as defined by the allocator Rust is configured to use by default), and its pointer points to len initialized, contiguous elements in order (what you would see if you coerced it to a slice), followed by capacity-len logically uninitialized, contiguous elements.","Vec will never perform a \"small optimization\" where elements are actually stored on the stack for two reasons:","It would make it more difficult for unsafe code to correctly manipulate a Vec. The contents of a Vec wouldn't have a stable address if it were only moved, and it would be more difficult to determine if a Vec had actually allocated memory. It would penalize the general case, incurring an additional branch on every access.","Vec will never automatically shrink itself, even if completely empty. This ensures no unnecessary allocations or deallocations occur. Emptying a Vec and then filling it back up to the same len should incur no calls to the allocator. If you wish to free up unused memory, use shrink_to_fit.","push and insert will never (re)allocate if the reported capacity is sufficient. push and insert will (re)allocate if len==capacity. That is, the reported capacity is completely accurate, and can be relied on. It can even be used to manually free the memory allocated by a Vec if desired. Bulk insertion methods may reallocate, even when not necessary.","Vec does not guarantee any particular growth strategy when reallocating when full, nor when reserve is called. The current strategy is basic and it may prove desirable to use a non-constant growth factor. Whatever strategy is used will of course guarantee O(1) amortized push.","vec![x; n], vec![a, b, c, d], and Vec::with_capacity(n), will all produce a Vec with exactly the requested capacity. If len==capacity, (as is the case for the vec! macro), then a Vec<T> can be converted to and from a Box<[T]> without reallocating or moving the elements.","Vec will not specifically overwrite any data that is removed from it, but also won't specifically preserve it. Its uninitialized memory is scratch space that it may use however it wants. It will generally just do whatever is most efficient or otherwise easy to implement. Do not rely on removed data to be erased for security purposes. Even if you drop a Vec, its buffer may simply be reused by another Vec. Even if you zero a Vec's memory first, that may not actually happen because the optimizer does not consider this a side-effect that must be preserved. There is one case which we will not break, however: using unsafe code to write to the excess capacity, and then increasing the length to match, is always valid.","Vec does not currently guarantee the order in which elements are dropped. The order has changed in the past and may change again."],"examples":["let mut vec = Vec::new();\nvec.push(1);\nvec.push(2);\n\nassert_eq!(vec.len(), 2);\nassert_eq!(vec[0], 1);\n\nassert_eq!(vec.pop(), Some(2));\nassert_eq!(vec.len(), 1);\n\nvec[0] = 7;\nassert_eq!(vec[0], 7);\n\nvec.extend([1, 2, 3].iter().cloned());\n\nfor x in &vec {\n    println!(\"{}\", x);\n}\nassert_eq!(vec, [7, 1, 2, 3]);","The vec! macro is provided to make initialization more convenient:","let mut vec = vec![1, 2, 3];\nvec.push(4);\nassert_eq!(vec, [1, 2, 3, 4]);","It can also initialize each element of a Vec<T> with a given value:","let vec = vec![0; 5];\nassert_eq!(vec, [0, 0, 0, 0, 0]);","Use a Vec<T> as an efficient stack:","let mut stack = Vec::new();\n\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\nwhile let Some(top) = stack.pop() {\n    // Prints 3, 2, 1\n    println!(\"{}\", top);\n}"]},"trait implementations":[{"name":"impl<T> std::cmp::PartialOrd<std::vec::Vec<T>> for std::vec::Vec<T> where T: std::cmp::PartialOrd<T>","stable since":"1.0.0"},{"name":"impl<T> std::borrow::BorrowMut<[T]> for std::vec::Vec<T>","stable since":"1.0.0"},{"name":"impl<T> std::convert::AsRef<std::vec::Vec<T>> for std::vec::Vec<T>","stable since":"1.0.0"},{"name":"impl<T> std::convert::AsRef<[T]> for std::vec::Vec<T>","stable since":"1.0.0"},{"name":"impl<T> std::ops::Drop for std::vec::Vec<T>","stable since":"1.0.0"},{"name":"impl<T> std::convert::AsMut<[T]> for std::vec::Vec<T>","stable since":"1.5.0"},{"name":"impl<T> std::convert::AsMut<std::vec::Vec<T>> for std::vec::Vec<T>","stable since":"1.5.0"},{"name":"impl<'a, T> std::iter::IntoIterator for &'a mut std::vec::Vec<T>","stable since":"1.0.0"},{"name":"impl<'a, T> std::iter::IntoIterator for &'a std::vec::Vec<T>","stable since":"1.0.0"},{"name":"impl<T> std::iter::IntoIterator for std::vec::Vec<T>","stable since":"1.0.0"},{"name":"impl<T> std::cmp::Eq for std::vec::Vec<T> where T: std::cmp::Eq","stable since":"1.0.0"},{"name":"impl<T, I> std::ops::IndexMut<I> for std::vec::Vec<T> where I: std::slice::SliceIndex<[T]>","stable since":"1.0.0"},{"name":"impl<T> std::ops::Deref for std::vec::Vec<T>","stable since":"1.0.0"},{"name":"impl<T> std::borrow::Borrow<[T]> for std::vec::Vec<T>","stable since":"1.0.0"},{"name":"impl<T> std::ops::DerefMut for std::vec::Vec<T>","stable since":"1.0.0"},{"name":"impl<T> std::default::Default for std::vec::Vec<T>","stable since":"1.0.0"},{"name":"impl<T> std::iter::FromIterator<T> for std::vec::Vec<T>","stable since":"1.0.0"},{"name":"impl<'a, T> std::convert::From<&'a mut [T]> for std::vec::Vec<T> where T: std::clone::Clone","stable since":"1.19.0"},{"name":"impl<'a, T> std::convert::From<std::borrow::Cow<'a, [T]>> for std::vec::Vec<T> where [T]: std::borrow::ToOwned, <[T] as std::borrow::ToOwned>::std::borrow::ToOwned::Owned == std::vec::Vec<T>","stable since":"1.14.0"},{"name":"impl<T> std::convert::From<std::vec::Vec<T>> for std::sync::Arc<[T]>","stable since":"1.21.0"},{"name":"impl<T> std::convert::From<std::vec::Vec<T>> for std::rc::Rc<[T]>","stable since":"1.21.0"},{"name":"impl<T> std::convert::From<std::boxed::Box<[T]>> for std::vec::Vec<T>","stable since":"1.18.0"},{"name":"impl<'a, T> std::convert::From<std::vec::Vec<T>> for std::borrow::Cow<'a, [T]> where T: std::clone::Clone","stable since":"1.8.0"},{"name":"impl std::convert::From<std::string::String> for std::vec::Vec<u8>","stable since":"1.14.0"},{"name":"impl<T> std::convert::From<std::vec::Vec<T>> for std::collections::binary_heap::BinaryHeap<T> where T: std::cmp::Ord","stable since":"1.5.0"},{"name":"impl<'a> std::convert::From<&'a str> for std::vec::Vec<u8>","stable since":"1.0.0"},{"name":"impl<T> std::convert::From<std::collections::vec_deque::VecDeque<T>> for std::vec::Vec<T>","stable since":"1.10.0"},{"name":"impl<T> std::convert::From<std::collections::binary_heap::BinaryHeap<T>> for std::vec::Vec<T>","stable since":"1.5.0"},{"name":"impl<T> std::convert::From<std::vec::Vec<T>> for std::collections::vec_deque::VecDeque<T>","stable since":"1.10.0"},{"name":"impl<'a, T> std::convert::From<&'a [T]> for std::vec::Vec<T> where T: std::clone::Clone","stable since":"1.0.0"},{"name":"impl<'a, T> std::convert::From<&'a std::vec::Vec<T>> for std::borrow::Cow<'a, [T]> where T: std::clone::Clone","stable since":"1.28.0"},{"name":"impl<T> std::convert::From<std::vec::Vec<T>> for std::boxed::Box<[T]>","stable since":"1.20.0"},{"name":"impl<T> std::clone::Clone for std::vec::Vec<T> where T: std::clone::Clone","stable since":"1.0.0"},{"name":"impl<T> std::iter::Extend<T> for std::vec::Vec<T>","stable since":"1.0.0"},{"name":"impl<'a, T> std::iter::Extend<&'a T> for std::vec::Vec<T> where T: 'a + std::marker::Copy","stable since":"1.2.0"},{"name":"impl<T> std::hash::Hash for std::vec::Vec<T> where T: std::hash::Hash","stable since":"1.0.0"},{"name":"impl<T> std::fmt::Debug for std::vec::Vec<T> where T: std::fmt::Debug","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 30]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 13]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 29]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 25]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 8]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 31]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 13]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 22]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 15]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 7]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 3]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 17]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 32]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 28]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 4]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 8]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 14]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 24]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 27]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 16]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<std::vec::Vec<B>> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 4]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b mut [B]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 6]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 20]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 3]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 23]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 26]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 1]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 15]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 9]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 26]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 6]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 14]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 17]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 21]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 0]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 18]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 11]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 30]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 29]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 9]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 32]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 2]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 28]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 10]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<std::vec::Vec<B>> for std::borrow::Cow<'a, [A]> where A: std::clone::Clone + std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 1]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<std::vec::Vec<B>> for std::collections::vec_deque::VecDeque<A> where A: std::cmp::PartialEq<B>","stable since":"1.17.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 20]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 21]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 31]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 19]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 22]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 12]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 10]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 0]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 18]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 7]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 5]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 27]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 23]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 19]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 16]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 24]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 12]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 25]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<&'b [B; 2]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 11]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[B; 5]> for std::vec::Vec<A> where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<T> std::cmp::Ord for std::vec::Vec<T> where T: std::cmp::Ord","stable since":"1.0.0"},{"name":"impl<T, I> std::ops::Index<I> for std::vec::Vec<T> where I: std::slice::SliceIndex<[T]>","stable since":"1.0.0"},{"name":"impl std::convert::From<std::ffi::CString> for std::vec::Vec<u8>","stable since":"1.7.0"},{"name":"impl std::io::Write for std::vec::Vec<u8>","stable since":"1.0.0"},{"name":"impl<T> std::marker::Send for std::vec::Vec<T> where T: std::marker::Send","stable since":"1.0.0"},{"name":"impl<T> std::marker::Sync for std::vec::Vec<T> where T: std::marker::Sync","stable since":"1.0.0"}],"methods":[{"name":"pub const fn new() -> Vec<T>","details":{"description":["Constructs a new, empty Vec<T>.","The vector will not allocate until elements are pushed onto it."],"example":["let mut vec: Vec<i32> = Vec::new();"]}},{"name":"pub fn with_capacity(capacity: usize) -> Vec<T>","details":{"description":["Constructs a new, empty Vec<T> with the specified capacity.","The vector will be able to hold exactly capacity elements without reallocating. If capacity is 0, the vector will not allocate.","It is important to note that although the returned vector has the capacity specified, the vector will have a zero length. For an explanation of the difference between length and capacity, see Capacity and reallocation."],"example":["let mut vec = Vec::with_capacity(10);\n\n// The vector contains no items, even though it has capacity for more\nassert_eq!(vec.len(), 0);\n\n// These are all done without reallocating...\nfor i in 0..10 {\n    vec.push(i);\n}\n\n// ...but this may make the vector reallocate\nvec.push(11);"]}},{"name":"pub unsafe fn from_raw_parts( ptr: *mut T, length: usize, capacity: usize) -> Vec<T>","details":{"description":["Creates a Vec<T> directly from the raw components of another vector.","Safety","This is highly unsafe, due to the number of invariants that aren't checked:","ptr needs to have been previously allocated via String/Vec<T> (at least, it's highly likely to be incorrect if it wasn't). ptr's T needs to have the same size and alignment as it was allocated with. length needs to be less than or equal to capacity. capacity needs to be the capacity that the pointer was allocated with.","Violating these may cause problems like corrupting the allocator's internal data structures. For example it is not safe to build a Vec<u8> from a pointer to a C char array and a size_t.","The ownership of ptr is effectively transferred to the Vec<T> which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function."],"example":["use std::ptr;\nuse std::mem;\n\nfn main() {\n    let mut v = vec![1, 2, 3];\n\n    // Pull out the various important pieces of information about `v`\n    let p = v.as_mut_ptr();\n    let len = v.len();\n    let cap = v.capacity();\n\n    unsafe {\n        // Cast `v` into the void: no destructor run, so we are in\n        // complete control of the allocation to which `p` points.\n        mem::forget(v);\n\n        // Overwrite memory with 4, 5, 6\n        for i in 0..len as isize {\n            ptr::write(p.offset(i), 4 + i);\n        }\n\n        // Put everything back together into a Vec\n        let rebuilt = Vec::from_raw_parts(p, len, cap);\n        assert_eq!(rebuilt, [4, 5, 6]);\n    }\n}"]}},{"name":"pub fn capacity(&self) -> usize","details":{"description":["Returns the number of elements the vector can hold without reallocating."],"example":["let vec: Vec<i32> = Vec::with_capacity(10);\nassert_eq!(vec.capacity(), 10);"]}},{"name":"pub fn reserve(&mut self, additional: usize)","details":{"description":["Reserves capacity for at least additional more elements to be inserted in the given Vec<T>. The collection may reserve more space to avoid frequent reallocations. After calling reserve, capacity will be greater than or equal to self.len() + additional. Does nothing if capacity is already sufficient.","Panics","Panics if the new capacity overflows usize."],"example":["let mut vec = vec![1];\nvec.reserve(10);\nassert!(vec.capacity() >= 11);"]}},{"name":"pub fn reserve_exact(&mut self, additional: usize)","details":{"description":["Reserves the minimum capacity for exactly additional more elements to be inserted in the given Vec<T>. After calling reserve_exact, capacity will be greater than or equal to self.len() + additional. Does nothing if the capacity is already sufficient.","Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer reserve if future insertions are expected.","Panics","Panics if the new capacity overflows usize."],"example":["let mut vec = vec![1];\nvec.reserve_exact(10);\nassert!(vec.capacity() >= 11);"]}},{"name":"pub fn try_reserve( &mut self, additional: usize) -> Result<(), CollectionAllocErr>","stability":["ðŸ”¬ This is a nightly-only experimental API.  (try_reserve #48043)new API\n"]},{"name":"pub fn try_reserve_exact( &mut self, additional: usize) -> Result<(), CollectionAllocErr>","stability":["ðŸ”¬ This is a nightly-only experimental API.  (try_reserve #48043)new API\n"]},{"name":"pub fn shrink_to_fit(&mut self)","details":{"description":["Shrinks the capacity of the vector as much as possible.","It will drop down as close as possible to the length but the allocator may still inform the vector that there is space for a few more elements."],"example":["let mut vec = Vec::with_capacity(10);\nvec.extend([1, 2, 3].iter().cloned());\nassert_eq!(vec.capacity(), 10);\nvec.shrink_to_fit();\nassert!(vec.capacity() >= 3);"]}},{"name":"pub fn shrink_to(&mut self, min_capacity: usize)","stability":["ðŸ”¬ This is a nightly-only experimental API.  (shrink_to)new API\n"]},{"name":"pub fn into_boxed_slice(self) -> Box<[T]>","details":{"description":["Converts the vector into Box<[T]>.","Note that this will drop any excess capacity."],"example":["let v = vec![1, 2, 3];\n\nlet slice = v.into_boxed_slice();","Any excess capacity is removed:","let mut vec = Vec::with_capacity(10);\nvec.extend([1, 2, 3].iter().cloned());\n\nassert_eq!(vec.capacity(), 10);\nlet slice = vec.into_boxed_slice();\nassert_eq!(slice.into_vec().capacity(), 3);"]}},{"name":"pub fn truncate(&mut self, len: usize)","details":{"description":["Shortens the vector, keeping the first len elements and dropping the rest.","If len is greater than the vector's current length, this has no effect.","The drain method can emulate truncate, but causes the excess elements to be returned instead of dropped.","Note that this method has no effect on the allocated capacity of the vector."],"example":["Truncating a five element vector to two elements:","let mut vec = vec![1, 2, 3, 4, 5];\nvec.truncate(2);\nassert_eq!(vec, [1, 2]);","No truncation occurs when len is greater than the vector's current\nlength:","let mut vec = vec![1, 2, 3];\nvec.truncate(8);\nassert_eq!(vec, [1, 2, 3]);","Truncating when len == 0 is equivalent to calling the clear\nmethod.","let mut vec = vec![1, 2, 3];\nvec.truncate(0);\nassert_eq!(vec, []);"]}},{"name":"pub fn as_slice(&self) -> &[T]","details":{"description":["Extracts a slice containing the entire vector.","Equivalent to &s[..]."],"example":["use std::io::{self, Write};\nlet buffer = vec![1, 2, 3, 5, 8];\nio::sink().write(buffer.as_slice()).unwrap();"]}},{"name":"pub fn as_mut_slice(&mut self) -> &mut [T]","details":{"description":["Extracts a mutable slice of the entire vector.","Equivalent to &mut s[..]."],"example":["use std::io::{self, Read};\nlet mut buffer = vec![0; 3];\nio::repeat(0b101).read_exact(buffer.as_mut_slice()).unwrap();"]}},{"name":"pub unsafe fn set_len(&mut self, len: usize)","details":{"description":["Sets the length of a vector.","This will explicitly set the size of the vector, without actually modifying its buffers, so it is up to the caller to ensure that the vector is actually the specified size."],"example":["use std::ptr;\n\nlet mut vec = vec!['r', 'u', 's', 't'];\n\nunsafe {\n    ptr::drop_in_place(&mut vec[3]);\n    vec.set_len(3);\n}\nassert_eq!(vec, ['r', 'u', 's']);","In this example, there is a memory leak since the memory locations\nowned by the inner vectors were not freed prior to the set_len call:","let mut vec = vec![vec![1, 0, 0],\n                   vec![0, 1, 0],\n                   vec![0, 0, 1]];\nunsafe {\n    vec.set_len(0);\n}","In this example, the vector gets expanded from zero to four items\nwithout any memory allocations occurring, resulting in vector\nvalues of unallocated memory:","let mut vec: Vec<char> = Vec::new();\n\nunsafe {\n    vec.set_len(4);\n}"]}},{"name":"pub fn swap_remove(&mut self, index: usize) -> T","details":{"description":["Removes an element from the vector and returns it.","The removed element is replaced by the last element of the vector.","This does not preserve ordering, but is O(1).","Panics","Panics if index is out of bounds."],"example":["let mut v = vec![\"foo\", \"bar\", \"baz\", \"qux\"];\n\nassert_eq!(v.swap_remove(1), \"bar\");\nassert_eq!(v, [\"foo\", \"qux\", \"baz\"]);\n\nassert_eq!(v.swap_remove(0), \"foo\");\nassert_eq!(v, [\"baz\", \"qux\"]);"]}},{"name":"pub fn insert(&mut self, index: usize, element: T)","details":{"description":["Inserts an element at position index within the vector, shifting all elements after it to the right.","Panics","Panics if index > len."],"example":["let mut vec = vec![1, 2, 3];\nvec.insert(1, 4);\nassert_eq!(vec, [1, 4, 2, 3]);\nvec.insert(4, 5);\nassert_eq!(vec, [1, 4, 2, 3, 5]);"]}},{"name":"pub fn remove(&mut self, index: usize) -> T","details":{"description":["Removes and returns the element at position index within the vector, shifting all elements after it to the left.","Panics","Panics if index is out of bounds."],"example":["let mut v = vec![1, 2, 3];\nassert_eq!(v.remove(1), 2);\nassert_eq!(v, [1, 3]);"]}},{"name":"pub fn retain<F>(&mut self, f: F) where F: FnMut(&T) -> bool","details":{"description":["Retains only the elements specified by the predicate.","In other words, remove all elements e such that f(&e) returns false. This method operates in place and preserves the order of the retained elements."],"example":["let mut vec = vec![1, 2, 3, 4];\nvec.retain(|&x| x%2 == 0);\nassert_eq!(vec, [2, 4]);"]}},{"name":"pub fn dedup_by_key<F, K>(&mut self, key: F) where F: FnMut(&mut T) -> K, K: PartialEq<K>","details":{"description":["Removes all but the first of consecutive elements in the vector that resolve to the same key.","If the vector is sorted, this removes all duplicates."],"example":["let mut vec = vec![10, 20, 21, 30, 20];\n\nvec.dedup_by_key(|i| *i / 10);\n\nassert_eq!(vec, [10, 20, 30, 20]);"]}},{"name":"pub fn dedup_by<F>(&mut self, same_bucket: F) where F: FnMut(&mut T, &mut T) -> bool","details":{"description":["Removes all but the first of consecutive elements in the vector satisfying a given equality relation.","The same_bucket function is passed references to two elements from the vector, and returns true if the elements compare equal, or false if they do not. The elements are passed in opposite order from their order in the vector, so if same_bucket(a, b) returns true, a is removed.","If the vector is sorted, this removes all duplicates."],"example":["let mut vec = vec![\"foo\", \"bar\", \"Bar\", \"baz\", \"bar\"];\n\nvec.dedup_by(|a, b| a.eq_ignore_ascii_case(b));\n\nassert_eq!(vec, [\"foo\", \"bar\", \"baz\", \"bar\"]);"]}},{"name":"pub fn push(&mut self, value: T)","details":{"description":["Appends an element to the back of a collection.","Panics","Panics if the number of elements in the vector overflows a usize."],"example":["let mut vec = vec![1, 2];\nvec.push(3);\nassert_eq!(vec, [1, 2, 3]);"]}},{"name":"pub fn pop(&mut self) -> Option<T>","details":{"description":["Removes the last element from a vector and returns it, or None if it is empty."],"example":["let mut vec = vec![1, 2, 3];\nassert_eq!(vec.pop(), Some(3));\nassert_eq!(vec, [1, 2]);"]}},{"name":"pub fn append(&mut self, other: &mut Vec<T>)","details":{"description":["Moves all the elements of other into Self, leaving other empty.","Panics","Panics if the number of elements in the vector overflows a usize."],"example":["let mut vec = vec![1, 2, 3];\nlet mut vec2 = vec![4, 5, 6];\nvec.append(&mut vec2);\nassert_eq!(vec, [1, 2, 3, 4, 5, 6]);\nassert_eq!(vec2, []);"]}},{"name":"pub fn drain<R>(&mut self, range: R) -> Drain<T> where R: RangeBounds<usize>","details":{"description":["Creates a draining iterator that removes the specified range in the vector and yields the removed items.","Note 1: The element range is removed even if the iterator is only partially consumed or not consumed at all.","Note 2: It is unspecified how many elements are removed from the vector if the Drain value is leaked.","Panics","Panics if the starting point is greater than the end point or if the end point is greater than the length of the vector."],"example":["let mut v = vec![1, 2, 3];\nlet u: Vec<_> = v.drain(1..).collect();\nassert_eq!(v, &[1]);\nassert_eq!(u, &[2, 3]);\n\n// A full range clears the vector\nv.drain(..);\nassert_eq!(v, &[]);"]}},{"name":"pub fn clear(&mut self)","details":{"description":["Clears the vector, removing all values.","Note that this method has no effect on the allocated capacity of the vector."],"example":["let mut v = vec![1, 2, 3];\n\nv.clear();\n\nassert!(v.is_empty());"]}},{"name":"pub fn len(&self) -> usize","details":{"description":["Returns the number of elements in the vector, also referred to as its 'length'."],"example":["let a = vec![1, 2, 3];\nassert_eq!(a.len(), 3);"]}},{"name":"pub fn is_empty(&self) -> bool","details":{"description":["Returns true if the vector contains no elements."],"example":["let mut v = Vec::new();\nassert!(v.is_empty());\n\nv.push(1);\nassert!(!v.is_empty());"]}},{"name":"pub fn split_off(&mut self, at: usize) -> Vec<T>","details":{"description":["Splits the collection into two at the given index.","Returns a newly allocated Self. self contains elements [0, at), and the returned Self contains elements [at, len).","Note that the capacity of self does not change.","Panics","Panics if at > len."],"example":["let mut vec = vec![1,2,3];\nlet vec2 = vec.split_off(1);\nassert_eq!(vec, [1]);\nassert_eq!(vec2, [2, 3]);"]}},{"name":"pub fn resize_with<F>(&mut self, new_len: usize, f: F) where F: FnMut() -> T","stability":["ðŸ”¬ This is a nightly-only experimental API.  (vec_resize_with #41758)"]},{"name":"pub fn resize(&mut self, new_len: usize, value: T)","details":{"description":["Resizes the Vec in-place so that len is equal to new_len.","If new_len is greater than len, the Vec is extended by the difference, with each additional slot filled with value. If new_len is less than len, the Vec is simply truncated.","This method requires Clone to be able clone the passed value. If you need more flexibility (or want to rely on Default instead of Clone), use resize_with."],"example":["let mut vec = vec![\"hello\"];\nvec.resize(3, \"world\");\nassert_eq!(vec, [\"hello\", \"world\", \"world\"]);\n\nlet mut vec = vec![1, 2, 3, 4];\nvec.resize(2, 0);\nassert_eq!(vec, [1, 2]);"]}},{"name":"pub fn extend_from_slice(&mut self, other: &[T])","details":{"description":["Clones and appends all elements in a slice to the Vec.","Iterates over the slice other, clones each element, and then appends it to this Vec. The other vector is traversed in-order.","Note that this function is same as extend except that it is specialized to work with slices instead. If and when Rust gets specialization this function will likely be deprecated (but still available)."],"example":["let mut vec = vec![1];\nvec.extend_from_slice(&[2, 3, 4]);\nassert_eq!(vec, [1, 2, 3, 4]);"]}},{"name":"pub fn resize_default(&mut self, new_len: usize)","stability":["ðŸ”¬ This is a nightly-only experimental API.  (vec_resize_default #41758)"]},{"name":"pub fn dedup(&mut self)","details":{"description":["Removes consecutive repeated elements in the vector.","If the vector is sorted, this removes all duplicates."],"example":["let mut vec = vec![1, 2, 2, 3, 2];\n\nvec.dedup();\n\nassert_eq!(vec, [1, 2, 3, 2]);"]}},{"name":"pub fn remove_item(&mut self, item: &T) -> Option<T>","stability":["ðŸ”¬ This is a nightly-only experimental API.  (vec_remove_item #40062)recently added\n"]},{"name":"pub fn splice<R, I>( &mut self, range: R, replace_with: I) -> Splice<<I as IntoIterator>::IntoIter> where I: IntoIterator<Item = T>, R: RangeBounds<usize>","details":{"description":["Creates a splicing iterator that replaces the specified range in the vector with the given replace_with iterator and yields the removed items. replace_with does not need to be the same length as range.","Note 1: The element range is removed even if the iterator is not consumed until the end.","Note 2: It is unspecified how many elements are removed from the vector, if the Splice value is leaked.","Note 3: The input iterator replace_with is only consumed when the Splice value is dropped.","Note 4: This is optimal if:","The tail (elements in the vector after range) is empty, or replace_with yields fewer elements than rangeâ€™s length or the lower bound of its size_hint() is exact.","Otherwise, a temporary vector is allocated and the tail is moved twice.","Panics","Panics if the starting point is greater than the end point or if the end point is greater than the length of the vector."],"example":["let mut v = vec![1, 2, 3];\nlet new = [7, 8];\nlet u: Vec<_> = v.splice(..2, new.iter().cloned()).collect();\nassert_eq!(v, &[7, 8, 3]);\nassert_eq!(u, &[1, 2]);"]}},{"name":"pub fn drain_filter<F>(&mut self, filter: F) -> DrainFilter<T, F> where F: FnMut(&mut T) -> bool","stability":["ðŸ”¬ This is a nightly-only experimental API.  (drain_filter #43244)recently added\n"]}]}