{"stability":{"stable since":"1.0.0"},"apiName":"std::mem::uninitialized","apiType":"function","apiDocumentation":{"apiDescription":["Bypasses Rust's normal memory-initialization checks by pretending to produce a value of type T, while doing nothing at all.","This is incredibly dangerous and should not be done lightly. Deeply consider initializing your memory with a default value instead.","This is useful for FFI functions and initializing arrays sometimes, but should generally be avoided.","Undefined behavior","It is undefined behavior to read uninitialized memory, even just an uninitialized boolean. For instance, if you branch on the value of such a boolean, your program may take one, both, or neither of the branches.","Writing to the uninitialized value is similarly dangerous. Rust believes the value is initialized, and will therefore try to Drop the uninitialized value and its fields if you try to overwrite it in a normal manner. The only way to safely initialize an uninitialized value is with ptr::write, ptr::copy, or ptr::copy_nonoverlapping.","If the value does implement Drop, it must be initialized before it goes out of scope (and therefore would be dropped). Note that this includes a panic occurring and unwinding the stack suddenly."],"examples":["Here's how to safely initialize an array of Vecs.","use std::mem;\nuse std::ptr;\n\n// Only declare the array. This safely leaves it\n// uninitialized in a way that Rust will track for us.\n// However we can't initialize it element-by-element\n// safely, and we can't use the `[value; 1000]`\n// constructor because it only works with `Copy` data.\nlet mut data: [Vec<u32>; 1000];\n\nunsafe {\n    // So we need to do this to initialize it.\n    data = mem::uninitialized();\n\n    // DANGER ZONE: if anything panics or otherwise\n    // incorrectly reads the array here, we will have\n    // Undefined Behavior.\n\n    // It's ok to mutably iterate the data, since this\n    // doesn't involve reading it at all.\n    // (ptr and len are statically known for arrays)\n    for elem in &mut data[..] {\n        // *elem = Vec::new() would try to drop the\n        // uninitialized memory at `elem` -- bad!\n        //\n        // Vec::new doesn't allocate or do really\n        // anything. It's only safe to call here\n        // because we know it won't panic.\n        ptr::write(elem, Vec::new());\n    }\n\n    // SAFE ZONE: everything is initialized.\n}\n\nprintln!(\"{:?}\", &data[0]);","This example emphasizes exactly how delicate and dangerous using mem::uninitialized\ncan be. Note that the vec! macro does let you initialize every element with a\nvalue that is only Clone, so the following is semantically equivalent and\nvastly less dangerous, as long as you can live with an extra heap\nallocation:","let data: Vec<Vec<u32>> = vec![Vec::new(); 1000];\nprintln!(\"{:?}\", &data[0]);"]}}