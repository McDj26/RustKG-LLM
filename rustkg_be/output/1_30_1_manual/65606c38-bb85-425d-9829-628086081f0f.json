{"stability":{"stable since":"1.0.0"},"apiName":"std::rc","apiType":"module","apiDocumentation":{"apiDescription":["Single-threaded reference-counting pointers. 'Rc' stands for 'Reference Counted'.","The type Rc<T> provides shared ownership of a value of type T, allocated in the heap. Invoking clone on Rc produces a new pointer to the same value in the heap. When the last Rc pointer to a given value is destroyed, the pointed-to value is also destroyed.","Shared references in Rust disallow mutation by default, and Rc is no exception: you cannot generally obtain a mutable reference to something inside an Rc. If you need mutability, put a Cell or RefCell inside the Rc; see an example of mutability inside an Rc.","Rc uses non-atomic reference counting. This means that overhead is very low, but an Rc cannot be sent between threads, and consequently Rc does not implement Send. As a result, the Rust compiler will check at compile time that you are not sending Rcs between threads. If you need multi-threaded, atomic reference counting, use sync::Arc.","The downgrade method can be used to create a non-owning Weak pointer. A Weak pointer can be upgraded to an Rc, but this will return None if the value has already been dropped.","A cycle between Rc pointers will never be deallocated. For this reason, Weak is used to break cycles. For example, a tree could have strong Rc pointers from parent nodes to children, and Weak pointers from children back to their parents.","Rc<T> automatically dereferences to T (via the Deref trait), so you can call T's methods on a value of type Rc<T>. To avoid name clashes with T's methods, the methods of Rc<T> itself are associated functions, called using function-like syntax:","use std::rc::Rc; let my_rc = Rc::new(()); Rc::downgrade(&my_rc);","Weak<T> does not auto-dereference to T, because the value may have already been destroyed.","Cloning references","Creating a new reference from an existing reference counted pointer is done using the Clone trait implemented for Rc<T> and Weak<T>.","use std::rc::Rc; let foo = Rc::new(vec![1.0, 2.0, 3.0]); // The two syntaxes below are equivalent. let a = foo.clone(); let b = Rc::clone(&foo); // a and b both point to the same memory location as foo.","The Rc::clone(&from) syntax is the most idiomatic because it conveys more explicitly the meaning of the code. In the example above, this syntax makes it easier to see that this code is creating a new reference rather than copying the whole content of foo."],"examples":["Consider a scenario where a set of Gadgets are owned by a given Owner.\nWe want to have our Gadgets point to their Owner. We can't do this with\nunique ownership, because more than one gadget may belong to the same\nOwner. Rc allows us to share an Owner between multiple Gadgets,\nand have the Owner remain allocated as long as any Gadget points at it.","use std::rc::Rc;\n\nstruct Owner {\n    name: String,\n    // ...other fields\n}\n\nstruct Gadget {\n    id: i32,\n    owner: Rc<Owner>,\n    // ...other fields\n}\n\nfn main() {\n    // Create a reference-counted `Owner`.\n    let gadget_owner: Rc<Owner> = Rc::new(\n        Owner {\n            name: \"Gadget Man\".to_string(),\n        }\n    );\n\n    // Create `Gadget`s belonging to `gadget_owner`. Cloning the `Rc<Owner>`\n    // value gives us a new pointer to the same `Owner` value, incrementing\n    // the reference count in the process.\n    let gadget1 = Gadget {\n        id: 1,\n        owner: Rc::clone(&gadget_owner),\n    };\n    let gadget2 = Gadget {\n        id: 2,\n        owner: Rc::clone(&gadget_owner),\n    };\n\n    // Dispose of our local variable `gadget_owner`.\n    drop(gadget_owner);\n\n    // Despite dropping `gadget_owner`, we're still able to print out the name\n    // of the `Owner` of the `Gadget`s. This is because we've only dropped a\n    // single `Rc<Owner>`, not the `Owner` it points to. As long as there are\n    // other `Rc<Owner>` values pointing at the same `Owner`, it will remain\n    // allocated. The field projection `gadget1.owner.name` works because\n    // `Rc<Owner>` automatically dereferences to `Owner`.\n    println!(\"Gadget {} owned by {}\", gadget1.id, gadget1.owner.name);\n    println!(\"Gadget {} owned by {}\", gadget2.id, gadget2.owner.name);\n\n    // At the end of the function, `gadget1` and `gadget2` are destroyed, and\n    // with them the last counted references to our `Owner`. Gadget Man now\n    // gets destroyed as well.\n}","If our requirements change, and we also need to be able to traverse from\nOwner toÂ Gadget, we will run into problems. An Rc pointer from Owner\nto Gadget introduces a cycle between the values. This means that their\nreference counts can never reach 0, and the values will remain allocated\nforever: a memory leak. In order to get around this, we can use Weak\npointers.","Rust actually makes it somewhat difficult to produce this loop in the first\nplace. In order to end up with two values that point at each other, one of\nthem needs to be mutable. This is difficult because Rc enforces\nmemory safety by only giving out shared references to the value it wraps,\nand these don't allow direct mutation. We need to wrap the part of the\nvalue we wish to mutate in a RefCell, which provides interior\nmutability: a method to achieve mutability through a shared reference.\nRefCell enforces Rust's borrowing rules at runtime.","use std::rc::Rc;\nuse std::rc::Weak;\nuse std::cell::RefCell;\n\nstruct Owner {\n    name: String,\n    gadgets: RefCell<Vec<Weak<Gadget>>>,\n    // ...other fields\n}\n\nstruct Gadget {\n    id: i32,\n    owner: Rc<Owner>,\n    // ...other fields\n}\n\nfn main() {\n    // Create a reference-counted `Owner`. Note that we've put the `Owner`'s\n    // vector of `Gadget`s inside a `RefCell` so that we can mutate it through\n    // a shared reference.\n    let gadget_owner: Rc<Owner> = Rc::new(\n        Owner {\n            name: \"Gadget Man\".to_string(),\n            gadgets: RefCell::new(vec![]),\n        }\n    );\n\n    // Create `Gadget`s belonging to `gadget_owner`, as before.\n    let gadget1 = Rc::new(\n        Gadget {\n            id: 1,\n            owner: Rc::clone(&gadget_owner),\n        }\n    );\n    let gadget2 = Rc::new(\n        Gadget {\n            id: 2,\n            owner: Rc::clone(&gadget_owner),\n        }\n    );\n\n    // Add the `Gadget`s to their `Owner`.\n    {\n        let mut gadgets = gadget_owner.gadgets.borrow_mut();\n        gadgets.push(Rc::downgrade(&gadget1));\n        gadgets.push(Rc::downgrade(&gadget2));\n\n        // `RefCell` dynamic borrow ends here.\n    }\n\n    // Iterate over our `Gadget`s, printing their details out.\n    for gadget_weak in gadget_owner.gadgets.borrow().iter() {\n\n        // `gadget_weak` is a `Weak<Gadget>`. Since `Weak` pointers can't\n        // guarantee the value is still allocated, we need to call\n        // `upgrade`, which returns an `Option<Rc<Gadget>>`.\n        //\n        // In this case we know the value still exists, so we simply\n        // `unwrap` the `Option`. In a more complicated program, you might\n        // need graceful error handling for a `None` result.\n\n        let gadget = gadget_weak.upgrade().unwrap();\n        println!(\"Gadget {} owned by {}\", gadget.id, gadget.owner.name);\n    }\n\n    // At the end of the function, `gadget_owner`, `gadget1`, and `gadget2`\n    // are destroyed. There are now no strong (`Rc`) pointers to the\n    // gadgets, so they are destroyed. This zeroes the reference count on\n    // Gadget Man, so he gets destroyed as well.\n}"]},"children":["std::rc::Rc","std::rc::Weak"]}