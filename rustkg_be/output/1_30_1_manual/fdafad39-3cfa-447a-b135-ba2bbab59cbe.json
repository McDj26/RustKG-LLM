{"stability":{"stable since":"1.17.0"},"apiName":"std::ptr::read_unaligned","apiType":"function","apiDocumentation":{"apiDescription":["Reads the value from src without moving it. This leaves the memory in src unchanged.","Unlike read, the pointer may be unaligned.","Safety","Beyond accepting a raw pointer, this is unsafe because it semantically moves the value out of src without preventing further usage of src. If T is not Copy, then care must be taken to ensure that the value at src is not used before the data is overwritten again (e.g. with write, write_bytes, or copy). Note that *src = foo counts as a use because it will attempt to drop the value previously at *src."],"examples":["Basic usage:","let x = 12;\nlet y = &x as *const i32;\n\nunsafe {\n    assert_eq!(std::ptr::read_unaligned(y), 12);\n}"]}}