{"stability":{"stable since":"1.25.0"},"apiName":"std::ptr::NonNull","apiType":"struct","apiDocumentation":{"apiDescription":["*mut T but non-zero and covariant.","This is often the correct thing to use when building data structures using raw pointers, but is ultimately more dangerous to use because of its additional properties. If you're not sure if you should use NonNull<T>, just use *mut T!","Unlike *mut T, the pointer must always be non-null, even if the pointer is never dereferenced. This is so that enums may use this forbidden value as a discriminant -- Option<NonNull<T>> has the same size as *mut T. However the pointer may still dangle if it isn't dereferenced.","Unlike *mut T, NonNull<T> is covariant over T. If this is incorrect for your use case, you should include some PhantomData in your type to provide invariance, such as PhantomData<Cell<T>> or PhantomData<&'a mut T>. Usually this won't be necessary; covariance is correct for most safe abstractions, such as Box, Rc, Arc, Vec, and LinkedList. This is the case because they provide a public API that follows the normal shared XOR mutable rules of Rust."]},"trait implementations":[{"name":"impl<T> std::hash::Hash for std::ptr::NonNull<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::clone::Clone for std::ptr::NonNull<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::cmp::PartialOrd<std::ptr::NonNull<T>> for std::ptr::NonNull<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::cmp::Ord for std::ptr::NonNull<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::fmt::Pointer for std::ptr::NonNull<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::fmt::Debug for std::ptr::NonNull<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::cmp::Eq for std::ptr::NonNull<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T, U> std::ops::CoerceUnsized<std::ptr::NonNull<U>> for std::ptr::NonNull<T> where T: std::marker::Unsize<U> + ?std::marker::Sized, U: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::cmp::PartialEq<std::ptr::NonNull<T>> for std::ptr::NonNull<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<'a, T> std::convert::From<&'a T> for std::ptr::NonNull<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::convert::From<Unique<T>> for std::ptr::NonNull<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<'a, T> std::convert::From<&'a mut T> for std::ptr::NonNull<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::marker::Copy for std::ptr::NonNull<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> !std::marker::Sync for std::ptr::NonNull<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> !std::marker::Send for std::ptr::NonNull<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T: std::panic::RefUnwindSafe + ?std::marker::Sized> std::panic::UnwindSafe for std::ptr::NonNull<T>","stable since":"1.0.0"}],"methods":[{"name":"pub fn dangling() -> NonNull<T>","details":{"description":["Creates a new NonNull that is dangling, but well-aligned.","This is useful for initializing types which lazily allocate, like Vec::new does.","Note that the pointer value may potentially represent a valid pointer to a T, which means this must not be used as a \"not yet initialized\" sentinel value. Types that lazily allocate must track initialization by some other means."]}},{"name":"pub const unsafe fn new_unchecked(ptr: *mut T) -> NonNull<T>","details":{"description":["Creates a new NonNull.","Safety","ptr must be non-null."]}},{"name":"pub fn new(ptr: *mut T) -> Option<NonNull<T>>","details":{"description":["Creates a new NonNull if ptr is non-null."]}},{"name":"pub fn as_ptr(self) -> *mut T","details":{"description":["Acquires the underlying *mut pointer."]}},{"name":"pub unsafe fn as_ref(&self) -> &T","details":{"description":["Dereferences the content.","The resulting lifetime is bound to self so this behaves \"as if\" it were actually an instance of T that is getting borrowed. If a longer (unbound) lifetime is needed, use &*my_ptr.as_ptr()."]}},{"name":"pub unsafe fn as_mut(&mut self) -> &mut T","details":{"description":["Mutably dereferences the content.","The resulting lifetime is bound to self so this behaves \"as if\" it were actually an instance of T that is getting borrowed. If a longer (unbound) lifetime is needed, use &mut *my_ptr.as_ptr()."]}},{"name":"pub fn cast<U>(self) -> NonNull<U>","details":{"description":["Cast to a pointer of another type"]}}]}