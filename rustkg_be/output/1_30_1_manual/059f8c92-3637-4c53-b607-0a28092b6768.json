{"stability":{"stable since":"1.0.0"},"apiName":"std::ops","apiType":"module","apiDocumentation":{"apiDescription":["Overloadable operators.","Implementing these traits allows you to overload certain operators.","Some of these traits are imported by the prelude, so they are available in every Rust program. Only operators backed by traits can be overloaded. For example, the addition operator (+) can be overloaded through the Add trait, but since the assignment operator (=) has no backing trait, there is no way of overloading its semantics. Additionally, this module does not provide any mechanism to create new operators. If traitless overloading or custom operators are required, you should look toward macros or compiler plugins to extend Rust's syntax.","Implementations of operator traits should be unsurprising in their respective contexts, keeping in mind their usual meanings and operator precedence. For example, when implementing Mul, the operation should have some resemblance to multiplication (and share expected properties like associativity).","Note that the && and || operators short-circuit, i.e. they only evaluate their second operand if it contributes to the result. Since this behavior is not enforceable by traits, && and || are not supported as overloadable operators.","Many of the operators take their operands by value. In non-generic contexts involving built-in types, this is usually not a problem. However, using these operators in generic code, requires some attention if values have to be reused as opposed to letting the operators consume them. One option is to occasionally use clone. Another option is to rely on the types involved providing additional operator implementations for references. For example, for a user-defined type T which is supposed to support addition, it is probably a good idea to have both T and &T implement the traits Add<T> and Add<&T> so that generic code can be written without unnecessary cloning."],"examples":["This example creates a Point struct that implements Add and Sub,\nand then demonstrates adding and subtracting two Points.","use std::ops::{Add, Sub};\n\n#[derive(Debug, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Add for Point {\n    type Output = Point;\n\n    fn add(self, other: Point) -> Point {\n        Point {x: self.x + other.x, y: self.y + other.y}\n    }\n}\n\nimpl Sub for Point {\n    type Output = Point;\n\n    fn sub(self, other: Point) -> Point {\n        Point {x: self.x - other.x, y: self.y - other.y}\n    }\n}\n\nassert_eq!(Point {x: 3, y: 3}, Point {x: 1, y: 0} + Point {x: 2, y: 3});\nassert_eq!(Point {x: -1, y: -3}, Point {x: 1, y: 0} - Point {x: 2, y: 3});","See the documentation for each trait for an example implementation.","The Fn, FnMut, and FnOnce traits are implemented by types that can be\ninvoked like functions. Note that Fn takes &self, FnMut takes &mut self and FnOnce takes self. These correspond to the three kinds of\nmethods that can be invoked on an instance: call-by-reference,\ncall-by-mutable-reference, and call-by-value. The most common use of these\ntraits is to act as bounds to higher-level functions that take functions or\nclosures as arguments.","Taking a Fn as a parameter:","fn call_with_one<F>(func: F) -> usize\n    where F: Fn(usize) -> usize\n{\n    func(1)\n}\n\nlet double = |x| x * 2;\nassert_eq!(call_with_one(double), 2);","Taking a FnMut as a parameter:","fn do_twice<F>(mut func: F)\n    where F: FnMut()\n{\n    func();\n    func();\n}\n\nlet mut x: usize = 1;\n{\n    let add_two_to_x = || x += 2;\n    do_twice(add_two_to_x);\n}\n\nassert_eq!(x, 5);","Taking a FnOnce as a parameter:","fn consume_with_relish<F>(func: F)\n    where F: FnOnce() -> String\n{\n    // `func` consumes its captured variables, so it cannot be run more\n    // than once\n    println!(\"Consumed: {}\", func());\n\n    println!(\"Delicious!\");\n\n    // Attempting to invoke `func()` again will throw a `use of moved\n    // value` error for `func`\n}\n\nlet x = String::from(\"x\");\nlet consume_and_return_x = move || x;\nconsume_with_relish(consume_and_return_x);\n\n// `consume_and_return_x` can no longer be invoked at this point"]},"children":["std::ops::Range","std::ops::RangeFrom","std::ops::RangeFull","std::ops::RangeInclusive","std::ops::RangeTo","std::ops::RangeToInclusive","std::ops::Bound","std::ops::GeneratorState","std::ops::Add","std::ops::AddAssign","std::ops::BitAnd","std::ops::BitAndAssign","std::ops::BitOr","std::ops::BitOrAssign","std::ops::BitXor","std::ops::BitXorAssign","std::ops::Deref","std::ops::DerefMut","std::ops::Div","std::ops::DivAssign","std::ops::Drop","std::ops::Fn","std::ops::FnMut","std::ops::FnOnce","std::ops::Index","std::ops::IndexMut","std::ops::Mul","std::ops::MulAssign","std::ops::Neg","std::ops::Not","std::ops::RangeBounds","std::ops::Rem","std::ops::RemAssign","std::ops::Shl","std::ops::ShlAssign","std::ops::Shr","std::ops::ShrAssign","std::ops::Sub","std::ops::SubAssign","std::ops::CoerceUnsized","std::ops::Generator","std::ops::Try"]}