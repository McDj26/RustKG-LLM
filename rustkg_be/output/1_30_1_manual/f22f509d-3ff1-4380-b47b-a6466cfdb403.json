{"stability":{"stable since":"1.0.0"},"apiName":"std::boxed","apiType":"module","apiDocumentation":{"apiDescription":["A pointer type for heap allocation.","Box<T>, casually referred to as a 'box', provides the simplest form of heap allocation in Rust. Boxes provide ownership for this allocation, and drop their contents when they go out of scope."],"examples":["Creating a box:","let x = Box::new(5);","Creating a recursive data structure:","#[derive(Debug)]\nenum List<T> {\n    Cons(T, Box<List<T>>),\n    Nil,\n}\n\nfn main() {\n    let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));\n    println!(\"{:?}\", list);\n}","This will print Cons(1, Cons(2, Nil)).","Recursive structures must be boxed, because if the definition of Cons\nlooked like this:","â“˜This example deliberately fails to compile","Cons(T, List<T>),","It wouldn't work. This is because the size of a List depends on how many\nelements are in the list, and so we don't know how much memory to allocate\nfor a Cons. By introducing a Box, which has a defined size, we know how\nbig Cons needs to be."]},"children":["std::boxed::Box","std::boxed::FnBox"]}