{"stability":{"stable since":"1.0.0"},"apiName":"std::option","apiType":"module","apiDocumentation":{"apiDescription":["Optional values.","Type Option represents an optional value: every Option is either Some and contains a value, or None, and does not. Option types are very common in Rust code, as they have a number of uses:","Initial values Return values for functions that are not defined over their entire input range (partial functions) Return value for otherwise reporting simple errors, where None is returned on error Optional struct fields Struct fields that can be loaned or \"taken\" Optional function arguments Nullable pointers Swapping things out of difficult situations","Options are commonly paired with pattern matching to query the presence of a value and take action, always accounting for the None case.","fn divide(numerator: f64, denominator: f64) -> Option<f64> { if denominator == 0.0 { None } else { Some(numerator / denominator) } } // The return value of the function is an option let result = divide(2.0, 3.0); // Pattern match to retrieve the value match result { // The division was valid Some(x) => println!(\"Result: {}\", x), // The division was invalid None => println!(\"Cannot divide by 0\"), }","Options and pointers (\"nullable\" pointers)","Rust's pointer types must always point to a valid location; there are no \"null\" pointers. Instead, Rust has optional pointers, like the optional owned box, Option<Box<T>>.","The following example uses Option to create an optional box of i32. Notice that in order to use the inner i32 value first, the check_optional function needs to use pattern matching to determine whether the box has a value (i.e. it is Some(...)) or not (None).","let optional = None; check_optional(optional); let optional = Some(Box::new(9000)); check_optional(optional); fn check_optional(optional: Option<Box<i32>>) { match optional { Some(ref p) => println!(\"has value {}\", p), None => println!(\"has no value\"), } }","This usage of Option to create safe nullable pointers is so common that Rust does special optimizations to make the representation of Option<Box<T>> a single pointer. Optional pointers in Rust are stored as efficiently as any other pointer type."],"examples":["Basic pattern matching on Option:","let msg = Some(\"howdy\");\n\n// Take a reference to the contained string\nif let Some(ref m) = msg {\n    println!(\"{}\", *m);\n}\n\n// Remove the contained string, destroying the Option\nlet unwrapped_msg = msg.unwrap_or(\"default message\");","Initialize a result to None before a loop:","enum Kingdom { Plant(u32, &'static str), Animal(u32, &'static str) }\n\n// A list of data to search through.\nlet all_the_big_things = [\n    Kingdom::Plant(250, \"redwood\"),\n    Kingdom::Plant(230, \"noble fir\"),\n    Kingdom::Plant(229, \"sugar pine\"),\n    Kingdom::Animal(25, \"blue whale\"),\n    Kingdom::Animal(19, \"fin whale\"),\n    Kingdom::Animal(15, \"north pacific right whale\"),\n];\n\n// We're going to search for the name of the biggest animal,\n// but to start with we've just got `None`.\nlet mut name_of_biggest_animal = None;\nlet mut size_of_biggest_animal = 0;\nfor big_thing in &all_the_big_things {\n    match *big_thing {\n        Kingdom::Animal(size, name) if size > size_of_biggest_animal => {\n            // Now we've found the name of some big animal\n            size_of_biggest_animal = size;\n            name_of_biggest_animal = Some(name);\n        }\n        Kingdom::Animal(..) | Kingdom::Plant(..) => ()\n    }\n}\n\nmatch name_of_biggest_animal {\n    Some(name) => println!(\"the biggest animal is {}\", name),\n    None => println!(\"there are no animals :(\"),\n}"]},"children":["std::option::IntoIter","std::option::Iter","std::option::IterMut","std::option::NoneError","std::option::Option"]}