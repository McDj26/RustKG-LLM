{"stability":{"stable since":"1.17.0"},"apiName":"std::process::abort","apiType":"function","apiDocumentation":{"apiDescription":["Terminates the process in an abnormal fashion.","The function will never return and will immediately terminate the current process in a platform specific \"abnormal\" manner.","Note that because this function never returns, and that it terminates the process, no destructors on the current stack or any other thread's stack will be run.","This is in contrast to the default behaviour of panic! which unwinds the current thread's stack and calls all destructors. When panic=\"abort\" is set, either as an argument to rustc or in a crate's Cargo.toml, panic! and abort are similar. However, panic! will still call the panic hook while abort will not.","If a clean shutdown is needed it is recommended to only call this function at a known point where there are no more destructors left to run."],"examples":["use std::process;\n\nfn main() {\n    println!(\"aborting\");\n\n    process::abort();\n\n    // execution never gets here\n}","The abort function terminates the process, so the destructor will not\nget run on the example below:","use std::process;\n\nstruct HasDrop;\n\nimpl Drop for HasDrop {\n    fn drop(&mut self) {\n        println!(\"This will never be printed!\");\n    }\n}\n\nfn main() {\n    let _x = HasDrop;\n    process::abort();\n    // the destructor implemented for HasDrop will never get run\n}"]}}