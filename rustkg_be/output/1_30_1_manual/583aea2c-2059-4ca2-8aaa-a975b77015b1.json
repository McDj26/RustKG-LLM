{"stability":{"stable since":"1.0.0"},"apiName":"std::sync::mpsc","apiType":"module","apiDocumentation":{"apiDescription":["Multi-producer, single-consumer FIFO queue communication primitives.","This module provides message-based communication over channels, concretely defined among three types:","Sender SyncSender Receiver","A Sender or SyncSender is used to send data to a Receiver. Both senders are clone-able (multi-producer) such that many threads can send simultaneously to one receiver (single-consumer).","These channels come in two flavors:","An asynchronous, infinitely buffered channel. The channel function will return a (Sender, Receiver) tuple where all sends will be asynchronous (they never block). The channel conceptually has an infinite buffer. A synchronous, bounded channel. The sync_channel function will return a (SyncSender, Receiver) tuple where the storage for pending messages is a pre-allocated buffer of a fixed size. All sends will be synchronous by blocking until there is buffer space available. Note that a bound of 0 is allowed, causing the channel to become a \"rendezvous\" channel where each sender atomically hands off a message to a receiver.","Disconnection","The send and receive operations on channels will all return a Result indicating whether the operation succeeded or not. An unsuccessful operation is normally indicative of the other half of a channel having \"hung up\" by being dropped in its corresponding thread.","Once half of a channel has been deallocated, most operations can no longer continue to make progress, so Err will be returned. Many applications will continue to unwrap the results returned from this module, instigating a propagation of failure among threads if one unexpectedly dies."],"examples":["Simple usage:","use std::thread;\nuse std::sync::mpsc::channel;\n\n// Create a simple streaming channel\nlet (tx, rx) = channel();\nthread::spawn(move|| {\n    tx.send(10).unwrap();\n});\nassert_eq!(rx.recv().unwrap(), 10);","Shared usage:","use std::thread;\nuse std::sync::mpsc::channel;\n\n// Create a shared channel that can be sent along from many threads\n// where tx is the sending half (tx for transmission), and rx is the receiving\n// half (rx for receiving).\nlet (tx, rx) = channel();\nfor i in 0..10 {\n    let tx = tx.clone();\n    thread::spawn(move|| {\n        tx.send(i).unwrap();\n    });\n}\n\nfor _ in 0..10 {\n    let j = rx.recv().unwrap();\n    assert!(0 <= j && j < 10);\n}","Propagating panics:","use std::sync::mpsc::channel;\n\n// The call to recv() will return an error because the channel has already\n// hung up (or been deallocated)\nlet (tx, rx) = channel::<i32>();\ndrop(tx);\nassert!(rx.recv().is_err());","Synchronous channels:","use std::thread;\nuse std::sync::mpsc::sync_channel;\n\nlet (tx, rx) = sync_channel::<i32>(0);\nthread::spawn(move|| {\n    // This will wait for the parent thread to start receiving\n    tx.send(53).unwrap();\n});\nrx.recv().unwrap();"]},"children":["std::sync::mpsc::IntoIter","std::sync::mpsc::Iter","std::sync::mpsc::Receiver","std::sync::mpsc::RecvError","std::sync::mpsc::SendError","std::sync::mpsc::Sender","std::sync::mpsc::SyncSender","std::sync::mpsc::TryIter","std::sync::mpsc::Handle","std::sync::mpsc::Select","std::sync::mpsc::RecvTimeoutError","std::sync::mpsc::TryRecvError","std::sync::mpsc::TrySendError","std::sync::mpsc::channel","std::sync::mpsc::sync_channel"]}