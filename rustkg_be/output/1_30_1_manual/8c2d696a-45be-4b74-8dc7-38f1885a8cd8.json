{"stability":{"stable since":"1.0.0"},"apiName":"std::io::Stdin","apiType":"struct","apiDocumentation":{"apiDescription":["A handle to the standard input stream of a process.","Each handle is a shared reference to a global buffer of input data to this process. A handle can be lock'd to gain full access to BufRead methods (e.g. .lines()). Reads to this handle are otherwise locked with respect to other reads.","This handle implements the Read trait, but beware that concurrent reads of Stdin must be executed with care.","Created by the io::stdin method."]},"trait implementations":[{"name":"impl std::fmt::Debug for std::io::Stdin","stable since":"1.16.0"},{"name":"impl std::io::Read for std::io::Stdin","stable since":"1.0.0"},{"name":"impl std::os::windows::io::AsRawHandle for std::io::Stdin","stable since":"1.21.0"},{"name":"impl std::os::unix::io::AsRawFd for std::io::Stdin","stable since":"1.21.0"},{"name":"impl std::marker::Send for std::io::Stdin","stable since":"1.0.0"},{"name":"impl std::marker::Sync for std::io::Stdin","stable since":"1.0.0"}],"methods":[{"name":"pub fn lock(&self) -> StdinLock","details":{"description":["Locks this handle to the standard input stream, returning a readable guard.","The lock is released when the returned lock goes out of scope. The returned guard also implements the Read and BufRead traits for accessing the underlying data."],"example":["use std::io::{self, Read};\n\nfn main() -> io::Result<()> {\n    let mut buffer = String::new();\n    let stdin = io::stdin();\n    let mut handle = stdin.lock();\n\n    handle.read_to_string(&mut buffer)?;\n    Ok(())\n}"]}},{"name":"pub fn read_line(&self, buf: &mut String) -> Result<usize>","details":{"description":["Locks this handle and reads a line of input into the specified buffer.","For detailed semantics of this method, see the documentation on BufRead::read_line."],"example":["use std::io;\n\nlet mut input = String::new();\nmatch io::stdin().read_line(&mut input) {\n    Ok(n) => {\n        println!(\"{} bytes read\", n);\n        println!(\"{}\", input);\n    }\n    Err(error) => println!(\"error: {}\", error),\n}","You can run the example one of two ways:","\nPipe some text to it, e.g. printf foo | path/to/executable\nGive it text interactively by running the executable directly,\nin which case it will wait for the Enter key to be pressed before\ncontinuing\n"]}}]}