{"stability":{"stable since":"1.0.0"},"apiName":"std::collections::hash_map::HashMap","apiType":"struct","apiDocumentation":{"apiDescription":["A hash map implemented with linear probing and Robin Hood bucket stealing.","By default, HashMap uses a hashing algorithm selected to provide resistance against HashDoS attacks. The algorithm is randomly seeded, and a reasonable best-effort is made to generate this seed from a high quality, secure source of randomness provided by the host without blocking the program. Because of this, the randomness of the seed depends on the output quality of the system's random number generator when the seed is created. In particular, seeds generated when the system's entropy pool is abnormally low such as during system boot may be of a lower quality.","The default hashing algorithm is currently SipHash 1-3, though this is subject to change at any point in the future. While its performance is very competitive for medium sized keys, other hashing algorithms will outperform it for small keys such as integers as well as large keys such as long strings, though those algorithms will typically not protect against attacks such as HashDoS.","The hashing algorithm can be replaced on a per-HashMap basis using the default, with_hasher, and with_capacity_and_hasher methods. Many alternative algorithms are available on crates.io, such as the fnv crate.","It is required that the keys implement the Eq and Hash traits, although this can frequently be achieved by using #[derive(PartialEq, Eq, Hash)]. If you implement these yourself, it is important that the following property holds:","k1 == k2 -> hash(k1) == hash(k2)","In other words, if two keys are equal, their hashes must be equal.","It is a logic error for a key to be modified in such a way that the key's hash, as determined by the Hash trait, or its equality, as determined by the Eq trait, changes while it is in the map. This is normally only possible through Cell, RefCell, global state, I/O, or unsafe code.","Relevant papers/articles:","Pedro Celis. \"Robin Hood Hashing\" Emmanuel Goossaert. \"Robin Hood hashing\" Emmanuel Goossaert. \"Robin Hood hashing: backward shift deletion\""],"examples":["use std::collections::HashMap;\n\n// Type inference lets us omit an explicit type signature (which\n// would be `HashMap<String, String>` in this example).\nlet mut book_reviews = HashMap::new();\n\n// Review some books.\nbook_reviews.insert(\n    \"Adventures of Huckleberry Finn\".to_string(),\n    \"My favorite book.\".to_string(),\n);\nbook_reviews.insert(\n    \"Grimms' Fairy Tales\".to_string(),\n    \"Masterpiece.\".to_string(),\n);\nbook_reviews.insert(\n    \"Pride and Prejudice\".to_string(),\n    \"Very enjoyable.\".to_string(),\n);\nbook_reviews.insert(\n    \"The Adventures of Sherlock Holmes\".to_string(),\n    \"Eye lyked it alot.\".to_string(),\n);\n\n// Check for a specific one.\n// When collections store owned values (String), they can still be\n// queried using references (&str).\nif !book_reviews.contains_key(\"Les Misérables\") {\n    println!(\"We've got {} reviews, but Les Misérables ain't one.\",\n             book_reviews.len());\n}\n\n// oops, this review has a lot of spelling mistakes, let's delete it.\nbook_reviews.remove(\"The Adventures of Sherlock Holmes\");\n\n// Look up the values associated with some keys.\nlet to_find = [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"];\nfor &book in &to_find {\n    match book_reviews.get(book) {\n        Some(review) => println!(\"{}: {}\", book, review),\n        None => println!(\"{} is unreviewed.\", book)\n    }\n}\n\n// Iterate over everything.\nfor (book, review) in &book_reviews {\n    println!(\"{}: \\\"{}\\\"\", book, review);\n}","HashMap also implements an Entry API, which allows\nfor more complex methods of getting, setting, updating and removing keys and\ntheir values:","use std::collections::HashMap;\n\n// type inference lets us omit an explicit type signature (which\n// would be `HashMap<&str, u8>` in this example).\nlet mut player_stats = HashMap::new();\n\nfn random_stat_buff() -> u8 {\n    // could actually return some random value here - let's just return\n    // some fixed value for now\n    42\n}\n\n// insert a key only if it doesn't already exist\nplayer_stats.entry(\"health\").or_insert(100);\n\n// insert a key using a function that provides a new value only if it\n// doesn't already exist\nplayer_stats.entry(\"defence\").or_insert_with(random_stat_buff);\n\n// update a key, guarding against the key possibly not being set\nlet stat = player_stats.entry(\"attack\").or_insert(100);\n*stat += random_stat_buff();","The easiest way to use HashMap with a custom type as key is to derive Eq and Hash.\nWe must also derive PartialEq.","use std::collections::HashMap;\n\n#[derive(Hash, Eq, PartialEq, Debug)]\nstruct Viking {\n    name: String,\n    country: String,\n}\n\nimpl Viking {\n    /// Create a new Viking.\n    fn new(name: &str, country: &str) -> Viking {\n        Viking { name: name.to_string(), country: country.to_string() }\n    }\n}\n\n// Use a HashMap to store the vikings' health points.\nlet mut vikings = HashMap::new();\n\nvikings.insert(Viking::new(\"Einar\", \"Norway\"), 25);\nvikings.insert(Viking::new(\"Olaf\", \"Denmark\"), 24);\nvikings.insert(Viking::new(\"Harald\", \"Iceland\"), 12);\n\n// Use derived implementation to print the status of the vikings.\nfor (viking, health) in &vikings {\n    println!(\"{:?} has {} hp\", viking, health);\n}","A HashMap with fixed list of elements can be initialized from an array:","use std::collections::HashMap;\n\nfn main() {\n    let timber_resources: HashMap<&str, i32> =\n    [(\"Norway\", 100),\n     (\"Denmark\", 50),\n     (\"Iceland\", 10)]\n     .iter().cloned().collect();\n    // use the values stored in map\n}"]},"trait implementations":[{"name":"impl<K: std::clone::Clone, V: std::clone::Clone, S: std::clone::Clone> std::clone::Clone for std::collections::HashMap<K, V, S>","stable since":"1.0.0"},{"name":"impl<K, V, S> std::cmp::PartialEq for std::collections::HashMap<K, V, S> where K: std::cmp::Eq + std::hash::Hash, V: std::cmp::PartialEq, S: std::hash::BuildHasher","stable since":"1.0.0"},{"name":"impl<K, V, S> std::cmp::Eq for std::collections::HashMap<K, V, S> where K: std::cmp::Eq + std::hash::Hash, V: std::cmp::Eq, S: std::hash::BuildHasher","stable since":"1.0.0"},{"name":"impl<K, V, S> std::fmt::Debug for std::collections::HashMap<K, V, S> where K: std::cmp::Eq + std::hash::Hash + std::fmt::Debug, V: std::fmt::Debug, S: std::hash::BuildHasher","stable since":"1.0.0"},{"name":"impl<K, V, S> std::default::Default for std::collections::HashMap<K, V, S> where K: std::cmp::Eq + std::hash::Hash, S: std::hash::BuildHasher + std::default::Default","stable since":"1.0.0"},{"name":"impl<'a, K, Q: ?std::marker::Sized, V, S> std::ops::Index<&'a Q> for std::collections::HashMap<K, V, S> where K: std::cmp::Eq + std::hash::Hash + std::borrow::Borrow<Q>, Q: std::cmp::Eq + std::hash::Hash, S: std::hash::BuildHasher","stable since":"1.0.0"},{"name":"impl<'a, K, V, S> std::iter::IntoIterator for &'a std::collections::HashMap<K, V, S> where K: std::cmp::Eq + std::hash::Hash, S: std::hash::BuildHasher","stable since":"1.0.0"},{"name":"impl<'a, K, V, S> std::iter::IntoIterator for &'a mut std::collections::HashMap<K, V, S> where K: std::cmp::Eq + std::hash::Hash, S: std::hash::BuildHasher","stable since":"1.0.0"},{"name":"impl<K, V, S> std::iter::IntoIterator for std::collections::HashMap<K, V, S> where K: std::cmp::Eq + std::hash::Hash, S: std::hash::BuildHasher","stable since":"1.0.0"},{"name":"impl<K, V, S> std::iter::FromIterator<(K, V)> for std::collections::HashMap<K, V, S> where K: std::cmp::Eq + std::hash::Hash, S: std::hash::BuildHasher + std::default::Default","stable since":"1.0.0"},{"name":"impl<K, V, S> std::iter::Extend<(K, V)> for std::collections::HashMap<K, V, S> where K: std::cmp::Eq + std::hash::Hash, S: std::hash::BuildHasher","stable since":"1.0.0"},{"name":"impl<'a, K, V, S> std::iter::Extend<(&'a K, &'a V)> for std::collections::HashMap<K, V, S> where K: std::cmp::Eq + std::hash::Hash + std::marker::Copy, V: std::marker::Copy, S: std::hash::BuildHasher","stable since":"1.4.0"},{"name":"impl<K, V, S> std::marker::Send for std::collections::HashMap<K, V, S> where K: std::marker::Send, S: std::marker::Send, V: std::marker::Send","stable since":"1.0.0"},{"name":"impl<K, V, S> std::marker::Sync for std::collections::HashMap<K, V, S> where K: std::marker::Sync, S: std::marker::Sync, V: std::marker::Sync","stable since":"1.0.0"}],"methods":[{"name":"pub fn new() -> HashMap<K, V, RandomState>","details":{"description":["Creates an empty HashMap.","The hash map is initially created with a capacity of 0, so it will not allocate until it is first inserted into."],"example":["use std::collections::HashMap;\nlet mut map: HashMap<&str, i32> = HashMap::new();"]}},{"name":"pub fn with_capacity(capacity: usize) -> HashMap<K, V, RandomState>","details":{"description":["Creates an empty HashMap with the specified capacity.","The hash map will be able to hold at least capacity elements without reallocating. If capacity is 0, the hash map will not allocate."],"example":["use std::collections::HashMap;\nlet mut map: HashMap<&str, i32> = HashMap::with_capacity(10);"]}},{"name":"pub fn with_hasher(hash_builder: S) -> HashMap<K, V, S>","details":{"description":["Creates an empty HashMap which will use the given hash builder to hash keys.","The created map has the default initial capacity.","Warning: hash_builder is normally randomly generated, and is designed to allow HashMaps to be resistant to attacks that cause many collisions and very poor performance. Setting it manually using this function can expose a DoS attack vector."],"example":["use std::collections::HashMap;\nuse std::collections::hash_map::RandomState;\n\nlet s = RandomState::new();\nlet mut map = HashMap::with_hasher(s);\nmap.insert(1, 2);"]}},{"name":"pub fn with_capacity_and_hasher( capacity: usize, hash_builder: S) -> HashMap<K, V, S>","details":{"description":["Creates an empty HashMap with the specified capacity, using hash_builder to hash the keys.","The hash map will be able to hold at least capacity elements without reallocating. If capacity is 0, the hash map will not allocate.","Warning: hash_builder is normally randomly generated, and is designed to allow HashMaps to be resistant to attacks that cause many collisions and very poor performance. Setting it manually using this function can expose a DoS attack vector."],"example":["use std::collections::HashMap;\nuse std::collections::hash_map::RandomState;\n\nlet s = RandomState::new();\nlet mut map = HashMap::with_capacity_and_hasher(10, s);\nmap.insert(1, 2);"]}},{"name":"pub fn hasher(&self) -> &S","details":{"description":["Returns a reference to the map's BuildHasher."],"example":["use std::collections::HashMap;\nuse std::collections::hash_map::RandomState;\n\nlet hasher = RandomState::new();\nlet map: HashMap<i32, i32> = HashMap::with_hasher(hasher);\nlet hasher: &RandomState = map.hasher();"]}},{"name":"pub fn capacity(&self) -> usize","details":{"description":["Returns the number of elements the map can hold without reallocating.","This number is a lower bound; the HashMap<K, V> might be able to hold more, but is guaranteed to be able to hold at least this many."],"example":["use std::collections::HashMap;\nlet map: HashMap<i32, i32> = HashMap::with_capacity(100);\nassert!(map.capacity() >= 100);"]}},{"name":"pub fn reserve(&mut self, additional: usize)","details":{"description":["Reserves capacity for at least additional more elements to be inserted in the HashMap. The collection may reserve more space to avoid frequent reallocations.","Panics","Panics if the new allocation size overflows usize."],"example":["use std::collections::HashMap;\nlet mut map: HashMap<&str, i32> = HashMap::new();\nmap.reserve(10);"]}},{"name":"pub fn try_reserve( &mut self, additional: usize) -> Result<(), CollectionAllocErr>","stability":["🔬 This is a nightly-only experimental API.  (try_reserve #48043)new API\n"]},{"name":"pub fn shrink_to_fit(&mut self)","details":{"description":["Shrinks the capacity of the map as much as possible. It will drop down as much as possible while maintaining the internal rules and possibly leaving some space in accordance with the resize policy."],"example":["use std::collections::HashMap;\n\nlet mut map: HashMap<i32, i32> = HashMap::with_capacity(100);\nmap.insert(1, 2);\nmap.insert(3, 4);\nassert!(map.capacity() >= 100);\nmap.shrink_to_fit();\nassert!(map.capacity() >= 2);"]}},{"name":"pub fn shrink_to(&mut self, min_capacity: usize)","stability":["🔬 This is a nightly-only experimental API.  (shrink_to)new API\n"]},{"name":"pub fn keys(&self) -> Keys<K, V>","details":{"description":["An iterator visiting all keys in arbitrary order. The iterator element type is &'a K."],"example":["use std::collections::HashMap;\n\nlet mut map = HashMap::new();\nmap.insert(\"a\", 1);\nmap.insert(\"b\", 2);\nmap.insert(\"c\", 3);\n\nfor key in map.keys() {\n    println!(\"{}\", key);\n}"]}},{"name":"pub fn values(&self) -> Values<K, V>","details":{"description":["An iterator visiting all values in arbitrary order. The iterator element type is &'a V."],"example":["use std::collections::HashMap;\n\nlet mut map = HashMap::new();\nmap.insert(\"a\", 1);\nmap.insert(\"b\", 2);\nmap.insert(\"c\", 3);\n\nfor val in map.values() {\n    println!(\"{}\", val);\n}"]}},{"name":"pub fn values_mut(&mut self) -> ValuesMut<K, V>","details":{"description":["An iterator visiting all values mutably in arbitrary order. The iterator element type is &'a mut V."],"example":["use std::collections::HashMap;\n\nlet mut map = HashMap::new();\n\nmap.insert(\"a\", 1);\nmap.insert(\"b\", 2);\nmap.insert(\"c\", 3);\n\nfor val in map.values_mut() {\n    *val = *val + 10;\n}\n\nfor val in map.values() {\n    println!(\"{}\", val);\n}"]}},{"name":"pub fn iter(&self) -> Iter<K, V>","details":{"description":["An iterator visiting all key-value pairs in arbitrary order. The iterator element type is (&'a K, &'a V)."],"example":["use std::collections::HashMap;\n\nlet mut map = HashMap::new();\nmap.insert(\"a\", 1);\nmap.insert(\"b\", 2);\nmap.insert(\"c\", 3);\n\nfor (key, val) in map.iter() {\n    println!(\"key: {} val: {}\", key, val);\n}"]}},{"name":"pub fn iter_mut(&mut self) -> IterMut<K, V>","details":{"description":["An iterator visiting all key-value pairs in arbitrary order, with mutable references to the values. The iterator element type is (&'a K, &'a mut V)."],"example":["use std::collections::HashMap;\n\nlet mut map = HashMap::new();\nmap.insert(\"a\", 1);\nmap.insert(\"b\", 2);\nmap.insert(\"c\", 3);\n\n// Update all values\nfor (_, val) in map.iter_mut() {\n    *val *= 2;\n}\n\nfor (key, val) in &map {\n    println!(\"key: {} val: {}\", key, val);\n}"]}},{"name":"pub fn entry(&mut self, key: K) -> Entry<K, V>","details":{"description":["Gets the given key's corresponding entry in the map for in-place manipulation."],"example":["use std::collections::HashMap;\n\nlet mut letters = HashMap::new();\n\nfor ch in \"a short treatise on fungi\".chars() {\n    let counter = letters.entry(ch).or_insert(0);\n    *counter += 1;\n}\n\nassert_eq!(letters[&'s'], 2);\nassert_eq!(letters[&'t'], 3);\nassert_eq!(letters[&'u'], 1);\nassert_eq!(letters.get(&'y'), None);"]}},{"name":"pub fn len(&self) -> usize","details":{"description":["Returns the number of elements in the map."],"example":["use std::collections::HashMap;\n\nlet mut a = HashMap::new();\nassert_eq!(a.len(), 0);\na.insert(1, \"a\");\nassert_eq!(a.len(), 1);"]}},{"name":"pub fn is_empty(&self) -> bool","details":{"description":["Returns true if the map contains no elements."],"example":["use std::collections::HashMap;\n\nlet mut a = HashMap::new();\nassert!(a.is_empty());\na.insert(1, \"a\");\nassert!(!a.is_empty());"]}},{"name":"pub fn drain(&mut self) -> Drain<K, V>","details":{"description":["Clears the map, returning all key-value pairs as an iterator. Keeps the allocated memory for reuse."],"example":["use std::collections::HashMap;\n\nlet mut a = HashMap::new();\na.insert(1, \"a\");\na.insert(2, \"b\");\n\nfor (k, v) in a.drain().take(1) {\n    assert!(k == 1 || k == 2);\n    assert!(v == \"a\" || v == \"b\");\n}\n\nassert!(a.is_empty());"]}},{"name":"pub fn clear(&mut self)","details":{"description":["Clears the map, removing all key-value pairs. Keeps the allocated memory for reuse."],"example":["use std::collections::HashMap;\n\nlet mut a = HashMap::new();\na.insert(1, \"a\");\na.clear();\nassert!(a.is_empty());"]}},{"name":"pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V> where K: Borrow<Q>, Q: Hash + Eq","details":{"description":["Returns a reference to the value corresponding to the key.","The key may be any borrowed form of the map's key type, but Hash and Eq on the borrowed form must match those for the key type."],"example":["use std::collections::HashMap;\n\nlet mut map = HashMap::new();\nmap.insert(1, \"a\");\nassert_eq!(map.get(&1), Some(&\"a\"));\nassert_eq!(map.get(&2), None);"]}},{"name":"pub fn get_key_value<Q: ?Sized>(&self, k: &Q) -> Option<(&K, &V)> where K: Borrow<Q>, Q: Hash + Eq","stability":["🔬 This is a nightly-only experimental API.  (map_get_key_value #49347)"]},{"name":"pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool where K: Borrow<Q>, Q: Hash + Eq","details":{"description":["Returns true if the map contains a value for the specified key.","The key may be any borrowed form of the map's key type, but Hash and Eq on the borrowed form must match those for the key type."],"example":["use std::collections::HashMap;\n\nlet mut map = HashMap::new();\nmap.insert(1, \"a\");\nassert_eq!(map.contains_key(&1), true);\nassert_eq!(map.contains_key(&2), false);"]}},{"name":"pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V> where K: Borrow<Q>, Q: Hash + Eq","details":{"description":["Returns a mutable reference to the value corresponding to the key.","The key may be any borrowed form of the map's key type, but Hash and Eq on the borrowed form must match those for the key type."],"example":["use std::collections::HashMap;\n\nlet mut map = HashMap::new();\nmap.insert(1, \"a\");\nif let Some(x) = map.get_mut(&1) {\n    *x = \"b\";\n}\nassert_eq!(map[&1], \"b\");"]}},{"name":"pub fn insert(&mut self, k: K, v: V) -> Option<V>","details":{"description":["Inserts a key-value pair into the map.","If the map did not have this key present, None is returned.","If the map did have this key present, the value is updated, and the old value is returned. The key is not updated, though; this matters for types that can be == without being identical. See the module-level documentation for more."],"example":["use std::collections::HashMap;\n\nlet mut map = HashMap::new();\nassert_eq!(map.insert(37, \"a\"), None);\nassert_eq!(map.is_empty(), false);\n\nmap.insert(37, \"b\");\nassert_eq!(map.insert(37, \"c\"), Some(\"b\"));\nassert_eq!(map[&37], \"c\");"]}},{"name":"pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V> where K: Borrow<Q>, Q: Hash + Eq","details":{"description":["Removes a key from the map, returning the value at the key if the key was previously in the map.","The key may be any borrowed form of the map's key type, but Hash and Eq on the borrowed form must match those for the key type."],"example":["use std::collections::HashMap;\n\nlet mut map = HashMap::new();\nmap.insert(1, \"a\");\nassert_eq!(map.remove(&1), Some(\"a\"));\nassert_eq!(map.remove(&1), None);"]}},{"name":"pub fn remove_entry<Q: ?Sized>(&mut self, k: &Q) -> Option<(K, V)> where K: Borrow<Q>, Q: Hash + Eq","details":{"description":["Removes a key from the map, returning the stored key and value if the key was previously in the map.","The key may be any borrowed form of the map's key type, but Hash and Eq on the borrowed form must match those for the key type."],"example":["use std::collections::HashMap;\n\nlet mut map = HashMap::new();\nmap.insert(1, \"a\");\nassert_eq!(map.remove_entry(&1), Some((1, \"a\")));\nassert_eq!(map.remove(&1), None);"]}},{"name":"pub fn retain<F>(&mut self, f: F) where F: FnMut(&K, &mut V) -> bool","details":{"description":["Retains only the elements specified by the predicate.","In other words, remove all pairs (k, v) such that f(&k,&mut v) returns false."],"example":["use std::collections::HashMap;\n\nlet mut map: HashMap<i32, i32> = (0..8).map(|x|(x, x*10)).collect();\nmap.retain(|&k, _| k % 2 == 0);\nassert_eq!(map.len(), 4);"]}}]}