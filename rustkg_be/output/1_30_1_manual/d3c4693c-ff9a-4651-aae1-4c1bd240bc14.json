{"stability":{"stable since":"1.0.0"},"apiName":"std::net::UdpSocket","apiType":"struct","apiDocumentation":{"apiDescription":["A UDP socket.","After creating a UdpSocket by binding it to a socket address, data can be sent to and received from any other socket address.","Although UDP is a connectionless protocol, this implementation provides an interface to set an address where data should be sent and received from. After setting a remote address with connect, data can be sent to and received from that address with send and recv.","As stated in the User Datagram Protocol's specification in IETF RFC 768, UDP is an unordered, unreliable protocol; refer to TcpListener and TcpStream for TCP primitives."],"examples":["use std::net::UdpSocket;\n\nfn main() -> std::io::Result<()> {\n    {\n        let mut socket = UdpSocket::bind(\"127.0.0.1:34254\")?;\n\n        // Receives a single datagram message on the socket. If `buf` is too small to hold\n        // the message, it will be cut off.\n        let mut buf = [0; 10];\n        let (amt, src) = socket.recv_from(&mut buf)?;\n\n        // Redeclare `buf` as slice of the received data and send reverse data back to origin.\n        let buf = &mut buf[..amt];\n        buf.reverse();\n        socket.send_to(buf, &src)?;\n    } // the socket is closed here\n    Ok(())\n}"]},"trait implementations":[{"name":"impl std::fmt::Debug for std::net::UdpSocket","stable since":"1.0.0"},{"name":"impl std::os::windows::io::AsRawSocket for std::net::UdpSocket","stable since":"1.0.0"},{"name":"impl std::os::windows::io::FromRawSocket for std::net::UdpSocket","stable since":"1.1.0"},{"name":"impl std::os::windows::io::IntoRawSocket for std::net::UdpSocket","stable since":"1.4.0"},{"name":"impl std::os::unix::io::AsRawFd for std::net::UdpSocket","stable since":"1.0.0"},{"name":"impl std::os::unix::io::FromRawFd for std::net::UdpSocket","stable since":"1.1.0"},{"name":"impl std::os::unix::io::IntoRawFd for std::net::UdpSocket","stable since":"1.4.0"},{"name":"impl std::marker::Send for std::net::UdpSocket","stable since":"1.0.0"},{"name":"impl std::marker::Sync for std::net::UdpSocket","stable since":"1.0.0"}],"methods":[{"name":"pub fn bind<A: ToSocketAddrs>(addr: A) -> Result<UdpSocket>","details":{"description":["Creates a UDP socket from the given address.","The address type can be any implementor of ToSocketAddrs trait. See its documentation for concrete examples.","If addr yields multiple addresses, bind will be attempted with each of the addresses until one succeeds and returns the socket. If none of the addresses succeed in creating a socket, the error returned from the last attempt (the last address) is returned."],"example":["Create a UDP socket bound to 127.0.0.1:3400:","use std::net::UdpSocket;\n\nlet socket = UdpSocket::bind(\"127.0.0.1:3400\").expect(\"couldn't bind to address\");","Create a UDP socket bound to 127.0.0.1:3400. If the socket cannot be\nbound to that address, create a UDP socket bound to 127.0.0.1:3401:","use std::net::{SocketAddr, UdpSocket};\n\nlet addrs = [\n    SocketAddr::from(([127, 0, 0, 1], 3400)),\n    SocketAddr::from(([127, 0, 0, 1], 3401)),\n];\nlet socket = UdpSocket::bind(&addrs[..]).expect(\"couldn't bind to address\");"]}},{"name":"pub fn recv_from(&self, buf: &mut [u8]) -> Result<(usize, SocketAddr)>","details":{"description":["Receives a single datagram message on the socket. On success, returns the number of bytes read and the origin.","The function must be called with valid byte array buf of sufficient size to hold the message bytes. If a message is too long to fit in the supplied buffer, excess bytes may be discarded."],"example":["use std::net::UdpSocket;\n\nlet socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\nlet mut buf = [0; 10];\nlet (number_of_bytes, src_addr) = socket.recv_from(&mut buf)\n                                        .expect(\"Didn't receive data\");\nlet filled_buf = &mut buf[..number_of_bytes];"]}},{"name":"pub fn peek_from(&self, buf: &mut [u8]) -> Result<(usize, SocketAddr)>","details":{"description":["Receives a single datagram message on the socket, without removing it from the queue. On success, returns the number of bytes read and the origin.","The function must be called with valid byte array buf of sufficient size to hold the message bytes. If a message is too long to fit in the supplied buffer, excess bytes may be discarded.","Successive calls return the same data. This is accomplished by passing MSG_PEEK as a flag to the underlying recvfrom system call.","Do not use this function to implement busy waiting, instead use libc::poll to synchronize IO events on one or more sockets."],"example":["use std::net::UdpSocket;\n\nlet socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\nlet mut buf = [0; 10];\nlet (number_of_bytes, src_addr) = socket.peek_from(&mut buf)\n                                        .expect(\"Didn't receive data\");\nlet filled_buf = &mut buf[..number_of_bytes];"]}},{"name":"pub fn send_to<A: ToSocketAddrs>(&self, buf: &[u8], addr: A) -> Result<usize>","details":{"description":["Sends data on the socket to the given address. On success, returns the number of bytes written.","Address type can be any implementor of ToSocketAddrs trait. See its documentation for concrete examples.","It is possible for addr to yield multiple addresses, but send_to will only send data to the first address yielded by addr.","This will return an error when the IP version of the local socket does not match that returned from ToSocketAddrs.","See https://github.com/rust-lang/rust/issues/34202 for more details."],"example":["use std::net::UdpSocket;\n\nlet socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\nsocket.send_to(&[0; 10], \"127.0.0.1:4242\").expect(\"couldn't send data\");"]}},{"name":"pub fn local_addr(&self) -> Result<SocketAddr>","details":{"description":["Returns the socket address that this socket was created from."],"example":["use std::net::{Ipv4Addr, SocketAddr, SocketAddrV4, UdpSocket};\n\nlet socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\nassert_eq!(socket.local_addr().unwrap(),\n           SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 34254)));"]}},{"name":"pub fn try_clone(&self) -> Result<UdpSocket>","details":{"description":["Creates a new independently owned handle to the underlying socket.","The returned UdpSocket is a reference to the same socket that this object references. Both handles will read and write the same port, and options set on one socket will be propagated to the other."],"example":["use std::net::UdpSocket;\n\nlet socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\nlet socket_clone = socket.try_clone().expect(\"couldn't clone the socket\");"]}},{"name":"pub fn set_read_timeout(&self, dur: Option<Duration>) -> Result<()>","details":{"description":["Sets the read timeout to the timeout specified.","If the value specified is None, then read calls will block indefinitely. An Err is returned if the zero Duration is passed to this method.","Platform-specific behavior","Platforms may return a different error code whenever a read times out as a result of setting this option. For example Unix typically returns an error of the kind WouldBlock, but Windows may return TimedOut."],"example":["use std::net::UdpSocket;\n\nlet socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\nsocket.set_read_timeout(None).expect(\"set_read_timeout call failed\");","An Err is returned if the zero Duration is passed to this\nmethod:","use std::io;\nuse std::net::UdpSocket;\nuse std::time::Duration;\n\nlet socket = UdpSocket::bind(\"127.0.0.1:34254\").unwrap();\nlet result = socket.set_read_timeout(Some(Duration::new(0, 0)));\nlet err = result.unwrap_err();\nassert_eq!(err.kind(), io::ErrorKind::InvalidInput)"]}},{"name":"pub fn set_write_timeout(&self, dur: Option<Duration>) -> Result<()>","details":{"description":["Sets the write timeout to the timeout specified.","If the value specified is None, then write calls will block indefinitely. An Err is returned if the zero Duration is passed to this method.","Platform-specific behavior","Platforms may return a different error code whenever a write times out as a result of setting this option. For example Unix typically returns an error of the kind WouldBlock, but Windows may return TimedOut."],"example":["use std::net::UdpSocket;\n\nlet socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\nsocket.set_write_timeout(None).expect(\"set_write_timeout call failed\");","An Err is returned if the zero Duration is passed to this\nmethod:","use std::io;\nuse std::net::UdpSocket;\nuse std::time::Duration;\n\nlet socket = UdpSocket::bind(\"127.0.0.1:34254\").unwrap();\nlet result = socket.set_write_timeout(Some(Duration::new(0, 0)));\nlet err = result.unwrap_err();\nassert_eq!(err.kind(), io::ErrorKind::InvalidInput)"]}},{"name":"pub fn read_timeout(&self) -> Result<Option<Duration>>","details":{"description":["Returns the read timeout of this socket.","If the timeout is None, then read calls will block indefinitely."],"example":["use std::net::UdpSocket;\n\nlet socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\nsocket.set_read_timeout(None).expect(\"set_read_timeout call failed\");\nassert_eq!(socket.read_timeout().unwrap(), None);"]}},{"name":"pub fn write_timeout(&self) -> Result<Option<Duration>>","details":{"description":["Returns the write timeout of this socket.","If the timeout is None, then write calls will block indefinitely."],"example":["use std::net::UdpSocket;\n\nlet socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\nsocket.set_write_timeout(None).expect(\"set_write_timeout call failed\");\nassert_eq!(socket.write_timeout().unwrap(), None);"]}},{"name":"pub fn set_broadcast(&self, broadcast: bool) -> Result<()>","details":{"description":["Sets the value of the SO_BROADCAST option for this socket.","When enabled, this socket is allowed to send packets to a broadcast address."],"example":["use std::net::UdpSocket;\n\nlet socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\nsocket.set_broadcast(false).expect(\"set_broadcast call failed\");"]}},{"name":"pub fn broadcast(&self) -> Result<bool>","details":{"description":["Gets the value of the SO_BROADCAST option for this socket.","For more information about this option, see set_broadcast."],"example":["use std::net::UdpSocket;\n\nlet socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\nsocket.set_broadcast(false).expect(\"set_broadcast call failed\");\nassert_eq!(socket.broadcast().unwrap(), false);"]}},{"name":"pub fn set_multicast_loop_v4(&self, multicast_loop_v4: bool) -> Result<()>","details":{"description":["Sets the value of the IP_MULTICAST_LOOP option for this socket.","If enabled, multicast packets will be looped back to the local socket. Note that this may not have any affect on IPv6 sockets."],"example":["use std::net::UdpSocket;\n\nlet socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\nsocket.set_multicast_loop_v4(false).expect(\"set_multicast_loop_v4 call failed\");"]}},{"name":"pub fn multicast_loop_v4(&self) -> Result<bool>","details":{"description":["Gets the value of the IP_MULTICAST_LOOP option for this socket.","For more information about this option, see set_multicast_loop_v4."],"example":["use std::net::UdpSocket;\n\nlet socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\nsocket.set_multicast_loop_v4(false).expect(\"set_multicast_loop_v4 call failed\");\nassert_eq!(socket.multicast_loop_v4().unwrap(), false);"]}},{"name":"pub fn set_multicast_ttl_v4(&self, multicast_ttl_v4: u32) -> Result<()>","details":{"description":["Sets the value of the IP_MULTICAST_TTL option for this socket.","Indicates the time-to-live value of outgoing multicast packets for this socket. The default value is 1 which means that multicast packets don't leave the local network unless explicitly requested.","Note that this may not have any affect on IPv6 sockets."],"example":["use std::net::UdpSocket;\n\nlet socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\nsocket.set_multicast_ttl_v4(42).expect(\"set_multicast_ttl_v4 call failed\");"]}},{"name":"pub fn multicast_ttl_v4(&self) -> Result<u32>","details":{"description":["Gets the value of the IP_MULTICAST_TTL option for this socket.","For more information about this option, see set_multicast_ttl_v4."],"example":["use std::net::UdpSocket;\n\nlet socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\nsocket.set_multicast_ttl_v4(42).expect(\"set_multicast_ttl_v4 call failed\");\nassert_eq!(socket.multicast_ttl_v4().unwrap(), 42);"]}},{"name":"pub fn set_multicast_loop_v6(&self, multicast_loop_v6: bool) -> Result<()>","details":{"description":["Sets the value of the IPV6_MULTICAST_LOOP option for this socket.","Controls whether this socket sees the multicast packets it sends itself. Note that this may not have any affect on IPv4 sockets."],"example":["use std::net::UdpSocket;\n\nlet socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\nsocket.set_multicast_loop_v6(false).expect(\"set_multicast_loop_v6 call failed\");"]}},{"name":"pub fn multicast_loop_v6(&self) -> Result<bool>","details":{"description":["Gets the value of the IPV6_MULTICAST_LOOP option for this socket.","For more information about this option, see set_multicast_loop_v6."],"example":["use std::net::UdpSocket;\n\nlet socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\nsocket.set_multicast_loop_v6(false).expect(\"set_multicast_loop_v6 call failed\");\nassert_eq!(socket.multicast_loop_v6().unwrap(), false);"]}},{"name":"pub fn set_ttl(&self, ttl: u32) -> Result<()>","details":{"description":["Sets the value for the IP_TTL option on this socket.","This value sets the time-to-live field that is used in every packet sent from this socket."],"example":["use std::net::UdpSocket;\n\nlet socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\nsocket.set_ttl(42).expect(\"set_ttl call failed\");"]}},{"name":"pub fn ttl(&self) -> Result<u32>","details":{"description":["Gets the value of the IP_TTL option for this socket.","For more information about this option, see set_ttl."],"example":["use std::net::UdpSocket;\n\nlet socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\nsocket.set_ttl(42).expect(\"set_ttl call failed\");\nassert_eq!(socket.ttl().unwrap(), 42);"]}},{"name":"pub fn join_multicast_v4( &self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr) -> Result<()>","details":{"description":["Executes an operation of the IP_ADD_MEMBERSHIP type.","This function specifies a new multicast group for this socket to join. The address must be a valid multicast address, and interface is the address of the local interface with which the system should join the multicast group. If it's equal to INADDR_ANY then an appropriate interface is chosen by the system."]}},{"name":"pub fn join_multicast_v6( &self, multiaddr: &Ipv6Addr, interface: u32) -> Result<()>","details":{"description":["Executes an operation of the IPV6_ADD_MEMBERSHIP type.","This function specifies a new multicast group for this socket to join. The address must be a valid multicast address, and interface is the index of the interface to join/leave (or 0 to indicate any interface)."]}},{"name":"pub fn leave_multicast_v4( &self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr) -> Result<()>","details":{"description":["Executes an operation of the IP_DROP_MEMBERSHIP type.","For more information about this option, see join_multicast_v4."]}},{"name":"pub fn leave_multicast_v6( &self, multiaddr: &Ipv6Addr, interface: u32) -> Result<()>","details":{"description":["Executes an operation of the IPV6_DROP_MEMBERSHIP type.","For more information about this option, see join_multicast_v6."]}},{"name":"pub fn take_error(&self) -> Result<Option<Error>>","details":{"description":["Get the value of the SO_ERROR option on this socket.","This will retrieve the stored error in the underlying socket, clearing the field in the process. This can be useful for checking errors between calls."],"example":["use std::net::UdpSocket;\n\nlet socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\nmatch socket.take_error() {\n    Ok(Some(error)) => println!(\"UdpSocket error: {:?}\", error),\n    Ok(None) => println!(\"No error\"),\n    Err(error) => println!(\"UdpSocket.take_error failed: {:?}\", error),\n}"]}},{"name":"pub fn connect<A: ToSocketAddrs>(&self, addr: A) -> Result<()>","details":{"description":["Connects this UDP socket to a remote address, allowing the send and recv syscalls to be used to send data and also applies filters to only receive data from the specified address.","If addr yields multiple addresses, connect will be attempted with each of the addresses until the underlying OS function returns no error. Note that usually, a successful connect call does not specify that there is a remote server listening on the port, rather, such an error would only be detected after the first send. If the OS returns an error for each of the specified addresses, the error returned from the last connection attempt (the last address) is returned."],"example":["Create a UDP socket bound to 127.0.0.1:3400 and connect the socket to\n127.0.0.1:8080:","use std::net::UdpSocket;\n\nlet socket = UdpSocket::bind(\"127.0.0.1:3400\").expect(\"couldn't bind to address\");\nsocket.connect(\"127.0.0.1:8080\").expect(\"connect function failed\");","Unlike in the TCP case, passing an array of addresses to the connect\nfunction of a UDP socket is not a useful thing to do: The OS will be\nunable to determine whether something is listening on the remote\naddress without the application sending data."]}},{"name":"pub fn send(&self, buf: &[u8]) -> Result<usize>","details":{"description":["Sends data on the socket to the remote address to which it is connected.","The connect method will connect this socket to a remote address. This method will fail if the socket is not connected."],"example":["use std::net::UdpSocket;\n\nlet socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\nsocket.connect(\"127.0.0.1:8080\").expect(\"connect function failed\");\nsocket.send(&[0, 1, 2]).expect(\"couldn't send message\");"]}},{"name":"pub fn recv(&self, buf: &mut [u8]) -> Result<usize>","details":{"description":["Receives a single datagram message on the socket from the remote address to which it is connected. On success, returns the number of bytes read.","The function must be called with valid byte array buf of sufficient size to hold the message bytes. If a message is too long to fit in the supplied buffer, excess bytes may be discarded.","The connect method will connect this socket to a remote address. This method will fail if the socket is not connected."],"example":["use std::net::UdpSocket;\n\nlet socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\nsocket.connect(\"127.0.0.1:8080\").expect(\"connect function failed\");\nlet mut buf = [0; 10];\nmatch socket.recv(&mut buf) {\n    Ok(received) => println!(\"received {} bytes {:?}\", received, &buf[..received]),\n    Err(e) => println!(\"recv function failed: {:?}\", e),\n}"]}},{"name":"pub fn peek(&self, buf: &mut [u8]) -> Result<usize>","details":{"description":["Receives single datagram on the socket from the remote address to which it is connected, without removing the message from input queue. On success, returns the number of bytes peeked.","The function must be called with valid byte array buf of sufficient size to hold the message bytes. If a message is too long to fit in the supplied buffer, excess bytes may be discarded.","Successive calls return the same data. This is accomplished by passing MSG_PEEK as a flag to the underlying recv system call.","Do not use this function to implement busy waiting, instead use libc::poll to synchronize IO events on one or more sockets.","The connect method will connect this socket to a remote address. This method will fail if the socket is not connected.","Errors","This method will fail if the socket is not connected. The connect method will connect this socket to a remote address."],"example":["use std::net::UdpSocket;\n\nlet socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\nsocket.connect(\"127.0.0.1:8080\").expect(\"connect function failed\");\nlet mut buf = [0; 10];\nmatch socket.peek(&mut buf) {\n    Ok(received) => println!(\"received {} bytes\", received),\n    Err(e) => println!(\"peek function failed: {:?}\", e),\n}"]}},{"name":"pub fn set_nonblocking(&self, nonblocking: bool) -> Result<()>","details":{"description":["Moves this UDP socket into or out of nonblocking mode.","This will result in recv, recv_from, send, and send_to operations becoming nonblocking, i.e. immediately returning from their calls. If the IO operation is successful, Ok is returned and no further action is required. If the IO operation could not be completed and needs to be retried, an error with kind io::ErrorKind::WouldBlock is returned.","On Unix platforms, calling this method corresponds to calling fcntl FIONBIO. On Windows calling this method corresponds to calling ioctlsocket FIONBIO."],"example":["Create a UDP socket bound to 127.0.0.1:7878 and read bytes in\nnonblocking mode:","use std::io;\nuse std::net::UdpSocket;\n\nlet socket = UdpSocket::bind(\"127.0.0.1:7878\").unwrap();\nsocket.set_nonblocking(true).unwrap();\n\nlet mut buf = [0; 10];\nlet (num_bytes_read, _) = loop {\n    match socket.recv_from(&mut buf) {\n        Ok(n) => break n,\n        Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {\n            // wait until network socket is ready, typically implemented\n            // via platform-specific APIs such as epoll or IOCP\n            wait_for_fd();\n        }\n        Err(e) => panic!(\"encountered IO error: {}\", e),\n    }\n};\nprintln!(\"bytes: {:?}\", &buf[..num_bytes_read]);"]}}]}