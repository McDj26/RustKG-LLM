{"stability":{"stable since":"1.0.0"},"apiName":"std::sync::mpsc::Sender","apiType":"struct","apiDocumentation":{"apiDescription":["The sending-half of Rust's asynchronous channel type. This half can only be owned by one thread, but it can be cloned to send to other threads.","Messages can be sent through this channel with send."],"examples":["use std::sync::mpsc::channel;\nuse std::thread;\n\nlet (sender, receiver) = channel();\nlet sender2 = sender.clone();\n\n// First thread owns sender\nthread::spawn(move || {\n    sender.send(1).unwrap();\n});\n\n// Second thread owns sender2\nthread::spawn(move || {\n    sender2.send(2).unwrap();\n});\n\nlet msg = receiver.recv().unwrap();\nlet msg2 = receiver.recv().unwrap();\n\nassert_eq!(3, msg + msg2);"]},"trait implementations":[{"name":"impl<T: std::marker::Send> std::marker::Send for std::sync::mpsc::Sender<T>","stable since":"1.0.0"},{"name":"impl<T> !std::marker::Sync for std::sync::mpsc::Sender<T>","stable since":"1.0.0"},{"name":"impl<T> std::clone::Clone for std::sync::mpsc::Sender<T>","stable since":"1.0.0"},{"name":"impl<T> std::ops::Drop for std::sync::mpsc::Sender<T>","stable since":"1.0.0"},{"name":"impl<T> std::fmt::Debug for std::sync::mpsc::Sender<T>","stable since":"1.8.0"}],"methods":[{"name":"pub fn send(&self, t: T) -> Result<(), SendError<T>>","details":{"description":["Attempts to send a value on this channel, returning it back if it could not be sent.","A successful send occurs when it is determined that the other end of the channel has not hung up already. An unsuccessful send would be one where the corresponding receiver has already been deallocated. Note that a return value of Err means that the data will never be received, but a return value of Ok does not mean that the data will be received. It is possible for the corresponding receiver to hang up immediately after this function returns Ok.","This method will never block the current thread."],"example":["use std::sync::mpsc::channel;\n\nlet (tx, rx) = channel();\n\n// This send is always successful\ntx.send(1).unwrap();\n\n// This send will fail because the receiver is gone\ndrop(rx);\nassert_eq!(tx.send(1).unwrap_err().0, 1);"]}}]}