{"stability":{"stable since":"1.0.0"},"apiName":"slice","apiType":"primitive","apiDocumentation":{"apiDescription":["A dynamically-sized view into a contiguous sequence, [T].","See also the std::slice module.","Slices are a view into a block of memory represented as a pointer and a length.","// slicing a Vec let vec = vec![1, 2, 3]; let int_slice = &vec[..]; // coercing an array to a slice let str_slice: &[&str] = &[\"one\", \"two\", \"three\"];","Slices are either mutable or shared. The shared slice type is &[T], while the mutable slice type is &mut [T], where T represents the element type. For example, you can mutate the block of memory that a mutable slice points to:","let x = &mut [1, 2, 3]; x[1] = 7; assert_eq!(x, &[1, 7, 3]);"]},"trait implementations":[{"name":"impl<T> std::convert::AsMut<[T]> for [T]","stable since":"1.0.0"},{"name":"impl<'a, T> std::iter::IntoIterator for &'a mut [T]","stable since":"1.0.0"},{"name":"impl<'a, T> std::iter::IntoIterator for &'a [T]","stable since":"1.0.0"},{"name":"impl<T> std::hash::Hash for [T] where T: std::hash::Hash","stable since":"1.0.0"},{"name":"impl<T> std::cmp::PartialOrd<[T]> for [T] where T: std::cmp::PartialOrd<T>","stable since":"1.0.0"},{"name":"impl<T, I> std::ops::IndexMut<I> for [T] where I: std::slice::SliceIndex<[T]>","stable since":"1.0.0"},{"name":"impl<T, I> std::ops::Index<I> for [T] where I: std::slice::SliceIndex<[T]>","stable since":"1.0.0"},{"name":"impl<T> std::cmp::Ord for [T] where T: std::cmp::Ord","stable since":"1.0.0"},{"name":"impl<T> std::fmt::Debug for [T] where T: std::fmt::Debug","stable since":"1.0.0"},{"name":"impl<T> std::cmp::Eq for [T] where T: std::cmp::Eq","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 27]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 1]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 6]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 17]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 5]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 7]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 17]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 21]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 16]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 10]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 8]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 5]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 29]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 4]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 2]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 10]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 19]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 8]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 0]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 2]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 13]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 25]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 23]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 7]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 7]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 16]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 19]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 4]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 29]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 4]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 30]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<A, B> std::cmp::PartialEq<[B]> for [A] where A: std::cmp::PartialEq<B>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 3]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 13]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 28]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 11]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 5]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 20]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 9]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 26]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 18]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 24]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 27]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 31]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 1]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 32]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 16]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 1]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 15]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 29]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 23]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 2]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 14]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 30]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 31]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 26]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 21]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 14]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 15]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 13]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 32]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 31]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 20]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 28]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 24]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 9]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 0]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 22]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 15]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 6]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 27]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 12]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 0]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 24]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 11]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 22]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 17]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 18]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 19]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 21]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 11]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 12]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 10]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 30]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 6]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 12]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 20]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 9]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 18]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 22]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 3]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 28]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 25]> for &'b [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 26]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 8]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 32]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 14]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 25]> for &'b mut [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 3]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b, A, B> std::cmp::PartialEq<[A; 23]> for [B] where B: std::cmp::PartialEq<A>","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::str::pattern::Pattern<'a> for &'b [char]","stable since":"1.0.0"},{"name":"impl<T> std::convert::AsRef<[T]> for [T]","stable since":"1.0.0"},{"name":"impl<'a, T> std::default::Default for &'a [T]","stable since":"1.0.0"},{"name":"impl<'a, T> std::default::Default for &'a mut [T]","stable since":"1.5.0"},{"name":"impl<T, V> std::slice::SliceConcatExt<T> for [V] where T: std::clone::Clone, V: std::borrow::Borrow<[T]>","stable since":"1.0.0"},{"name":"impl<S> std::slice::SliceConcatExt<str> for [S] where S: std::borrow::Borrow<str>","stable since":"1.0.0"},{"name":"impl<T> std::borrow::ToOwned for [T] where T: std::clone::Clone","stable since":"1.0.0"},{"name":"impl std::ascii::AsciiExt for [u8]","stable since":"1.0.0"},{"name":"impl<'a> std::io::Read for &'a [u8]","stable since":"1.0.0"},{"name":"impl<'a> std::io::BufRead for &'a [u8]","stable since":"1.0.0"},{"name":"impl<'a> std::io::Write for &'a mut [u8]","stable since":"1.0.0"},{"name":"impl<'a> std::net::ToSocketAddrs for &'a [std::net::SocketAddr]","stable since":"1.8.0"}],"methods":[{"name":"pub const fn len(&self) -> usize","details":{"description":["Returns the number of elements in the slice."],"example":["let a = [1, 2, 3];\nassert_eq!(a.len(), 3);"]}},{"name":"pub const fn is_empty(&self) -> bool","details":{"description":["Returns true if the slice has a length of 0."],"example":["let a = [1, 2, 3];\nassert!(!a.is_empty());"]}},{"name":"pub fn first(&self) -> Option<&T>","details":{"description":["Returns the first element of the slice, or None if it is empty."],"example":["let v = [10, 40, 30];\nassert_eq!(Some(&10), v.first());\n\nlet w: &[i32] = &[];\nassert_eq!(None, w.first());"]}},{"name":"pub fn first_mut(&mut self) -> Option<&mut T>","details":{"description":["Returns a mutable pointer to the first element of the slice, or None if it is empty."],"example":["let x = &mut [0, 1, 2];\n\nif let Some(first) = x.first_mut() {\n    *first = 5;\n}\nassert_eq!(x, &[5, 1, 2]);"]}},{"name":"pub fn split_first(&self) -> Option<(&T, &[T])>","details":{"description":["Returns the first and all the rest of the elements of the slice, or None if it is empty."],"example":["let x = &[0, 1, 2];\n\nif let Some((first, elements)) = x.split_first() {\n    assert_eq!(first, &0);\n    assert_eq!(elements, &[1, 2]);\n}"]}},{"name":"pub fn split_first_mut(&mut self) -> Option<(&mut T, &mut [T])>","details":{"description":["Returns the first and all the rest of the elements of the slice, or None if it is empty."],"example":["let x = &mut [0, 1, 2];\n\nif let Some((first, elements)) = x.split_first_mut() {\n    *first = 3;\n    elements[0] = 4;\n    elements[1] = 5;\n}\nassert_eq!(x, &[3, 4, 5]);"]}},{"name":"pub fn split_last(&self) -> Option<(&T, &[T])>","details":{"description":["Returns the last and all the rest of the elements of the slice, or None if it is empty."],"example":["let x = &[0, 1, 2];\n\nif let Some((last, elements)) = x.split_last() {\n    assert_eq!(last, &2);\n    assert_eq!(elements, &[0, 1]);\n}"]}},{"name":"pub fn split_last_mut(&mut self) -> Option<(&mut T, &mut [T])>","details":{"description":["Returns the last and all the rest of the elements of the slice, or None if it is empty."],"example":["let x = &mut [0, 1, 2];\n\nif let Some((last, elements)) = x.split_last_mut() {\n    *last = 3;\n    elements[0] = 4;\n    elements[1] = 5;\n}\nassert_eq!(x, &[4, 5, 3]);"]}},{"name":"pub fn last(&self) -> Option<&T>","details":{"description":["Returns the last element of the slice, or None if it is empty."],"example":["let v = [10, 40, 30];\nassert_eq!(Some(&30), v.last());\n\nlet w: &[i32] = &[];\nassert_eq!(None, w.last());"]}},{"name":"pub fn last_mut(&mut self) -> Option<&mut T>","details":{"description":["Returns a mutable pointer to the last item in the slice."],"example":["let x = &mut [0, 1, 2];\n\nif let Some(last) = x.last_mut() {\n    *last = 10;\n}\nassert_eq!(x, &[0, 1, 10]);"]}},{"name":"pub fn get<I>(&self, index: I) -> Option<&<I as SliceIndex<[T]>>::Output> where I: SliceIndex<[T]>","details":{"description":["Returns a reference to an element or subslice depending on the type of index.","If given a position, returns a reference to the element at that position or None if out of bounds. If given a range, returns the subslice corresponding to that range, or None if out of bounds."],"example":["let v = [10, 40, 30];\nassert_eq!(Some(&40), v.get(1));\nassert_eq!(Some(&[10, 40][..]), v.get(0..2));\nassert_eq!(None, v.get(3));\nassert_eq!(None, v.get(0..4));"]}},{"name":"pub fn get_mut<I>( &mut self, index: I) -> Option<&mut <I as SliceIndex<[T]>>::Output> where I: SliceIndex<[T]>","details":{"description":["Returns a mutable reference to an element or subslice depending on the type of index (see get) or None if the index is out of bounds."],"example":["let x = &mut [0, 1, 2];\n\nif let Some(elem) = x.get_mut(1) {\n    *elem = 42;\n}\nassert_eq!(x, &[0, 42, 2]);"]}},{"name":"pub unsafe fn get_unchecked<I>( &self, index: I) -> &<I as SliceIndex<[T]>>::Output where I: SliceIndex<[T]>","details":{"description":["Returns a reference to an element or subslice, without doing bounds checking.","This is generally not recommended, use with caution! For a safe alternative see get."],"example":["let x = &[1, 2, 4];\n\nunsafe {\n    assert_eq!(x.get_unchecked(1), &2);\n}"]}},{"name":"pub unsafe fn get_unchecked_mut<I>( &mut self, index: I) -> &mut <I as SliceIndex<[T]>>::Output where I: SliceIndex<[T]>","details":{"description":["Returns a mutable reference to an element or subslice, without doing bounds checking.","This is generally not recommended, use with caution! For a safe alternative see get_mut."],"example":["let x = &mut [1, 2, 4];\n\nunsafe {\n    let elem = x.get_unchecked_mut(1);\n    *elem = 13;\n}\nassert_eq!(x, &[1, 13, 4]);"]}},{"name":"pub const fn as_ptr(&self) -> *const T","details":{"description":["Returns a raw pointer to the slice's buffer.","The caller must ensure that the slice outlives the pointer this function returns, or else it will end up pointing to garbage.","Modifying the container referenced by this slice may cause its buffer to be reallocated, which would also make any pointers to it invalid."],"example":["let x = &[1, 2, 4];\nlet x_ptr = x.as_ptr();\n\nunsafe {\n    for i in 0..x.len() {\n        assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n    }\n}"]}},{"name":"pub fn as_mut_ptr(&mut self) -> *mut T","details":{"description":["Returns an unsafe mutable pointer to the slice's buffer.","The caller must ensure that the slice outlives the pointer this function returns, or else it will end up pointing to garbage.","Modifying the container referenced by this slice may cause its buffer to be reallocated, which would also make any pointers to it invalid."],"example":["let x = &mut [1, 2, 4];\nlet x_ptr = x.as_mut_ptr();\n\nunsafe {\n    for i in 0..x.len() {\n        *x_ptr.add(i) += 2;\n    }\n}\nassert_eq!(x, &[3, 4, 6]);"]}},{"name":"pub fn swap(&mut self, a: usize, b: usize)","details":{"description":["Swaps two elements in the slice.","Arguments","a - The index of the first element b - The index of the second element","Panics","Panics if a or b are out of bounds."],"example":["let mut v = [\"a\", \"b\", \"c\", \"d\"];\nv.swap(1, 3);\nassert!(v == [\"a\", \"d\", \"c\", \"b\"]);"]}},{"name":"pub fn reverse(&mut self)","details":{"description":["Reverses the order of elements in the slice, in place."],"example":["let mut v = [1, 2, 3];\nv.reverse();\nassert!(v == [3, 2, 1]);"]}},{"name":"pub fn iter(&self) -> Iter<T>","details":{"description":["Returns an iterator over the slice."],"example":["let x = &[1, 2, 4];\nlet mut iterator = x.iter();\n\nassert_eq!(iterator.next(), Some(&1));\nassert_eq!(iterator.next(), Some(&2));\nassert_eq!(iterator.next(), Some(&4));\nassert_eq!(iterator.next(), None);"]}},{"name":"pub fn iter_mut(&mut self) -> IterMut<T>","details":{"description":["Returns an iterator that allows modifying each value."],"example":["let x = &mut [1, 2, 4];\nfor elem in x.iter_mut() {\n    *elem += 2;\n}\nassert_eq!(x, &[3, 4, 6]);"]}},{"name":"pub fn windows(&self, size: usize) -> Windows<T>","details":{"description":["Returns an iterator over all contiguous windows of length size. The windows overlap. If the slice is shorter than size, the iterator returns no values.","Panics","Panics if size is 0."],"example":["let slice = ['r', 'u', 's', 't'];\nlet mut iter = slice.windows(2);\nassert_eq!(iter.next().unwrap(), &['r', 'u']);\nassert_eq!(iter.next().unwrap(), &['u', 's']);\nassert_eq!(iter.next().unwrap(), &['s', 't']);\nassert!(iter.next().is_none());","If the slice is shorter than size:","let slice = ['f', 'o', 'o'];\nlet mut iter = slice.windows(4);\nassert!(iter.next().is_none());"]}},{"name":"pub fn chunks(&self, chunk_size: usize) -> Chunks<T>","details":{"description":["Returns an iterator over chunk_size elements of the slice at a time. The chunks are slices and do not overlap. If chunk_size does not divide the length of the slice, then the last chunk will not have length chunk_size.","See exact_chunks for a variant of this iterator that returns chunks of always exactly chunk_size elements.","Panics","Panics if chunk_size is 0."],"example":["let slice = ['l', 'o', 'r', 'e', 'm'];\nlet mut iter = slice.chunks(2);\nassert_eq!(iter.next().unwrap(), &['l', 'o']);\nassert_eq!(iter.next().unwrap(), &['r', 'e']);\nassert_eq!(iter.next().unwrap(), &['m']);\nassert!(iter.next().is_none());"]}},{"name":"pub fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<T>","details":{"description":["Returns an iterator over chunk_size elements of the slice at a time. The chunks are mutable slices, and do not overlap. If chunk_size does not divide the length of the slice, then the last chunk will not have length chunk_size.","See exact_chunks_mut for a variant of this iterator that returns chunks of always exactly chunk_size elements.","Panics","Panics if chunk_size is 0."],"example":["let v = &mut [0, 0, 0, 0, 0];\nlet mut count = 1;\n\nfor chunk in v.chunks_mut(2) {\n    for elem in chunk.iter_mut() {\n        *elem += count;\n    }\n    count += 1;\n}\nassert_eq!(v, &[1, 1, 2, 2, 3]);"]}},{"name":"pub fn exact_chunks(&self, chunk_size: usize) -> ExactChunks<T>","stability":["🔬 This is a nightly-only experimental API.  (exact_chunks #47115)"]},{"name":"pub fn exact_chunks_mut(&mut self, chunk_size: usize) -> ExactChunksMut<T>","stability":["🔬 This is a nightly-only experimental API.  (exact_chunks #47115)"]},{"name":"pub fn split_at(&self, mid: usize) -> (&[T], &[T])","details":{"description":["Divides one slice into two at an index.","The first will contain all indices from [0, mid) (excluding the index mid itself) and the second will contain all indices from [mid, len) (excluding the index len itself).","Panics","Panics if mid > len."],"example":["let v = [1, 2, 3, 4, 5, 6];\n\n{\n   let (left, right) = v.split_at(0);\n   assert!(left == []);\n   assert!(right == [1, 2, 3, 4, 5, 6]);\n}\n\n{\n    let (left, right) = v.split_at(2);\n    assert!(left == [1, 2]);\n    assert!(right == [3, 4, 5, 6]);\n}\n\n{\n    let (left, right) = v.split_at(6);\n    assert!(left == [1, 2, 3, 4, 5, 6]);\n    assert!(right == []);\n}"]}},{"name":"pub fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T])","details":{"description":["Divides one mutable slice into two at an index.","The first will contain all indices from [0, mid) (excluding the index mid itself) and the second will contain all indices from [mid, len) (excluding the index len itself).","Panics","Panics if mid > len."],"example":["let mut v = [1, 0, 3, 0, 5, 6];\n// scoped to restrict the lifetime of the borrows\n{\n    let (left, right) = v.split_at_mut(2);\n    assert!(left == [1, 0]);\n    assert!(right == [3, 0, 5, 6]);\n    left[1] = 2;\n    right[1] = 4;\n}\nassert!(v == [1, 2, 3, 4, 5, 6]);"]}},{"name":"pub fn split<F>(&self, pred: F) -> Split<T, F> where F: FnMut(&T) -> bool","details":{"description":["Returns an iterator over subslices separated by elements that match pred. The matched element is not contained in the subslices."],"example":["let slice = [10, 40, 33, 20];\nlet mut iter = slice.split(|num| num % 3 == 0);\n\nassert_eq!(iter.next().unwrap(), &[10, 40]);\nassert_eq!(iter.next().unwrap(), &[20]);\nassert!(iter.next().is_none());","If the first element is matched, an empty slice will be the first item\nreturned by the iterator. Similarly, if the last element in the slice\nis matched, an empty slice will be the last item returned by the\niterator:","let slice = [10, 40, 33];\nlet mut iter = slice.split(|num| num % 3 == 0);\n\nassert_eq!(iter.next().unwrap(), &[10, 40]);\nassert_eq!(iter.next().unwrap(), &[]);\nassert!(iter.next().is_none());","If two matched elements are directly adjacent, an empty slice will be\npresent between them:","let slice = [10, 6, 33, 20];\nlet mut iter = slice.split(|num| num % 3 == 0);\n\nassert_eq!(iter.next().unwrap(), &[10]);\nassert_eq!(iter.next().unwrap(), &[]);\nassert_eq!(iter.next().unwrap(), &[20]);\nassert!(iter.next().is_none());"]}},{"name":"pub fn split_mut<F>(&mut self, pred: F) -> SplitMut<T, F> where F: FnMut(&T) -> bool","details":{"description":["Returns an iterator over mutable subslices separated by elements that match pred. The matched element is not contained in the subslices."],"example":["let mut v = [10, 40, 30, 20, 60, 50];\n\nfor group in v.split_mut(|num| *num % 3 == 0) {\n    group[0] = 1;\n}\nassert_eq!(v, [1, 40, 30, 1, 60, 1]);"]}},{"name":"pub fn rsplit<F>(&self, pred: F) -> RSplit<T, F> where F: FnMut(&T) -> bool","details":{"description":["Returns an iterator over subslices separated by elements that match pred, starting at the end of the slice and working backwards. The matched element is not contained in the subslices."],"example":["let slice = [11, 22, 33, 0, 44, 55];\nlet mut iter = slice.rsplit(|num| *num == 0);\n\nassert_eq!(iter.next().unwrap(), &[44, 55]);\nassert_eq!(iter.next().unwrap(), &[11, 22, 33]);\nassert_eq!(iter.next(), None);","As with split(), if the first or last element is matched, an empty\nslice will be the first (or last) item returned by the iterator.","let v = &[0, 1, 1, 2, 3, 5, 8];\nlet mut it = v.rsplit(|n| *n % 2 == 0);\nassert_eq!(it.next().unwrap(), &[]);\nassert_eq!(it.next().unwrap(), &[3, 5]);\nassert_eq!(it.next().unwrap(), &[1, 1]);\nassert_eq!(it.next().unwrap(), &[]);\nassert_eq!(it.next(), None);"]}},{"name":"pub fn rsplit_mut<F>(&mut self, pred: F) -> RSplitMut<T, F> where F: FnMut(&T) -> bool","details":{"description":["Returns an iterator over mutable subslices separated by elements that match pred, starting at the end of the slice and working backwards. The matched element is not contained in the subslices."],"example":["let mut v = [100, 400, 300, 200, 600, 500];\n\nlet mut count = 0;\nfor group in v.rsplit_mut(|num| *num % 3 == 0) {\n    count += 1;\n    group[0] = count;\n}\nassert_eq!(v, [3, 400, 300, 2, 600, 1]);"]}},{"name":"pub fn splitn<F>(&self, n: usize, pred: F) -> SplitN<T, F> where F: FnMut(&T) -> bool","details":{"description":["Returns an iterator over subslices separated by elements that match pred, limited to returning at most n items. The matched element is not contained in the subslices.","The last element returned, if any, will contain the remainder of the slice."],"example":["Print the slice split once by numbers divisible by 3 (i.e. [10, 40],\n[20, 60, 50]):","let v = [10, 40, 30, 20, 60, 50];\n\nfor group in v.splitn(2, |num| *num % 3 == 0) {\n    println!(\"{:?}\", group);\n}"]}},{"name":"pub fn splitn_mut<F>(&mut self, n: usize, pred: F) -> SplitNMut<T, F> where F: FnMut(&T) -> bool","details":{"description":["Returns an iterator over subslices separated by elements that match pred, limited to returning at most n items. The matched element is not contained in the subslices.","The last element returned, if any, will contain the remainder of the slice."],"example":["let mut v = [10, 40, 30, 20, 60, 50];\n\nfor group in v.splitn_mut(2, |num| *num % 3 == 0) {\n    group[0] = 1;\n}\nassert_eq!(v, [1, 40, 30, 1, 60, 50]);"]}},{"name":"pub fn rsplitn<F>(&self, n: usize, pred: F) -> RSplitN<T, F> where F: FnMut(&T) -> bool","details":{"description":["Returns an iterator over subslices separated by elements that match pred limited to returning at most n items. This starts at the end of the slice and works backwards. The matched element is not contained in the subslices.","The last element returned, if any, will contain the remainder of the slice."],"example":["Print the slice split once, starting from the end, by numbers divisible\nby 3 (i.e. [50], [10, 40, 30, 20]):","let v = [10, 40, 30, 20, 60, 50];\n\nfor group in v.rsplitn(2, |num| *num % 3 == 0) {\n    println!(\"{:?}\", group);\n}"]}},{"name":"pub fn rsplitn_mut<F>(&mut self, n: usize, pred: F) -> RSplitNMut<T, F> where F: FnMut(&T) -> bool","details":{"description":["Returns an iterator over subslices separated by elements that match pred limited to returning at most n items. This starts at the end of the slice and works backwards. The matched element is not contained in the subslices.","The last element returned, if any, will contain the remainder of the slice."],"example":["let mut s = [10, 40, 30, 20, 60, 50];\n\nfor group in s.rsplitn_mut(2, |num| *num % 3 == 0) {\n    group[0] = 1;\n}\nassert_eq!(s, [1, 40, 30, 20, 60, 1]);"]}},{"name":"pub fn contains(&self, x: &T) -> bool where T: PartialEq<T>","details":{"description":["Returns true if the slice contains an element with the given value."],"example":["let v = [10, 40, 30];\nassert!(v.contains(&30));\nassert!(!v.contains(&50));"]}},{"name":"pub fn starts_with(&self, needle: &[T]) -> bool where T: PartialEq<T>","details":{"description":["Returns true if needle is a prefix of the slice."],"example":["let v = [10, 40, 30];\nassert!(v.starts_with(&[10]));\nassert!(v.starts_with(&[10, 40]));\nassert!(!v.starts_with(&[50]));\nassert!(!v.starts_with(&[10, 50]));","Always returns true if needle is an empty slice:","let v = &[10, 40, 30];\nassert!(v.starts_with(&[]));\nlet v: &[u8] = &[];\nassert!(v.starts_with(&[]));"]}},{"name":"pub fn ends_with(&self, needle: &[T]) -> bool where T: PartialEq<T>","details":{"description":["Returns true if needle is a suffix of the slice."],"example":["let v = [10, 40, 30];\nassert!(v.ends_with(&[30]));\nassert!(v.ends_with(&[40, 30]));\nassert!(!v.ends_with(&[50]));\nassert!(!v.ends_with(&[50, 30]));","Always returns true if needle is an empty slice:","let v = &[10, 40, 30];\nassert!(v.ends_with(&[]));\nlet v: &[u8] = &[];\nassert!(v.ends_with(&[]));"]}},{"name":"pub fn binary_search(&self, x: &T) -> Result<usize, usize> where T: Ord","details":{"description":["Binary searches this sorted slice for a given element.","If the value is found then Ok is returned, containing the index of the matching element; if the value is not found then Err is returned, containing the index where a matching element could be inserted while maintaining sorted order."],"example":["Looks up a series of four elements. The first is found, with a\nuniquely determined position; the second and third are not\nfound; the fourth could match any position in [1, 4].","let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n\nassert_eq!(s.binary_search(&13),  Ok(9));\nassert_eq!(s.binary_search(&4),   Err(7));\nassert_eq!(s.binary_search(&100), Err(13));\nlet r = s.binary_search(&1);\nassert!(match r { Ok(1..=4) => true, _ => false, });"]}},{"name":"pub fn binary_search_by<'a, F>(&'a self, f: F) -> Result<usize, usize> where F: FnMut(&'a T) -> Ordering","details":{"description":["Binary searches this sorted slice with a comparator function.","The comparator function should implement an order consistent with the sort order of the underlying slice, returning an order code that indicates whether its argument is Less, Equal or Greater the desired target.","If a matching value is found then returns Ok, containing the index for the matched element; if no match is found then Err is returned, containing the index where a matching element could be inserted while maintaining sorted order."],"example":["Looks up a series of four elements. The first is found, with a\nuniquely determined position; the second and third are not\nfound; the fourth could match any position in [1, 4].","let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n\nlet seek = 13;\nassert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Ok(9));\nlet seek = 4;\nassert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(7));\nlet seek = 100;\nassert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(13));\nlet seek = 1;\nlet r = s.binary_search_by(|probe| probe.cmp(&seek));\nassert!(match r { Ok(1..=4) => true, _ => false, });"]}},{"name":"pub fn binary_search_by_key<'a, B, F>( &'a self, b: &B, f: F) -> Result<usize, usize> where B: Ord, F: FnMut(&'a T) -> B","details":{"description":["Binary searches this sorted slice with a key extraction function.","Assumes that the slice is sorted by the key, for instance with sort_by_key using the same key extraction function.","If a matching value is found then returns Ok, containing the index for the matched element; if no match is found then Err is returned, containing the index where a matching element could be inserted while maintaining sorted order."],"example":["Looks up a series of four elements in a slice of pairs sorted by\ntheir second elements. The first is found, with a uniquely\ndetermined position; the second and third are not found; the\nfourth could match any position in [1, 4].","let s = [(0, 0), (2, 1), (4, 1), (5, 1), (3, 1),\n         (1, 2), (2, 3), (4, 5), (5, 8), (3, 13),\n         (1, 21), (2, 34), (4, 55)];\n\nassert_eq!(s.binary_search_by_key(&13, |&(a,b)| b),  Ok(9));\nassert_eq!(s.binary_search_by_key(&4, |&(a,b)| b),   Err(7));\nassert_eq!(s.binary_search_by_key(&100, |&(a,b)| b), Err(13));\nlet r = s.binary_search_by_key(&1, |&(a,b)| b);\nassert!(match r { Ok(1..=4) => true, _ => false, });"]}},{"name":"pub fn sort_unstable(&mut self) where T: Ord","details":{"description":["Sorts the slice, but may not preserve the order of equal elements.","This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate), and O(n log n) worst-case.","Current implementation","The current algorithm is based on pattern-defeating quicksort by Orson Peters, which combines the fast average case of randomized quicksort with the fast worst case of heapsort, while achieving linear time on slices with certain patterns. It uses some randomization to avoid degenerate cases, but with a fixed seed to always provide deterministic behavior.","It is typically faster than stable sorting, except in a few special cases, e.g. when the slice consists of several concatenated sorted sequences."],"example":["let mut v = [-5, 4, 1, -3, 2];\n\nv.sort_unstable();\nassert!(v == [-5, -3, 1, 2, 4]);"]}},{"name":"pub fn sort_unstable_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering","details":{"description":["Sorts the slice with a comparator function, but may not preserve the order of equal elements.","This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate), and O(n log n) worst-case.","Current implementation","The current algorithm is based on pattern-defeating quicksort by Orson Peters, which combines the fast average case of randomized quicksort with the fast worst case of heapsort, while achieving linear time on slices with certain patterns. It uses some randomization to avoid degenerate cases, but with a fixed seed to always provide deterministic behavior.","It is typically faster than stable sorting, except in a few special cases, e.g. when the slice consists of several concatenated sorted sequences."],"example":["let mut v = [5, 4, 1, 3, 2];\nv.sort_unstable_by(|a, b| a.cmp(b));\nassert!(v == [1, 2, 3, 4, 5]);\n\n// reverse sorting\nv.sort_unstable_by(|a, b| b.cmp(a));\nassert!(v == [5, 4, 3, 2, 1]);"]}},{"name":"pub fn sort_unstable_by_key<K, F>(&mut self, f: F) where F: FnMut(&T) -> K, K: Ord","details":{"description":["Sorts the slice with a key extraction function, but may not preserve the order of equal elements.","This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate), and O(m n log(m n)) worst-case, where the key function is O(m).","Current implementation","The current algorithm is based on pattern-defeating quicksort by Orson Peters, which combines the fast average case of randomized quicksort with the fast worst case of heapsort, while achieving linear time on slices with certain patterns. It uses some randomization to avoid degenerate cases, but with a fixed seed to always provide deterministic behavior."],"example":["let mut v = [-5i32, 4, 1, -3, 2];\n\nv.sort_unstable_by_key(|k| k.abs());\nassert!(v == [1, 2, -3, 4, -5]);"]}},{"name":"pub fn rotate_left(&mut self, mid: usize)","details":{"description":["Rotates the slice in-place such that the first mid elements of the slice move to the end while the last self.len() - mid elements move to the front. After calling rotate_left, the element previously at index mid will become the first element in the slice.","Panics","This function will panic if mid is greater than the length of the slice. Note that mid == self.len() does not panic and is a no-op rotation.","Complexity","Takes linear (in self.len()) time."],"example":["let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\na.rotate_left(2);\nassert_eq!(a, ['c', 'd', 'e', 'f', 'a', 'b']);","Rotating a subslice:","let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\na[1..5].rotate_left(1);\nassert_eq!(a, ['a', 'c', 'd', 'e', 'b', 'f']);"]}},{"name":"pub fn rotate_right(&mut self, k: usize)","details":{"description":["Rotates the slice in-place such that the first self.len() - k elements of the slice move to the end while the last k elements move to the front. After calling rotate_right, the element previously at index self.len() - k will become the first element in the slice.","Panics","This function will panic if k is greater than the length of the slice. Note that k == self.len() does not panic and is a no-op rotation.","Complexity","Takes linear (in self.len()) time."],"example":["let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\na.rotate_right(2);\nassert_eq!(a, ['e', 'f', 'a', 'b', 'c', 'd']);","Rotate a subslice:","let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\na[1..5].rotate_right(1);\nassert_eq!(a, ['a', 'e', 'b', 'c', 'd', 'f']);"]}},{"name":"pub fn clone_from_slice(&mut self, src: &[T]) where T: Clone","details":{"description":["Copies the elements from src into self.","The length of src must be the same as self.","If src implements Copy, it can be more performant to use copy_from_slice.","Panics","This function will panic if the two slices have different lengths."],"example":["Cloning two elements from a slice into another:","let src = [1, 2, 3, 4];\nlet mut dst = [0, 0];\n\n// Because the slices have to be the same length,\n// we slice the source slice from four elements\n// to two. It will panic if we don't do this.\ndst.clone_from_slice(&src[2..]);\n\nassert_eq!(src, [1, 2, 3, 4]);\nassert_eq!(dst, [3, 4]);","Rust enforces that there can only be one mutable reference with no\nimmutable references to a particular piece of data in a particular\nscope. Because of this, attempting to use clone_from_slice on a\nsingle slice will result in a compile failure:","ⓘThis example deliberately fails to compile","let mut slice = [1, 2, 3, 4, 5];\n\nslice[..2].clone_from_slice(&slice[3..]); // compile fail!","To work around this, we can use split_at_mut to create two distinct\nsub-slices from a slice:","let mut slice = [1, 2, 3, 4, 5];\n\n{\n    let (left, right) = slice.split_at_mut(2);\n    left.clone_from_slice(&right[1..]);\n}\n\nassert_eq!(slice, [4, 5, 3, 4, 5]);"]}},{"name":"pub fn copy_from_slice(&mut self, src: &[T]) where T: Copy","details":{"description":["Copies all elements from src into self, using a memcpy.","The length of src must be the same as self.","If src does not implement Copy, use clone_from_slice.","Panics","This function will panic if the two slices have different lengths."],"example":["Copying two elements from a slice into another:","let src = [1, 2, 3, 4];\nlet mut dst = [0, 0];\n\n// Because the slices have to be the same length,\n// we slice the source slice from four elements\n// to two. It will panic if we don't do this.\ndst.copy_from_slice(&src[2..]);\n\nassert_eq!(src, [1, 2, 3, 4]);\nassert_eq!(dst, [3, 4]);","Rust enforces that there can only be one mutable reference with no\nimmutable references to a particular piece of data in a particular\nscope. Because of this, attempting to use copy_from_slice on a\nsingle slice will result in a compile failure:","ⓘThis example deliberately fails to compile","let mut slice = [1, 2, 3, 4, 5];\n\nslice[..2].copy_from_slice(&slice[3..]); // compile fail!","To work around this, we can use split_at_mut to create two distinct\nsub-slices from a slice:","let mut slice = [1, 2, 3, 4, 5];\n\n{\n    let (left, right) = slice.split_at_mut(2);\n    left.copy_from_slice(&right[1..]);\n}\n\nassert_eq!(slice, [4, 5, 3, 4, 5]);"]}},{"name":"pub fn swap_with_slice(&mut self, other: &mut [T])","details":{"description":["Swaps all elements in self with those in other.","The length of other must be the same as self.","Panics","This function will panic if the two slices have different lengths.","Example","Swapping two elements across slices:","let mut slice1 = [0, 0]; let mut slice2 = [1, 2, 3, 4]; slice1.swap_with_slice(&mut slice2[2..]); assert_eq!(slice1, [3, 4]); assert_eq!(slice2, [1, 2, 0, 0]);","Rust enforces that there can only be one mutable reference to a particular piece of data in a particular scope. Because of this, attempting to use swap_with_slice on a single slice will result in a compile failure:","ⓘThis example deliberately fails to compile","let mut slice = [1, 2, 3, 4, 5]; slice[..2].swap_with_slice(&mut slice[3..]); // compile fail!","To work around this, we can use split_at_mut to create two distinct mutable sub-slices from a slice:","let mut slice = [1, 2, 3, 4, 5]; { let (left, right) = slice.split_at_mut(2); left.swap_with_slice(&mut right[1..]); } assert_eq!(slice, [4, 5, 3, 1, 2]);"]}},{"name":"pub unsafe fn align_to<U>(&self) -> (&[T], &[U], &[T])","details":{"description":["Transmute the slice to a slice of another type, ensuring alignment of the types is maintained.","This method splits the slice into three distinct slices: prefix, correctly aligned middle slice of a new type, and the suffix slice. The method does a best effort to make the middle slice the greatest length possible for a given type and input slice, but only your algorithm's performance should depend on that, not its correctness.","This method has no purpose when either input element T or output element U are zero-sized and will return the original slice without splitting anything.","Unsafety","This method is essentially a transmute with respect to the elements in the returned middle slice, so all the usual caveats pertaining to transmute::<T, U> also apply here."],"example":["Basic usage:","unsafe {\n    let bytes: [u8; 7] = [1, 2, 3, 4, 5, 6, 7];\n    let (prefix, shorts, suffix) = bytes.align_to::<u16>();\n    // less_efficient_algorithm_for_bytes(prefix);\n    // more_efficient_algorithm_for_aligned_shorts(shorts);\n    // less_efficient_algorithm_for_bytes(suffix);\n}"]}},{"name":"pub unsafe fn align_to_mut<U>(&mut self) -> (&mut [T], &mut [U], &mut [T])","details":{"description":["Transmute the slice to a slice of another type, ensuring alignment of the types is maintained.","This method splits the slice into three distinct slices: prefix, correctly aligned middle slice of a new type, and the suffix slice. The method does a best effort to make the middle slice the greatest length possible for a given type and input slice, but only your algorithm's performance should depend on that, not its correctness.","This method has no purpose when either input element T or output element U are zero-sized and will return the original slice without splitting anything.","Unsafety","This method is essentially a transmute with respect to the elements in the returned middle slice, so all the usual caveats pertaining to transmute::<T, U> also apply here."],"example":["Basic usage:","unsafe {\n    let mut bytes: [u8; 7] = [1, 2, 3, 4, 5, 6, 7];\n    let (prefix, shorts, suffix) = bytes.align_to_mut::<u16>();\n    // less_efficient_algorithm_for_bytes(prefix);\n    // more_efficient_algorithm_for_aligned_shorts(shorts);\n    // less_efficient_algorithm_for_bytes(suffix);\n}"]}},{"name":"pub fn is_ascii(&self) -> bool","details":{"description":["Checks if all bytes in this slice are within the ASCII range."]}},{"name":"pub fn eq_ignore_ascii_case(&self, other: &[u8]) -> bool","details":{"description":["Checks that two slices are an ASCII case-insensitive match.","Same as to_ascii_lowercase(a) == to_ascii_lowercase(b), but without allocating and copying temporaries."]}},{"name":"pub fn make_ascii_uppercase(&mut self)","details":{"description":["Converts this slice to its ASCII upper case equivalent in-place.","ASCII letters 'a' to 'z' are mapped to 'A' to 'Z', but non-ASCII letters are unchanged.","To return a new uppercased value without modifying the existing one, use to_ascii_uppercase."]}},{"name":"pub fn make_ascii_lowercase(&mut self)","details":{"description":["Converts this slice to its ASCII lower case equivalent in-place.","ASCII letters 'A' to 'Z' are mapped to 'a' to 'z', but non-ASCII letters are unchanged.","To return a new lowercased value without modifying the existing one, use to_ascii_lowercase."]}},{"name":"pub fn sort(&mut self) where T: Ord","details":{"description":["Sorts the slice.","This sort is stable (i.e. does not reorder equal elements) and O(n log n) worst-case.","When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn't allocate auxiliary memory. See sort_unstable.","Current implementation","The current algorithm is an adaptive, iterative merge sort inspired by timsort. It is designed to be very fast in cases where the slice is nearly sorted, or consists of two or more sorted sequences concatenated one after another.","Also, it allocates temporary storage half the size of self, but for short slices a non-allocating insertion sort is used instead."],"example":["let mut v = [-5, 4, 1, -3, 2];\n\nv.sort();\nassert!(v == [-5, -3, 1, 2, 4]);"]}},{"name":"pub fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering","details":{"description":["Sorts the slice with a comparator function.","This sort is stable (i.e. does not reorder equal elements) and O(n log n) worst-case.","When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn't allocate auxiliary memory. See sort_unstable_by.","Current implementation","The current algorithm is an adaptive, iterative merge sort inspired by timsort. It is designed to be very fast in cases where the slice is nearly sorted, or consists of two or more sorted sequences concatenated one after another.","Also, it allocates temporary storage half the size of self, but for short slices a non-allocating insertion sort is used instead."],"example":["let mut v = [5, 4, 1, 3, 2];\nv.sort_by(|a, b| a.cmp(b));\nassert!(v == [1, 2, 3, 4, 5]);\n\n// reverse sorting\nv.sort_by(|a, b| b.cmp(a));\nassert!(v == [5, 4, 3, 2, 1]);"]}},{"name":"pub fn sort_by_key<K, F>(&mut self, f: F) where F: FnMut(&T) -> K, K: Ord","details":{"description":["Sorts the slice with a key extraction function.","This sort is stable (i.e. does not reorder equal elements) and O(m n log(m n)) worst-case, where the key function is O(m).","When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn't allocate auxiliary memory. See sort_unstable_by_key.","Current implementation","The current algorithm is an adaptive, iterative merge sort inspired by timsort. It is designed to be very fast in cases where the slice is nearly sorted, or consists of two or more sorted sequences concatenated one after another.","Also, it allocates temporary storage half the size of self, but for short slices a non-allocating insertion sort is used instead."],"example":["let mut v = [-5i32, 4, 1, -3, 2];\n\nv.sort_by_key(|k| k.abs());\nassert!(v == [1, 2, -3, 4, -5]);"]}},{"name":"pub fn sort_by_cached_key<K, F>(&mut self, f: F) where F: FnMut(&T) -> K, K: Ord","stability":["🔬 This is a nightly-only experimental API.  (slice_sort_by_cached_key #34447)"]},{"name":"pub fn to_vec(&self) -> Vec<T> where T: Clone","details":{"description":["Copies self into a new Vec."],"example":["let s = [10, 40, 30];\nlet x = s.to_vec();\n// Here, `s` and `x` can be modified independently."]}},{"name":"pub fn into_vec(self: Box<[T]>) -> Vec<T>","details":{"description":["Converts self into a vector without clones or allocation.","The resulting vector can be converted back into a box via Vec<T>'s into_boxed_slice method."],"example":["let s: Box<[i32]> = Box::new([10, 40, 30]);\nlet x = s.into_vec();\n// `s` cannot be used anymore because it has been converted into `x`.\n\nassert_eq!(x, vec![10, 40, 30]);"]}},{"name":"pub fn repeat(&self, n: usize) -> Vec<T> where T: Copy","stability":["🔬 This is a nightly-only experimental API.  (repeat_generic_slice #48784)it's on str, why not on slice?\n"]},{"name":"pub fn to_ascii_uppercase(&self) -> Vec<u8>","details":{"description":["Returns a vector containing a copy of this slice where each byte is mapped to its ASCII upper case equivalent.","ASCII letters 'a' to 'z' are mapped to 'A' to 'Z', but non-ASCII letters are unchanged.","To uppercase the value in-place, use make_ascii_uppercase."]}},{"name":"pub fn to_ascii_lowercase(&self) -> Vec<u8>","details":{"description":["Returns a vector containing a copy of this slice where each byte is mapped to its ASCII lower case equivalent.","ASCII letters 'A' to 'Z' are mapped to 'a' to 'z', but non-ASCII letters are unchanged.","To lowercase the value in-place, use make_ascii_lowercase."]}}]}