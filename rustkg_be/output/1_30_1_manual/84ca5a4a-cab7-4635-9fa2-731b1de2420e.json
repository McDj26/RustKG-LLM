{"stability":{"stable since":"1.0.0"},"apiName":"std::iter::DoubleEndedIterator","apiType":"trait","apiDocumentation":{"apiDescription":["An iterator able to yield elements from both ends.","Something that implements DoubleEndedIterator has one extra capability over something that implements Iterator: the ability to also take Items from the back, as well as the front.","It is important to note that both back and forth work on the same range, and do not cross: iteration is over when they meet in the middle.","In a similar fashion to the Iterator protocol, once a DoubleEndedIterator returns None from a next_back(), calling it again may or may not ever return Some again. next() and next_back() are interchangeable for this purpose."],"examples":["Basic usage:","let numbers = vec![1, 2, 3, 4, 5, 6];\n\nlet mut iter = numbers.iter();\n\nassert_eq!(Some(&1), iter.next());\nassert_eq!(Some(&6), iter.next_back());\nassert_eq!(Some(&5), iter.next_back());\nassert_eq!(Some(&2), iter.next());\nassert_eq!(Some(&3), iter.next());\nassert_eq!(Some(&4), iter.next());\nassert_eq!(None, iter.next());\nassert_eq!(None, iter.next_back());"]},"trait required methods":[{"name":"fn next_back(&mut self) -> Option<Self::Item>","details":{"description":"Removes and returns an element from the end of the iterator.","example":["Basic usage:","let numbers = vec![1, 2, 3, 4, 5, 6];\n\nlet mut iter = numbers.iter();\n\nassert_eq!(Some(&1), iter.next());\nassert_eq!(Some(&6), iter.next_back());\nassert_eq!(Some(&5), iter.next_back());\nassert_eq!(Some(&2), iter.next());\nassert_eq!(Some(&3), iter.next());\nassert_eq!(Some(&4), iter.next());\nassert_eq!(None, iter.next());\nassert_eq!(None, iter.next_back());"]}}],"trait provided methods":[{"name":"fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R where F: FnMut(B, Self::Item) -> R, R: Try<Ok = B>","details":{"description":"This is the reverse version of try_fold(): it takes elements\nstarting from the back of the iterator.","example":["Basic usage:","let a = [\"1\", \"2\", \"3\"];\nlet sum = a.iter()\n    .map(|&s| s.parse::<i32>())\n    .try_rfold(0, |acc, x| x.and_then(|y| Ok(acc + y)));\nassert_eq!(sum, Ok(6));","Short-circuiting:","let a = [\"1\", \"rust\", \"3\"];\nlet mut it = a.iter();\nlet sum = it\n    .by_ref()\n    .map(|&s| s.parse::<i32>())\n    .try_rfold(0, |acc, x| x.and_then(|y| Ok(acc + y)));\nassert!(sum.is_err());\n\n// Because it short-circuited, the remaining elements are still\n// available through the iterator.\nassert_eq!(it.next_back(), Some(&\"1\"));"]}},{"name":"fn rfold<B, F>(self, accum: B, f: F) -> B where F: FnMut(B, Self::Item) -> B","details":{"description":"An iterator method that reduces the iterator's elements to a single,\nfinal value, starting from the back.","example":["Basic usage:","let a = [1, 2, 3];\n\n// the sum of all of the elements of a\nlet sum = a.iter()\n           .rfold(0, |acc, &x| acc + x);\n\nassert_eq!(sum, 6);","This example builds a string, starting with an initial value\nand continuing with each element from the back until the front:","let numbers = [1, 2, 3, 4, 5];\n\nlet zero = \"0\".to_string();\n\nlet result = numbers.iter().rfold(zero, |acc, &x| {\n    format!(\"({} + {})\", x, acc)\n});\n\nassert_eq!(result, \"(1 + (2 + (3 + (4 + (5 + 0)))))\");"]}},{"name":"fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item> where P: FnMut(&Self::Item) -> bool","details":{"description":"Searches for an element of an iterator from the back that satisfies a predicate.","example":["Basic usage:","let a = [1, 2, 3];\n\nassert_eq!(a.iter().rfind(|&&x| x == 2), Some(&2));\n\nassert_eq!(a.iter().rfind(|&&x| x == 5), None);","Stopping at the first true:","let a = [1, 2, 3];\n\nlet mut iter = a.iter();\n\nassert_eq!(iter.rfind(|&&x| x == 2), Some(&2));\n\n// we can still use `iter`, as there are more elements.\nassert_eq!(iter.next_back(), Some(&1));"]}}]}