{"stability":{"unstable":"ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"},"apiName":"std::sync::atomic::AtomicU32","apiType":"struct","apiDocumentation":{"apiDescription":["An integer type which can be safely shared between threads.","This type has the same in-memory representation as the underlying integer type, u32. For more about the differences between atomic types and non-atomic types, please see the module-level documentation."]},"trait implementations":[{"name":"impl std::fmt::Debug for std::sync::atomic::AtomicU32","stable since":"1.0.0"},{"name":"impl std::convert::From<u32> for std::sync::atomic::AtomicU32","stable since":"1.0.0"},{"name":"impl std::marker::Sync for std::sync::atomic::AtomicU32","stable since":"1.0.0"},{"name":"impl std::default::Default for std::sync::atomic::AtomicU32","stable since":"1.0.0"},{"name":"impl std::panic::RefUnwindSafe for std::sync::atomic::AtomicU32","stable since":"1.0.0"},{"name":"impl std::marker::Send for std::sync::atomic::AtomicU32","stable since":"1.0.0"}],"methods":[{"name":"pub const fn new(v: u32) -> AtomicU32","stability":["ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"]},{"name":"pub fn get_mut(&mut self) -> &mut u32","stability":["ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"]},{"name":"pub fn into_inner(self) -> u32","stability":["ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"]},{"name":"pub fn load(&self, order: Ordering) -> u32","stability":["ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"]},{"name":"pub fn store(&self, val: u32, order: Ordering)","stability":["ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"]},{"name":"pub fn swap(&self, val: u32, order: Ordering) -> u32","stability":["ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"]},{"name":"pub fn compare_and_swap(&self, current: u32, new: u32, order: Ordering) -> u32","stability":["ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"]},{"name":"pub fn compare_exchange( &self, current: u32, new: u32, success: Ordering, failure: Ordering) -> Result<u32, u32>","stability":["ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"]},{"name":"pub fn compare_exchange_weak( &self, current: u32, new: u32, success: Ordering, failure: Ordering) -> Result<u32, u32>","stability":["ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"]},{"name":"pub fn fetch_add(&self, val: u32, order: Ordering) -> u32","stability":["ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"]},{"name":"pub fn fetch_sub(&self, val: u32, order: Ordering) -> u32","stability":["ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"]},{"name":"pub fn fetch_and(&self, val: u32, order: Ordering) -> u32","stability":["ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"]},{"name":"pub fn fetch_nand(&self, val: u32, order: Ordering) -> u32","stability":["ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"]},{"name":"pub fn fetch_or(&self, val: u32, order: Ordering) -> u32","stability":["ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"]},{"name":"pub fn fetch_xor(&self, val: u32, order: Ordering) -> u32","stability":["ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"]},{"name":"pub fn fetch_update<F>( &self, f: F, fetch_order: Ordering, set_order: Ordering) -> Result<u32, u32> where F: FnMut(u32) -> Option<u32>","stability":["ðŸ”¬ This is a nightly-only experimental API.  (no_more_cas #48655)no more CAS loops in user code\n"]},{"name":"pub fn fetch_max(&self, val: u32, order: Ordering) -> u32","stability":["ðŸ”¬ This is a nightly-only experimental API.  (atomic_min_max #48655)easier and faster min/max than writing manual CAS loop\n"]},{"name":"pub fn fetch_min(&self, val: u32, order: Ordering) -> u32","stability":["ðŸ”¬ This is a nightly-only experimental API.  (atomic_min_max #48655)easier and faster min/max than writing manual CAS loop\n"]}]}