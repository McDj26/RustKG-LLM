{"stability":{"stable since":"1.0.0"},"apiName":"std::cell::RefCell","apiType":"struct","apiDocumentation":{"apiDescription":["A mutable memory location with dynamically checked borrow rules","See the module-level documentation for more."]},"trait implementations":[{"name":"impl<T> std::clone::Clone for std::cell::RefCell<T> where T: std::clone::Clone","stable since":"1.0.0"},{"name":"impl<T> std::cmp::PartialOrd<std::cell::RefCell<T>> for std::cell::RefCell<T> where T: std::cmp::PartialOrd<T> + ?std::marker::Sized","stable since":"1.10.0"},{"name":"impl<T> std::cmp::Ord for std::cell::RefCell<T> where T: std::cmp::Ord + ?std::marker::Sized","stable since":"1.10.0"},{"name":"impl<T> std::fmt::Debug for std::cell::RefCell<T> where T: std::fmt::Debug + ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::cmp::Eq for std::cell::RefCell<T> where T: std::cmp::Eq + ?std::marker::Sized","stable since":"1.2.0"},{"name":"impl<T, U> std::ops::CoerceUnsized<std::cell::RefCell<U>> for std::cell::RefCell<T> where T: std::ops::CoerceUnsized<U>","stable since":"1.0.0"},{"name":"impl<T> std::cmp::PartialEq<std::cell::RefCell<T>> for std::cell::RefCell<T> where T: std::cmp::PartialEq<T> + ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::convert::From<T> for std::cell::RefCell<T>","stable since":"1.12.0"},{"name":"impl<T> !std::marker::Sync for std::cell::RefCell<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::default::Default for std::cell::RefCell<T> where T: std::default::Default","stable since":"1.0.0"},{"name":"impl<T> std::marker::Send for std::cell::RefCell<T> where T: std::marker::Send + ?std::marker::Sized","stable since":"1.0.0"}],"methods":[{"name":"pub const fn new(value: T) -> RefCell<T>","details":{"description":["Creates a new RefCell containing value."],"example":["use std::cell::RefCell;\n\nlet c = RefCell::new(5);"]}},{"name":"pub fn into_inner(self) -> T","details":{"description":["Consumes the RefCell, returning the wrapped value."],"example":["use std::cell::RefCell;\n\nlet c = RefCell::new(5);\n\nlet five = c.into_inner();"]}},{"name":"pub fn replace(&self, t: T) -> T","details":{"description":["Replaces the wrapped value with a new one, returning the old value, without deinitializing either one.","This function corresponds to std::mem::replace.","Panics","Panics if the value is currently borrowed."],"example":["use std::cell::RefCell;\nlet cell = RefCell::new(5);\nlet old_value = cell.replace(6);\nassert_eq!(old_value, 5);\nassert_eq!(cell, RefCell::new(6));"]}},{"name":"pub fn replace_with<F>(&self, f: F) -> T where F: FnOnce(&mut T) -> T","stability":["ðŸ”¬ This is a nightly-only experimental API.  (refcell_replace_swap #43570)"]},{"name":"pub fn swap(&self, other: &RefCell<T>)","details":{"description":["Swaps the wrapped value of self with the wrapped value of other, without deinitializing either one.","This function corresponds to std::mem::swap.","Panics","Panics if the value in either RefCell is currently borrowed."],"example":["use std::cell::RefCell;\nlet c = RefCell::new(5);\nlet d = RefCell::new(6);\nc.swap(&d);\nassert_eq!(c, RefCell::new(6));\nassert_eq!(d, RefCell::new(5));"]}},{"name":"pub fn borrow(&self) -> Ref<T>","details":{"description":["Immutably borrows the wrapped value.","The borrow lasts until the returned Ref exits scope. Multiple immutable borrows can be taken out at the same time.","Panics","Panics if the value is currently mutably borrowed. For a non-panicking variant, use try_borrow."],"example":["use std::cell::RefCell;\n\nlet c = RefCell::new(5);\n\nlet borrowed_five = c.borrow();\nlet borrowed_five2 = c.borrow();","An example of panic:","use std::cell::RefCell;\nuse std::thread;\n\nlet result = thread::spawn(move || {\n   let c = RefCell::new(5);\n   let m = c.borrow_mut();\n\n   let b = c.borrow(); // this causes a panic\n}).join();\n\nassert!(result.is_err());"]}},{"name":"pub fn try_borrow(&self) -> Result<Ref<T>, BorrowError>","details":{"description":["Immutably borrows the wrapped value, returning an error if the value is currently mutably borrowed.","The borrow lasts until the returned Ref exits scope. Multiple immutable borrows can be taken out at the same time.","This is the non-panicking variant of borrow."],"example":["use std::cell::RefCell;\n\nlet c = RefCell::new(5);\n\n{\n    let m = c.borrow_mut();\n    assert!(c.try_borrow().is_err());\n}\n\n{\n    let m = c.borrow();\n    assert!(c.try_borrow().is_ok());\n}"]}},{"name":"pub fn borrow_mut(&self) -> RefMut<T>","details":{"description":["Mutably borrows the wrapped value.","The borrow lasts until the returned RefMut or all RefMuts derived from it exit scope. The value cannot be borrowed while this borrow is active.","Panics","Panics if the value is currently borrowed. For a non-panicking variant, use try_borrow_mut."],"example":["use std::cell::RefCell;\n\nlet c = RefCell::new(5);\n\n*c.borrow_mut() = 7;\n\nassert_eq!(*c.borrow(), 7);","An example of panic:","use std::cell::RefCell;\nuse std::thread;\n\nlet result = thread::spawn(move || {\n   let c = RefCell::new(5);\n   let m = c.borrow();\n\n   let b = c.borrow_mut(); // this causes a panic\n}).join();\n\nassert!(result.is_err());"]}},{"name":"pub fn try_borrow_mut(&self) -> Result<RefMut<T>, BorrowMutError>","details":{"description":["Mutably borrows the wrapped value, returning an error if the value is currently borrowed.","The borrow lasts until the returned RefMut or all RefMuts derived from it exit scope. The value cannot be borrowed while this borrow is active.","This is the non-panicking variant of borrow_mut."],"example":["use std::cell::RefCell;\n\nlet c = RefCell::new(5);\n\n{\n    let m = c.borrow();\n    assert!(c.try_borrow_mut().is_err());\n}\n\nassert!(c.try_borrow_mut().is_ok());"]}},{"name":"pub fn as_ptr(&self) -> *mut T","details":{"description":["Returns a raw pointer to the underlying data in this cell."],"example":["use std::cell::RefCell;\n\nlet c = RefCell::new(5);\n\nlet ptr = c.as_ptr();"]}},{"name":"pub fn get_mut(&mut self) -> &mut T","details":{"description":["Returns a mutable reference to the underlying data.","This call borrows RefCell mutably (at compile-time) so there is no need for dynamic checks.","However be cautious: this method expects self to be mutable, which is generally not the case when using a RefCell. Take a look at the borrow_mut method instead if self isn't mutable.","Also, please be aware that this method is only for special circumstances and is usually not what you want. In case of doubt, use borrow_mut instead."],"example":["use std::cell::RefCell;\n\nlet mut c = RefCell::new(5);\n*c.get_mut() += 1;\n\nassert_eq!(c, RefCell::new(6));"]}}]}