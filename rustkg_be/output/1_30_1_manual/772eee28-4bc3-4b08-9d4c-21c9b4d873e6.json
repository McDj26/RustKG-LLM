{"stability":{"stable since":"1.0.0"},"apiName":"std::sync::Barrier","apiType":"struct","apiDocumentation":{"apiDescription":["A barrier enables multiple threads to synchronize the beginning of some computation."],"examples":["use std::sync::{Arc, Barrier};\nuse std::thread;\n\nlet mut handles = Vec::with_capacity(10);\nlet barrier = Arc::new(Barrier::new(10));\nfor _ in 0..10 {\n    let c = barrier.clone();\n    // The same messages will be printed together.\n    // You will NOT see any interleaving.\n    handles.push(thread::spawn(move|| {\n        println!(\"before wait\");\n        c.wait();\n        println!(\"after wait\");\n    }));\n}\n// Wait for other threads to finish.\nfor handle in handles {\n    handle.join().unwrap();\n}"]},"trait implementations":[{"name":"impl std::fmt::Debug for std::sync::Barrier","stable since":"1.16.0"},{"name":"impl std::marker::Send for std::sync::Barrier","stable since":"1.0.0"},{"name":"impl std::marker::Sync for std::sync::Barrier","stable since":"1.0.0"}],"methods":[{"name":"pub fn new(n: usize) -> Barrier","details":{"description":["Creates a new barrier that can block a given number of threads.","A barrier will block n-1 threads which call wait and then wake up all threads at once when the nth thread calls wait."],"example":["use std::sync::Barrier;\n\nlet barrier = Barrier::new(10);"]}},{"name":"pub fn wait(&self) -> BarrierWaitResult","details":{"description":["Blocks the current thread until all threads have rendezvoused here.","Barriers are re-usable after all threads have rendezvoused once, and can be used continuously.","A single (arbitrary) thread will receive a BarrierWaitResult that returns true from is_leader when returning from this function, and all other threads will receive a result that will return false from is_leader."],"example":["use std::sync::{Arc, Barrier};\nuse std::thread;\n\nlet mut handles = Vec::with_capacity(10);\nlet barrier = Arc::new(Barrier::new(10));\nfor _ in 0..10 {\n    let c = barrier.clone();\n    // The same messages will be printed together.\n    // You will NOT see any interleaving.\n    handles.push(thread::spawn(move|| {\n        println!(\"before wait\");\n        c.wait();\n        println!(\"after wait\");\n    }));\n}\n// Wait for other threads to finish.\nfor handle in handles {\n    handle.join().unwrap();\n}"]}}]}