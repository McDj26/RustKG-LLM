{"stability":{"stable since":"1.4.0"},"apiName":"std::thread::park_timeout","apiType":"function","apiDocumentation":{"apiDescription":["Blocks unless or until the current thread's token is made available or the specified duration has been reached (may wake spuriously).","The semantics of this function are equivalent to park except that the thread will be blocked for roughly no longer than dur. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely dur long.","See the park documentation for more details.","Platform-specific behavior","Platforms which do not support nanosecond precision for sleeping will have dur rounded up to the nearest granularity of time they can sleep for."],"examples":["Waiting for the complete expiration of the timeout:","use std::thread::park_timeout;\nuse std::time::{Instant, Duration};\n\nlet timeout = Duration::from_secs(2);\nlet beginning_park = Instant::now();\n\nlet mut timeout_remaining = timeout;\nloop {\n    park_timeout(timeout_remaining);\n    let elapsed = beginning_park.elapsed();\n    if elapsed >= timeout {\n        break;\n    }\n    println!(\"restarting park_timeout after {:?}\", elapsed);\n    timeout_remaining = timeout - elapsed;\n}"]}}