{"stability":{"stable since":"1.0.0"},"apiName":"std::ffi::CStr","apiType":"struct","apiDocumentation":{"apiDescription":["Representation of a borrowed C string.","This type represents a borrowed reference to a nul-terminated array of bytes. It can be constructed safely from a &[u8] slice, or unsafely from a raw *const c_char. It can then be converted to a Rust &str by performing UTF-8 validation, or into an owned CString.","&CStr is to CString as &str is to String: the former in each pair are borrowed references; the latter are owned strings.","Note that this structure is not repr(C) and is not recommended to be placed in the signatures of FFI functions. Instead, safe wrappers of FFI functions may leverage the unsafe from_ptr constructor to provide a safe interface to other consumers."],"examples":["Inspecting a foreign C string:","ⓘThis example is not tested","use std::ffi::CStr;\nuse std::os::raw::c_char;\n\nextern { fn my_string() -> *const c_char; }\n\nunsafe {\n    let slice = CStr::from_ptr(my_string());\n    println!(\"string buffer size without nul terminator: {}\", slice.to_bytes().len());\n}","Passing a Rust-originating C string:","ⓘThis example is not tested","use std::ffi::{CString, CStr};\nuse std::os::raw::c_char;\n\nfn work(data: &CStr) {\n    extern { fn work_with(data: *const c_char); }\n\n    unsafe { work_with(data.as_ptr()) }\n}\n\nlet s = CString::new(\"data data data data\").expect(\"CString::new failed\");\nwork(&s);","Converting a foreign C string into a Rust String:","ⓘThis example is not tested","use std::ffi::CStr;\nuse std::os::raw::c_char;\n\nextern { fn my_string() -> *const c_char; }\n\nfn my_string_safe() -> String {\n    unsafe {\n        CStr::from_ptr(my_string()).to_string_lossy().into_owned()\n    }\n}\n\nprintln!(\"string: {}\", my_string_safe());"]},"trait implementations":[{"name":"impl std::hash::Hash for std::ffi::CStr","stable since":"1.0.0"},{"name":"impl std::fmt::Debug for std::ffi::CStr","stable since":"1.3.0"},{"name":"impl<'a> std::default::Default for &'a std::ffi::CStr","stable since":"1.10.0"},{"name":"impl std::borrow::Borrow<std::ffi::CStr> for std::ffi::CString","stable since":"1.3.0"},{"name":"impl<'a> std::convert::From<&'a std::ffi::CStr> for std::boxed::Box<std::ffi::CStr>","stable since":"1.17.0"},{"name":"impl<'a> std::convert::From<&'a std::ffi::CStr> for std::borrow::Cow<'a, std::ffi::CStr>","stable since":"1.28.0"},{"name":"impl<'a> std::convert::From<&'a std::ffi::CStr> for std::sync::Arc<std::ffi::CStr>","stable since":"1.24.0"},{"name":"impl<'a> std::convert::From<&'a std::ffi::CStr> for std::rc::Rc<std::ffi::CStr>","stable since":"1.24.0"},{"name":"impl std::cmp::PartialEq for std::ffi::CStr","stable since":"1.0.0"},{"name":"impl std::cmp::Eq for std::ffi::CStr","stable since":"1.0.0"},{"name":"impl std::cmp::PartialOrd for std::ffi::CStr","stable since":"1.0.0"},{"name":"impl std::cmp::Ord for std::ffi::CStr","stable since":"1.0.0"},{"name":"impl std::borrow::ToOwned for std::ffi::CStr","stable since":"1.3.0"},{"name":"impl<'a> std::convert::From<&'a std::ffi::CStr> for std::ffi::CString","stable since":"1.7.0"},{"name":"impl std::convert::AsRef<std::ffi::CStr> for std::ffi::CStr","stable since":"1.7.0"},{"name":"impl std::convert::AsRef<std::ffi::CStr> for std::ffi::CString","stable since":"1.7.0"},{"name":"impl std::marker::Send for std::ffi::CStr","stable since":"1.0.0"},{"name":"impl std::marker::Sync for std::ffi::CStr","stable since":"1.0.0"}],"methods":[{"name":"pub unsafe fn from_ptr<'a>(ptr: *const c_char) -> &'a CStr","details":{"description":["Wraps a raw C string with a safe C string wrapper.","This function will wrap the provided ptr with a CStr wrapper, which allows inspection and interoperation of non-owned C strings. This method is unsafe for a number of reasons:","There is no guarantee to the validity of ptr. The returned lifetime is not guaranteed to be the actual lifetime of ptr. There is no guarantee that the memory pointed to by ptr contains a valid nul terminator byte at the end of the string. It is not guaranteed that the memory pointed by ptr won't change before the CStr has been destroyed.","Note: This operation is intended to be a 0-cost cast but it is currently implemented with an up-front calculation of the length of the string. This is not guaranteed to always be the case."],"example":["ⓘThis example is not tested","use std::ffi::CStr;\nuse std::os::raw::c_char;\n\nextern {\n    fn my_string() -> *const c_char;\n}\n\nunsafe {\n    let slice = CStr::from_ptr(my_string());\n    println!(\"string returned: {}\", slice.to_str().unwrap());\n}"]}},{"name":"pub fn from_bytes_with_nul(bytes: &[u8]) -> Result<&CStr, FromBytesWithNulError>","details":{"description":["Creates a C string wrapper from a byte slice.","This function will cast the provided bytes to a CStr wrapper after ensuring that the byte slice is nul-terminated and does not contain any interior nul bytes."],"example":["use std::ffi::CStr;\n\nlet cstr = CStr::from_bytes_with_nul(b\"hello\\0\");\nassert!(cstr.is_ok());","Creating a CStr without a trailing nul terminator is an error:","use std::ffi::CStr;\n\nlet c_str = CStr::from_bytes_with_nul(b\"hello\");\nassert!(c_str.is_err());","Creating a CStr with an interior nul byte is an error:","use std::ffi::CStr;\n\nlet c_str = CStr::from_bytes_with_nul(b\"he\\0llo\\0\");\nassert!(c_str.is_err());"]}},{"name":"pub unsafe fn from_bytes_with_nul_unchecked(bytes: &[u8]) -> &CStr","details":{"description":["Unsafely creates a C string wrapper from a byte slice.","This function will cast the provided bytes to a CStr wrapper without performing any sanity checks. The provided slice must be nul-terminated and not contain any interior nul bytes."],"example":["use std::ffi::{CStr, CString};\n\nunsafe {\n    let cstring = CString::new(\"hello\").expect(\"CString::new failed\");\n    let cstr = CStr::from_bytes_with_nul_unchecked(cstring.to_bytes_with_nul());\n    assert_eq!(cstr, &*cstring);\n}"]}},{"name":"pub fn as_ptr(&self) -> *const c_char","details":{"description":["Returns the inner pointer to this C string.","The returned pointer will be valid for as long as self is, and points to a contiguous region of memory terminated with a 0 byte to represent the end of the string.","WARNING","It is your responsibility to make sure that the underlying memory is not freed too early. For example, the following code will cause undefined behavior when ptr is used inside the unsafe block:","use std::ffi::{CString}; let ptr = CString::new(\"Hello\").expect(\"CString::new failed\").as_ptr(); unsafe { // `ptr` is dangling *ptr; }","This happens because the pointer returned by as_ptr does not carry any lifetime information and the CString is deallocated immediately after the CString::new(\"Hello\").expect(\"CString::new failed\").as_ptr() expression is evaluated. To fix the problem, bind the CString to a local variable:","use std::ffi::{CString}; let hello = CString::new(\"Hello\").expect(\"CString::new failed\"); let ptr = hello.as_ptr(); unsafe { // `ptr` is valid because `hello` is in scope *ptr; }","This way, the lifetime of the CString in hello encompasses the lifetime of ptr and the unsafe block."]}},{"name":"pub fn to_bytes(&self) -> &[u8]","details":{"description":["Converts this C string to a byte slice.","The returned slice will not contain the trailing nul terminator that this C string has.","Note: This method is currently implemented as a constant-time cast, but it is planned to alter its definition in the future to perform the length calculation whenever this method is called."],"example":["use std::ffi::CStr;\n\nlet c_str = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\nassert_eq!(c_str.to_bytes(), b\"foo\");"]}},{"name":"pub fn to_bytes_with_nul(&self) -> &[u8]","details":{"description":["Converts this C string to a byte slice containing the trailing 0 byte.","This function is the equivalent of to_bytes except that it will retain the trailing nul terminator instead of chopping it off.","Note: This method is currently implemented as a 0-cost cast, but it is planned to alter its definition in the future to perform the length calculation whenever this method is called."],"example":["use std::ffi::CStr;\n\nlet c_str = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\nassert_eq!(c_str.to_bytes_with_nul(), b\"foo\\0\");"]}},{"name":"pub fn to_str(&self) -> Result<&str, Utf8Error>","details":{"description":["Yields a &str slice if the CStr contains valid UTF-8.","If the contents of the CStr are valid UTF-8 data, this function will return the corresponding &str slice. Otherwise, it will return an error with details of where UTF-8 validation failed.","Note: This method is currently implemented to check for validity after a constant-time cast, but it is planned to alter its definition in the future to perform the length calculation in addition to the UTF-8 check whenever this method is called."],"example":["use std::ffi::CStr;\n\nlet c_str = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\nassert_eq!(c_str.to_str(), Ok(\"foo\"));"]}},{"name":"pub fn to_string_lossy(&self) -> Cow<str>","details":{"description":["Converts a CStr into a Cow<str>.","If the contents of the CStr are valid UTF-8 data, this function will return a Cow::Borrowed([&str]) with the the corresponding [&str] slice. Otherwise, it will replace any invalid UTF-8 sequences with U+FFFD REPLACEMENT CHARACTER and return a Cow::Owned(String) with the result.","Note: This method is currently implemented to check for validity after a constant-time cast, but it is planned to alter its definition in the future to perform the length calculation in addition to the UTF-8 check whenever this method is called."],"example":["Calling to_string_lossy on a CStr containing valid UTF-8:","use std::borrow::Cow;\nuse std::ffi::CStr;\n\nlet c_str = CStr::from_bytes_with_nul(b\"Hello World\\0\")\n                 .expect(\"CStr::from_bytes_with_nul failed\");\nassert_eq!(c_str.to_string_lossy(), Cow::Borrowed(\"Hello World\"));","Calling to_string_lossy on a CStr containing invalid UTF-8:","use std::borrow::Cow;\nuse std::ffi::CStr;\n\nlet c_str = CStr::from_bytes_with_nul(b\"Hello \\xF0\\x90\\x80World\\0\")\n                 .expect(\"CStr::from_bytes_with_nul failed\");\nassert_eq!(\n    c_str.to_string_lossy(),\n    Cow::Owned(String::from(\"Hello �World\")) as Cow<str>\n);"]}},{"name":"pub fn into_c_string(self: Box<CStr>) -> CString","details":{"description":["Converts a Box<CStr> into a CString without copying or allocating."],"example":["use std::ffi::CString;\n\nlet c_string = CString::new(b\"foo\".to_vec()).expect(\"CString::new failed\");\nlet boxed = c_string.into_boxed_c_str();\nassert_eq!(boxed.into_c_string(), CString::new(\"foo\").expect(\"CString::new failed\"));"]}}]}