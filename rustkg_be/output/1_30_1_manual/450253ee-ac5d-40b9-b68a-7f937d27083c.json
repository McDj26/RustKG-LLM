{"stability":{"stable since":"1.0.0"},"apiName":"f32","apiType":"primitive","apiDocumentation":{"apiDescription":["The 32-bit floating point type.","See also the std::f32 module."]},"trait implementations":[{"name":"impl std::ops::RemAssign<f32> for f32","stable since":"1.8.0"},{"name":"impl<'a> std::ops::RemAssign<&'a f32> for f32","stable since":"1.22.0"},{"name":"impl std::str::FromStr for f32","stable since":"1.0.0"},{"name":"impl std::ops::DivAssign<f32> for f32","stable since":"1.8.0"},{"name":"impl<'a> std::ops::DivAssign<&'a f32> for f32","stable since":"1.22.0"},{"name":"impl std::ops::MulAssign<f32> for f32","stable since":"1.8.0"},{"name":"impl<'a> std::ops::MulAssign<&'a f32> for f32","stable since":"1.22.0"},{"name":"impl<'a> std::ops::SubAssign<&'a f32> for f32","stable since":"1.22.0"},{"name":"impl std::ops::SubAssign<f32> for f32","stable since":"1.8.0"},{"name":"impl<'a> std::ops::AddAssign<&'a f32> for f32","stable since":"1.22.0"},{"name":"impl std::ops::AddAssign<f32> for f32","stable since":"1.8.0"},{"name":"impl<'a> std::ops::Neg for &'a f32","stable since":"1.0.0"},{"name":"impl std::ops::Neg for f32","stable since":"1.0.0"},{"name":"impl std::clone::Clone for f32","stable since":"1.0.0"},{"name":"impl std::cmp::PartialOrd<f32> for f32","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Sub<f32> for &'a f32","stable since":"1.0.0"},{"name":"impl std::ops::Sub<f32> for f32","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Sub<&'a f32> for &'b f32","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Sub<&'a f32> for f32","stable since":"1.0.0"},{"name":"impl std::iter::Sum<f32> for f32","stable since":"1.12.0"},{"name":"impl<'a> std::iter::Sum<&'a f32> for f32","stable since":"1.12.0"},{"name":"impl std::fmt::Debug for f32","stable since":"1.0.0"},{"name":"impl std::cmp::PartialEq<f32> for f32","stable since":"1.0.0"},{"name":"impl std::convert::From<u16> for f32","stable since":"1.6.0"},{"name":"impl std::convert::From<i8> for f32","stable since":"1.6.0"},{"name":"impl std::convert::From<i16> for f32","stable since":"1.6.0"},{"name":"impl std::convert::From<u8> for f32","stable since":"1.6.0"},{"name":"impl std::marker::Copy for f32","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Rem<&'a f32> for &'b f32","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Rem<&'a f32> for f32","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Rem<f32> for &'a f32","stable since":"1.0.0"},{"name":"impl std::ops::Rem<f32> for f32","stable since":"1.0.0"},{"name":"impl std::fmt::UpperExp for f32","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Mul<&'a f32> for &'b f32","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Mul<f32> for &'a f32","stable since":"1.0.0"},{"name":"impl std::ops::Mul<f32> for f32","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Mul<&'a f32> for f32","stable since":"1.0.0"},{"name":"impl std::default::Default for f32","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Div<&'a f32> for &'b f32","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Div<f32> for &'a f32","stable since":"1.0.0"},{"name":"impl std::ops::Div<f32> for f32","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Div<&'a f32> for f32","stable since":"1.0.0"},{"name":"impl std::fmt::LowerExp for f32","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Add<f32> for &'a f32","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Add<&'a f32> for f32","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Add<&'a f32> for &'b f32","stable since":"1.0.0"},{"name":"impl std::ops::Add<f32> for f32","stable since":"1.0.0"},{"name":"impl std::iter::Product<f32> for f32","stable since":"1.12.0"},{"name":"impl<'a> std::iter::Product<&'a f32> for f32","stable since":"1.12.0"},{"name":"impl std::fmt::Display for f32","stable since":"1.0.0"},{"name":"impl compiler_builtins::float::Float for f32","stable since":"1.0.0"},{"name":"impl std::marker::Send for f32","stable since":"1.0.0"},{"name":"impl std::marker::Sync for f32","stable since":"1.0.0"}],"methods":[{"name":"pub fn is_nan(self) -> bool","details":{"description":["Returns true if this value is NaN and false otherwise.","use std::f32; let nan = f32::NAN; let f = 7.0_f32; assert!(nan.is_nan()); assert!(!f.is_nan());"]}},{"name":"pub fn is_infinite(self) -> bool","details":{"description":["Returns true if this value is positive infinity or negative infinity and false otherwise.","use std::f32; let f = 7.0f32; let inf = f32::INFINITY; let neg_inf = f32::NEG_INFINITY; let nan = f32::NAN; assert!(!f.is_infinite()); assert!(!nan.is_infinite()); assert!(inf.is_infinite()); assert!(neg_inf.is_infinite());"]}},{"name":"pub fn is_finite(self) -> bool","details":{"description":["Returns true if this number is neither infinite nor NaN.","use std::f32; let f = 7.0f32; let inf = f32::INFINITY; let neg_inf = f32::NEG_INFINITY; let nan = f32::NAN; assert!(f.is_finite()); assert!(!nan.is_finite()); assert!(!inf.is_finite()); assert!(!neg_inf.is_finite());"]}},{"name":"pub fn is_normal(self) -> bool","details":{"description":["Returns true if the number is neither zero, infinite, subnormal, or NaN.","use std::f32; let min = f32::MIN_POSITIVE; // 1.17549435e-38f32 let max = f32::MAX; let lower_than_min = 1.0e-40_f32; let zero = 0.0_f32; assert!(min.is_normal()); assert!(max.is_normal()); assert!(!zero.is_normal()); assert!(!f32::NAN.is_normal()); assert!(!f32::INFINITY.is_normal()); // Values between `0` and `min` are Subnormal. assert!(!lower_than_min.is_normal());"]}},{"name":"pub fn classify(self) -> FpCategory","details":{"description":["Returns the floating point category of the number. If only one property is going to be tested, it is generally faster to use the specific predicate instead.","use std::num::FpCategory; use std::f32; let num = 12.4_f32; let inf = f32::INFINITY; assert_eq!(num.classify(), FpCategory::Normal); assert_eq!(inf.classify(), FpCategory::Infinite);"]}},{"name":"pub fn is_sign_positive(self) -> bool","details":{"description":["Returns true if and only if self has a positive sign, including +0.0, NaNs with positive sign bit and positive infinity.","let f = 7.0_f32; let g = -7.0_f32; assert!(f.is_sign_positive()); assert!(!g.is_sign_positive());"]}},{"name":"pub fn is_sign_negative(self) -> bool","details":{"description":["Returns true if and only if self has a negative sign, including -0.0, NaNs with negative sign bit and negative infinity.","let f = 7.0f32; let g = -7.0f32; assert!(!f.is_sign_negative()); assert!(g.is_sign_negative());"]}},{"name":"pub fn recip(self) -> f32","details":{"description":["Takes the reciprocal (inverse) of a number, 1/x.","use std::f32; let x = 2.0_f32; let abs_difference = (x.recip() - (1.0/x)).abs(); assert!(abs_difference <= f32::EPSILON);"]}},{"name":"pub fn to_degrees(self) -> f32","details":{"description":["Converts radians to degrees.","use std::f32::{self, consts}; let angle = consts::PI; let abs_difference = (angle.to_degrees() - 180.0).abs(); assert!(abs_difference <= f32::EPSILON);"]}},{"name":"pub fn to_radians(self) -> f32","details":{"description":["Converts degrees to radians.","use std::f32::{self, consts}; let angle = 180.0f32; let abs_difference = (angle.to_radians() - consts::PI).abs(); assert!(abs_difference <= f32::EPSILON);"]}},{"name":"pub fn max(self, other: f32) -> f32","details":{"description":["Returns the maximum of the two numbers.","let x = 1.0f32; let y = 2.0f32; assert_eq!(x.max(y), y);","If one of the arguments is NaN, then the other argument is returned."]}},{"name":"pub fn min(self, other: f32) -> f32","details":{"description":["Returns the minimum of the two numbers.","let x = 1.0f32; let y = 2.0f32; assert_eq!(x.min(y), x);","If one of the arguments is NaN, then the other argument is returned."]}},{"name":"pub fn to_bits(self) -> u32","details":{"description":["Raw transmutation to u32.","This is currently identical to transmute::<f32, u32>(self) on all platforms.","See from_bits for some discussion of the portability of this operation (there are almost no issues).","Note that this function is distinct from as casting, which attempts to preserve the numeric value, and not the bitwise value."],"example":["assert_ne!((1f32).to_bits(), 1f32 as u32); // to_bits() is not casting!\nassert_eq!((12.5f32).to_bits(), 0x41480000);\n"]}},{"name":"pub fn from_bits(v: u32) -> f32","details":{"description":["Raw transmutation from u32.","This is currently identical to transmute::<u32, f32>(v) on all platforms. It turns out this is incredibly portable, for two reasons:","Floats and Ints have the same endianness on all supported platforms. IEEE-754 very precisely specifies the bit layout of floats.","However there is one caveat: prior to the 2008 version of IEEE-754, how to interpret the NaN signaling bit wasn't actually specified. Most platforms (notably x86 and ARM) picked the interpretation that was ultimately standardized in 2008, but some didn't (notably MIPS). As a result, all signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.","Rather than trying to preserve signaling-ness cross-platform, this implementation favours preserving the exact bits. This means that any payloads encoded in NaNs will be preserved even if the result of this method is sent over the network from an x86 machine to a MIPS one.","If the results of this method are only manipulated by the same architecture that produced them, then there is no portability concern.","If the input isn't NaN, then there is no portability concern.","If you don't care about signalingness (very likely), then there is no portability concern.","Note that this function is distinct from as casting, which attempts to preserve the numeric value, and not the bitwise value."],"example":["use std::f32;\nlet v = f32::from_bits(0x41480000);\nlet difference = (v - 12.5).abs();\nassert!(difference <= 1e-5);"]}},{"name":"pub fn floor(self) -> f32","details":{"description":["Returns the largest integer less than or equal to a number."],"example":["let f = 3.99_f32;\nlet g = 3.0_f32;\n\nassert_eq!(f.floor(), 3.0);\nassert_eq!(g.floor(), 3.0);"]}},{"name":"pub fn ceil(self) -> f32","details":{"description":["Returns the smallest integer greater than or equal to a number."],"example":["let f = 3.01_f32;\nlet g = 4.0_f32;\n\nassert_eq!(f.ceil(), 4.0);\nassert_eq!(g.ceil(), 4.0);"]}},{"name":"pub fn round(self) -> f32","details":{"description":["Returns the nearest integer to a number. Round half-way cases away from 0.0."],"example":["let f = 3.3_f32;\nlet g = -3.3_f32;\n\nassert_eq!(f.round(), 3.0);\nassert_eq!(g.round(), -3.0);"]}},{"name":"pub fn trunc(self) -> f32","details":{"description":["Returns the integer part of a number."],"example":["let f = 3.3_f32;\nlet g = -3.7_f32;\n\nassert_eq!(f.trunc(), 3.0);\nassert_eq!(g.trunc(), -3.0);"]}},{"name":"pub fn fract(self) -> f32","details":{"description":["Returns the fractional part of a number."],"example":["use std::f32;\n\nlet x = 3.5_f32;\nlet y = -3.5_f32;\nlet abs_difference_x = (x.fract() - 0.5).abs();\nlet abs_difference_y = (y.fract() - (-0.5)).abs();\n\nassert!(abs_difference_x <= f32::EPSILON);\nassert!(abs_difference_y <= f32::EPSILON);"]}},{"name":"pub fn abs(self) -> f32","details":{"description":["Computes the absolute value of self. Returns NAN if the number is NAN."],"example":["use std::f32;\n\nlet x = 3.5_f32;\nlet y = -3.5_f32;\n\nlet abs_difference_x = (x.abs() - x).abs();\nlet abs_difference_y = (y.abs() - (-y)).abs();\n\nassert!(abs_difference_x <= f32::EPSILON);\nassert!(abs_difference_y <= f32::EPSILON);\n\nassert!(f32::NAN.abs().is_nan());"]}},{"name":"pub fn signum(self) -> f32","details":{"description":["Returns a number that represents the sign of self.","1.0 if the number is positive, +0.0 or INFINITY -1.0 if the number is negative, -0.0 or NEG_INFINITY NAN if the number is NAN"],"example":["use std::f32;\n\nlet f = 3.5_f32;\n\nassert_eq!(f.signum(), 1.0);\nassert_eq!(f32::NEG_INFINITY.signum(), -1.0);\n\nassert!(f32::NAN.signum().is_nan());"]}},{"name":"pub fn mul_add(self, a: f32, b: f32) -> f32","details":{"description":["Fused multiply-add. Computes (self * a) + b with only one rounding error, yielding a more accurate result than an unfused multiply-add.","Using mul_add can be more performant than an unfused multiply-add if the target architecture has a dedicated fma CPU instruction."],"example":["use std::f32;\n\nlet m = 10.0_f32;\nlet x = 4.0_f32;\nlet b = 60.0_f32;\n\n// 100.0\nlet abs_difference = (m.mul_add(x, b) - (m*x + b)).abs();\n\nassert!(abs_difference <= f32::EPSILON);"]}},{"name":"pub fn div_euc(self, rhs: f32) -> f32","stability":["🔬 This is a nightly-only experimental API.  (euclidean_division #49048)"]},{"name":"pub fn mod_euc(self, rhs: f32) -> f32","stability":["🔬 This is a nightly-only experimental API.  (euclidean_division #49048)"]},{"name":"pub fn powi(self, n: i32) -> f32","details":{"description":["Raises a number to an integer power.","Using this function is generally faster than using powf"],"example":["use std::f32;\n\nlet x = 2.0_f32;\nlet abs_difference = (x.powi(2) - x*x).abs();\n\nassert!(abs_difference <= f32::EPSILON);"]}},{"name":"pub fn powf(self, n: f32) -> f32","details":{"description":["Raises a number to a floating point power."],"example":["use std::f32;\n\nlet x = 2.0_f32;\nlet abs_difference = (x.powf(2.0) - x*x).abs();\n\nassert!(abs_difference <= f32::EPSILON);"]}},{"name":"pub fn sqrt(self) -> f32","details":{"description":["Takes the square root of a number.","Returns NaN if self is a negative number."],"example":["use std::f32;\n\nlet positive = 4.0_f32;\nlet negative = -4.0_f32;\n\nlet abs_difference = (positive.sqrt() - 2.0).abs();\n\nassert!(abs_difference <= f32::EPSILON);\nassert!(negative.sqrt().is_nan());"]}},{"name":"pub fn exp(self) -> f32","details":{"description":["Returns e^(self), (the exponential function)."],"example":["use std::f32;\n\nlet one = 1.0f32;\n// e^1\nlet e = one.exp();\n\n// ln(e) - 1 == 0\nlet abs_difference = (e.ln() - 1.0).abs();\n\nassert!(abs_difference <= f32::EPSILON);"]}},{"name":"pub fn exp2(self) -> f32","details":{"description":["Returns 2^(self)."],"example":["use std::f32;\n\nlet f = 2.0f32;\n\n// 2^2 - 4 == 0\nlet abs_difference = (f.exp2() - 4.0).abs();\n\nassert!(abs_difference <= f32::EPSILON);"]}},{"name":"pub fn ln(self) -> f32","details":{"description":["Returns the natural logarithm of the number."],"example":["use std::f32;\n\nlet one = 1.0f32;\n// e^1\nlet e = one.exp();\n\n// ln(e) - 1 == 0\nlet abs_difference = (e.ln() - 1.0).abs();\n\nassert!(abs_difference <= f32::EPSILON);"]}},{"name":"pub fn log(self, base: f32) -> f32","details":{"description":["Returns the logarithm of the number with respect to an arbitrary base.","The result may not be correctly rounded owing to implementation details; self.log2() can produce more accurate results for base 2, and self.log10() can produce more accurate results for base 10."],"example":["use std::f32;\n\nlet five = 5.0f32;\n\n// log5(5) - 1 == 0\nlet abs_difference = (five.log(5.0) - 1.0).abs();\n\nassert!(abs_difference <= f32::EPSILON);"]}},{"name":"pub fn log2(self) -> f32","details":{"description":["Returns the base 2 logarithm of the number."],"example":["use std::f32;\n\nlet two = 2.0f32;\n\n// log2(2) - 1 == 0\nlet abs_difference = (two.log2() - 1.0).abs();\n\nassert!(abs_difference <= f32::EPSILON);"]}},{"name":"pub fn log10(self) -> f32","details":{"description":["Returns the base 10 logarithm of the number."],"example":["use std::f32;\n\nlet ten = 10.0f32;\n\n// log10(10) - 1 == 0\nlet abs_difference = (ten.log10() - 1.0).abs();\n\nassert!(abs_difference <= f32::EPSILON);"]}},{"name":"pub fn abs_sub(self, other: f32) -> f32","stability":["Deprecated since 1.10.0: you probably meant (self - other).abs(): this operation is (self - other).max(0.0) (also known as fdimf in C). If you truly need the positive difference, consider using that expression or the C function fdimf, depending on how you wish to handle NaN (please consider filing an issue describing your use-case too).\n"]},{"name":"pub fn cbrt(self) -> f32","details":{"description":["Takes the cubic root of a number."],"example":["use std::f32;\n\nlet x = 8.0f32;\n\n// x^(1/3) - 2 == 0\nlet abs_difference = (x.cbrt() - 2.0).abs();\n\nassert!(abs_difference <= f32::EPSILON);"]}},{"name":"pub fn hypot(self, other: f32) -> f32","details":{"description":["Calculates the length of the hypotenuse of a right-angle triangle given legs of length x and y."],"example":["use std::f32;\n\nlet x = 2.0f32;\nlet y = 3.0f32;\n\n// sqrt(x^2 + y^2)\nlet abs_difference = (x.hypot(y) - (x.powi(2) + y.powi(2)).sqrt()).abs();\n\nassert!(abs_difference <= f32::EPSILON);"]}},{"name":"pub fn sin(self) -> f32","details":{"description":["Computes the sine of a number (in radians)."],"example":["use std::f32;\n\nlet x = f32::consts::PI/2.0;\n\nlet abs_difference = (x.sin() - 1.0).abs();\n\nassert!(abs_difference <= f32::EPSILON);"]}},{"name":"pub fn cos(self) -> f32","details":{"description":["Computes the cosine of a number (in radians)."],"example":["use std::f32;\n\nlet x = 2.0*f32::consts::PI;\n\nlet abs_difference = (x.cos() - 1.0).abs();\n\nassert!(abs_difference <= f32::EPSILON);"]}},{"name":"pub fn tan(self) -> f32","details":{"description":["Computes the tangent of a number (in radians)."],"example":["use std::f32;\n\nlet x = f32::consts::PI / 4.0;\nlet abs_difference = (x.tan() - 1.0).abs();\n\nassert!(abs_difference <= f32::EPSILON);"]}},{"name":"pub fn asin(self) -> f32","details":{"description":["Computes the arcsine of a number. Return value is in radians in the range [-pi/2, pi/2] or NaN if the number is outside the range [-1, 1]."],"example":["use std::f32;\n\nlet f = f32::consts::PI / 2.0;\n\n// asin(sin(pi/2))\nlet abs_difference = (f.sin().asin() - f32::consts::PI / 2.0).abs();\n\nassert!(abs_difference <= f32::EPSILON);"]}},{"name":"pub fn acos(self) -> f32","details":{"description":["Computes the arccosine of a number. Return value is in radians in the range [0, pi] or NaN if the number is outside the range [-1, 1]."],"example":["use std::f32;\n\nlet f = f32::consts::PI / 4.0;\n\n// acos(cos(pi/4))\nlet abs_difference = (f.cos().acos() - f32::consts::PI / 4.0).abs();\n\nassert!(abs_difference <= f32::EPSILON);"]}},{"name":"pub fn atan(self) -> f32","details":{"description":["Computes the arctangent of a number. Return value is in radians in the range [-pi/2, pi/2];"],"example":["use std::f32;\n\nlet f = 1.0f32;\n\n// atan(tan(1))\nlet abs_difference = (f.tan().atan() - 1.0).abs();\n\nassert!(abs_difference <= f32::EPSILON);"]}},{"name":"pub fn atan2(self, other: f32) -> f32","details":{"description":["Computes the four quadrant arctangent of self (y) and other (x) in radians.","x = 0, y = 0: 0 x >= 0: arctan(y/x) -> [-pi/2, pi/2] y >= 0: arctan(y/x) + pi -> (pi/2, pi] y < 0: arctan(y/x) - pi -> (-pi, -pi/2)"],"example":["use std::f32;\n\nlet pi = f32::consts::PI;\n// Positive angles measured counter-clockwise\n// from positive x axis\n// -pi/4 radians (45 deg clockwise)\nlet x1 = 3.0f32;\nlet y1 = -3.0f32;\n\n// 3pi/4 radians (135 deg counter-clockwise)\nlet x2 = -3.0f32;\nlet y2 = 3.0f32;\n\nlet abs_difference_1 = (y1.atan2(x1) - (-pi/4.0)).abs();\nlet abs_difference_2 = (y2.atan2(x2) - 3.0*pi/4.0).abs();\n\nassert!(abs_difference_1 <= f32::EPSILON);\nassert!(abs_difference_2 <= f32::EPSILON);"]}},{"name":"pub fn sin_cos(self) -> (f32, f32)","details":{"description":["Simultaneously computes the sine and cosine of the number, x. Returns (sin(x), cos(x))."],"example":["use std::f32;\n\nlet x = f32::consts::PI/4.0;\nlet f = x.sin_cos();\n\nlet abs_difference_0 = (f.0 - x.sin()).abs();\nlet abs_difference_1 = (f.1 - x.cos()).abs();\n\nassert!(abs_difference_0 <= f32::EPSILON);\nassert!(abs_difference_1 <= f32::EPSILON);"]}},{"name":"pub fn exp_m1(self) -> f32","details":{"description":["Returns e^(self) - 1 in a way that is accurate even if the number is close to zero."],"example":["use std::f32;\n\nlet x = 6.0f32;\n\n// e^(ln(6)) - 1\nlet abs_difference = (x.ln().exp_m1() - 5.0).abs();\n\nassert!(abs_difference <= f32::EPSILON);"]}},{"name":"pub fn ln_1p(self) -> f32","details":{"description":["Returns ln(1+n) (natural logarithm) more accurately than if the operations were performed separately."],"example":["use std::f32;\n\nlet x = f32::consts::E - 1.0;\n\n// ln(1 + (e - 1)) == ln(e) == 1\nlet abs_difference = (x.ln_1p() - 1.0).abs();\n\nassert!(abs_difference <= f32::EPSILON);"]}},{"name":"pub fn sinh(self) -> f32","details":{"description":["Hyperbolic sine function."],"example":["use std::f32;\n\nlet e = f32::consts::E;\nlet x = 1.0f32;\n\nlet f = x.sinh();\n// Solving sinh() at 1 gives `(e^2-1)/(2e)`\nlet g = (e*e - 1.0)/(2.0*e);\nlet abs_difference = (f - g).abs();\n\nassert!(abs_difference <= f32::EPSILON);"]}},{"name":"pub fn cosh(self) -> f32","details":{"description":["Hyperbolic cosine function."],"example":["use std::f32;\n\nlet e = f32::consts::E;\nlet x = 1.0f32;\nlet f = x.cosh();\n// Solving cosh() at 1 gives this result\nlet g = (e*e + 1.0)/(2.0*e);\nlet abs_difference = (f - g).abs();\n\n// Same result\nassert!(abs_difference <= f32::EPSILON);"]}},{"name":"pub fn tanh(self) -> f32","details":{"description":["Hyperbolic tangent function."],"example":["use std::f32;\n\nlet e = f32::consts::E;\nlet x = 1.0f32;\n\nlet f = x.tanh();\n// Solving tanh() at 1 gives `(1 - e^(-2))/(1 + e^(-2))`\nlet g = (1.0 - e.powi(-2))/(1.0 + e.powi(-2));\nlet abs_difference = (f - g).abs();\n\nassert!(abs_difference <= f32::EPSILON);"]}},{"name":"pub fn asinh(self) -> f32","details":{"description":["Inverse hyperbolic sine function."],"example":["use std::f32;\n\nlet x = 1.0f32;\nlet f = x.sinh().asinh();\n\nlet abs_difference = (f - x).abs();\n\nassert!(abs_difference <= f32::EPSILON);"]}},{"name":"pub fn acosh(self) -> f32","details":{"description":["Inverse hyperbolic cosine function."],"example":["use std::f32;\n\nlet x = 1.0f32;\nlet f = x.cosh().acosh();\n\nlet abs_difference = (f - x).abs();\n\nassert!(abs_difference <= f32::EPSILON);"]}},{"name":"pub fn atanh(self) -> f32","details":{"description":["Inverse hyperbolic tangent function."],"example":["use std::f32;\n\nlet e = f32::consts::E;\nlet f = e.tanh().atanh();\n\nlet abs_difference = (f - e).abs();\n\nassert!(abs_difference <= 1e-5);"]}}]}