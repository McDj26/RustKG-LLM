{"stability":{"stable since":"1.20.0"},"apiName":"std::mem::ManuallyDrop","apiType":"struct","apiDocumentation":{"apiDescription":["A wrapper to inhibit compiler from automatically calling T’s destructor.","This wrapper is 0-cost."],"examples":["This wrapper helps with explicitly documenting the drop order dependencies between fields of\nthe type:","use std::mem::ManuallyDrop;\nstruct Peach;\nstruct Banana;\nstruct Melon;\nstruct FruitBox {\n    // Immediately clear there’s something non-trivial going on with these fields.\n    peach: ManuallyDrop<Peach>,\n    melon: Melon, // Field that’s independent of the other two.\n    banana: ManuallyDrop<Banana>,\n}\n\nimpl Drop for FruitBox {\n    fn drop(&mut self) {\n        unsafe {\n            // Explicit ordering in which field destructors are run specified in the intuitive\n            // location – the destructor of the structure containing the fields.\n            // Moreover, one can now reorder fields within the struct however much they want.\n            ManuallyDrop::drop(&mut self.peach);\n            ManuallyDrop::drop(&mut self.banana);\n        }\n        // After destructor for `FruitBox` runs (this function), the destructor for Melon gets\n        // invoked in the usual manner, as it is not wrapped in `ManuallyDrop`.\n    }\n}"]},"trait implementations":[{"name":"impl<T> std::hash::Hash for std::mem::ManuallyDrop<T> where T: std::hash::Hash + ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::clone::Clone for std::mem::ManuallyDrop<T> where T: std::clone::Clone + ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::cmp::PartialOrd<std::mem::ManuallyDrop<T>> for std::mem::ManuallyDrop<T> where T: std::cmp::PartialOrd<T> + ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::cmp::Ord for std::mem::ManuallyDrop<T> where T: std::cmp::Ord + ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::fmt::Debug for std::mem::ManuallyDrop<T> where T: std::fmt::Debug + ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::cmp::Eq for std::mem::ManuallyDrop<T> where T: std::cmp::Eq + ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::cmp::PartialEq<std::mem::ManuallyDrop<T>> for std::mem::ManuallyDrop<T> where T: std::cmp::PartialEq<T> + ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::marker::Copy for std::mem::ManuallyDrop<T> where T: std::marker::Copy + ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::ops::DerefMut for std::mem::ManuallyDrop<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::default::Default for std::mem::ManuallyDrop<T> where T: std::default::Default + ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::ops::Deref for std::mem::ManuallyDrop<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T: ?std::marker::Sized> std::marker::Send for std::mem::ManuallyDrop<T> where T: std::marker::Send","stable since":"1.0.0"},{"name":"impl<T: ?std::marker::Sized> std::marker::Sync for std::mem::ManuallyDrop<T> where T: std::marker::Sync","stable since":"1.0.0"}],"methods":[{"name":"pub const fn new(value: T) -> ManuallyDrop<T>","details":{"description":["Wrap a value to be manually dropped."],"example":["use std::mem::ManuallyDrop;\nManuallyDrop::new(Box::new(()));"]}},{"name":"pub fn into_inner(slot: ManuallyDrop<T>) -> T","details":{"description":["Extract the value from the ManuallyDrop container.","This allows the value to be dropped again."],"example":["use std::mem::ManuallyDrop;\nlet x = ManuallyDrop::new(Box::new(()));\nlet _: Box<()> = ManuallyDrop::into_inner(x); // This drops the `Box`."]}},{"name":"pub unsafe fn drop(slot: &mut ManuallyDrop<T>)","details":{"description":["Manually drops the contained value.","If you have ownership of the value, you can use ManuallyDrop::into_inner instead.","Safety","This function runs the destructor of the contained value and thus the wrapped value now represents uninitialized data. It is up to the user of this method to ensure the uninitialized data is not actually used."]}}]}