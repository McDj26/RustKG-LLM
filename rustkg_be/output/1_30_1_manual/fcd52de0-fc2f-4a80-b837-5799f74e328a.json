{"stability":{"stable since":"1.0.0"},"apiName":"std::thread::LocalKey","apiType":"struct","apiDocumentation":{"apiDescription":["A thread local storage key which owns its contents.","This key uses the fastest possible implementation available to it for the target platform. It is instantiated with the thread_local! macro and the primary method is the with method.","The with method yields a reference to the contained value which cannot be sent across threads or escape the given closure.","Initialization and Destruction","Initialization is dynamically performed on the first call to with within a thread, and values that implement Drop get destructed when a thread exits. Some caveats apply, which are explained below.","A LocalKey's initializer cannot recursively depend on itself, and using a LocalKey in this way will cause the initializer to infinitely recurse on the first call to with.","Note that a \"best effort\" is made to ensure that destructors for types stored in thread local storage are run, but not all platforms can guarantee that destructors will be run for all types in thread local storage. For example, there are a number of known caveats where destructors are not run:","On Unix systems when pthread-based TLS is being used, destructors will not be run for TLS values on the main thread when it exits. Note that the application will exit immediately after the main thread exits as well. On all platforms it's possible for TLS to re-initialize other TLS slots during destruction. Some platforms ensure that this cannot happen infinitely by preventing re-initialization of any slot that has been destroyed, but not all platforms have this guard. Those platforms that do not guard typically have a synthetic limit after which point no more destructors are run. On macOS, initializing TLS during destruction of other TLS slots can sometimes cancel all destructors for the current thread, whether or not the slots have already had their destructors run or not."],"examples":["use std::cell::RefCell;\nuse std::thread;\n\nthread_local!(static FOO: RefCell<u32> = RefCell::new(1));\n\nFOO.with(|f| {\n    assert_eq!(*f.borrow(), 1);\n    *f.borrow_mut() = 2;\n});\n\n// each thread starts out with the initial value of 1\nthread::spawn(move|| {\n    FOO.with(|f| {\n        assert_eq!(*f.borrow(), 1);\n        *f.borrow_mut() = 3;\n    });\n});\n\n// we retain our original value of 2 despite the child thread\nFOO.with(|f| {\n    assert_eq!(*f.borrow(), 2);\n});"]},"trait implementations":[{"name":"impl<T: 'static> std::fmt::Debug for std::thread::LocalKey<T>","stable since":"1.16.0"},{"name":"impl<T> std::marker::Send for std::thread::LocalKey<T>","stable since":"1.0.0"},{"name":"impl<T> std::marker::Sync for std::thread::LocalKey<T>","stable since":"1.0.0"}],"methods":[{"name":"pub fn with<F, R>(&'static self, f: F) -> R where F: FnOnce(&T) -> R","details":{"description":["Acquires a reference to the value in this TLS key.","This will lazily initialize the value if this thread has not referenced this key yet.","Panics","This function will panic!() if the key currently has its destructor running, and it may panic if the destructor has previously been run for this thread."]}},{"name":"pub fn try_with<F, R>(&'static self, f: F) -> Result<R, AccessError> where F: FnOnce(&T) -> R","details":{"description":["Acquires a reference to the value in this TLS key.","This will lazily initialize the value if this thread has not referenced this key yet. If the key has been destroyed (which may happen if this is called in a destructor), this function will return an AccessError.","Panics","This function will still panic!() if the key is uninitialized and the key's initializer panics."]}}]}