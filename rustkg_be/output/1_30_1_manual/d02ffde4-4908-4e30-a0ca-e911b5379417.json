{"stability":{"stable since":"1.0.0"},"apiName":"std::sync::mpsc::SyncSender","apiType":"struct","apiDocumentation":{"apiDescription":["The sending-half of Rust's synchronous sync_channel type.","Messages can be sent through this channel with send or try_send.","send will block if there is no space in the internal buffer."],"examples":["use std::sync::mpsc::sync_channel;\nuse std::thread;\n\n// Create a sync_channel with buffer size 2\nlet (sync_sender, receiver) = sync_channel(2);\nlet sync_sender2 = sync_sender.clone();\n\n// First thread owns sync_sender\nthread::spawn(move || {\n    sync_sender.send(1).unwrap();\n    sync_sender.send(2).unwrap();\n});\n\n// Second thread owns sync_sender2\nthread::spawn(move || {\n    sync_sender2.send(3).unwrap();\n    // thread will now block since the buffer is full\n    println!(\"Thread unblocked!\");\n});\n\nlet mut msg;\n\nmsg = receiver.recv().unwrap();\nprintln!(\"message {} received\", msg);\n\n// \"Thread unblocked!\" will be printed now\n\nmsg = receiver.recv().unwrap();\nprintln!(\"message {} received\", msg);\n\nmsg = receiver.recv().unwrap();\n\nprintln!(\"message {} received\", msg);"]},"trait implementations":[{"name":"impl<T: std::marker::Send> std::marker::Send for std::sync::mpsc::SyncSender<T>","stable since":"1.0.0"},{"name":"impl<T> std::clone::Clone for std::sync::mpsc::SyncSender<T>","stable since":"1.0.0"},{"name":"impl<T> std::ops::Drop for std::sync::mpsc::SyncSender<T>","stable since":"1.0.0"},{"name":"impl<T> std::fmt::Debug for std::sync::mpsc::SyncSender<T>","stable since":"1.8.0"},{"name":"impl<T> std::marker::Sync for std::sync::mpsc::SyncSender<T> where T: std::marker::Send","stable since":"1.0.0"}],"methods":[{"name":"pub fn send(&self, t: T) -> Result<(), SendError<T>>","details":{"description":["Sends a value on this synchronous channel.","This function will block until space in the internal buffer becomes available or a receiver is available to hand off the message to.","Note that a successful send does not guarantee that the receiver will ever see the data if there is a buffer on this channel. Items may be enqueued in the internal buffer for the receiver to receive at a later time. If the buffer size is 0, however, the channel becomes a rendezvous channel and it guarantees that the receiver has indeed received the data if this function returns success.","This function will never panic, but it may return Err if the Receiver has disconnected and is no longer able to receive information."],"example":["use std::sync::mpsc::sync_channel;\nuse std::thread;\n\n// Create a rendezvous sync_channel with buffer size 0\nlet (sync_sender, receiver) = sync_channel(0);\n\nthread::spawn(move || {\n   println!(\"sending message...\");\n   sync_sender.send(1).unwrap();\n   // Thread is now blocked until the message is received\n\n   println!(\"...message received!\");\n});\n\nlet msg = receiver.recv().unwrap();\nassert_eq!(1, msg);"]}},{"name":"pub fn try_send(&self, t: T) -> Result<(), TrySendError<T>>","details":{"description":["Attempts to send a value on this channel without blocking.","This method differs from send by returning immediately if the channel's buffer is full or no receiver is waiting to acquire some data. Compared with send, this function has two failure cases instead of one (one for disconnection, one for a full buffer).","See send for notes about guarantees of whether the receiver has received the data or not if this function is successful."],"example":["use std::sync::mpsc::sync_channel;\nuse std::thread;\n\n// Create a sync_channel with buffer size 1\nlet (sync_sender, receiver) = sync_channel(1);\nlet sync_sender2 = sync_sender.clone();\n\n// First thread owns sync_sender\nthread::spawn(move || {\n    sync_sender.send(1).unwrap();\n    sync_sender.send(2).unwrap();\n    // Thread blocked\n});\n\n// Second thread owns sync_sender2\nthread::spawn(move || {\n    // This will return an error and send\n    // no message if the buffer is full\n    sync_sender2.try_send(3).is_err();\n});\n\nlet mut msg;\nmsg = receiver.recv().unwrap();\nprintln!(\"message {} received\", msg);\n\nmsg = receiver.recv().unwrap();\nprintln!(\"message {} received\", msg);\n\n// Third message may have never been sent\nmatch receiver.try_recv() {\n    Ok(msg) => println!(\"message {} received\", msg),\n    Err(_) => println!(\"the third message was never sent\"),\n}"]}}]}