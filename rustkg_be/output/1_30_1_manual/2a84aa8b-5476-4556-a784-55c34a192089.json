{"stability":{"stable since":"1.0.0"},"apiName":"std","apiType":"crate","apiDocumentation":{"apiDescription":["The Rust Standard Library","The Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the broader Rust ecosystem. It offers core types, like Vec<T> and Option<T>, library-defined operations on language primitives, standard macros, I/O and multithreading, among many other things.","std is available to all Rust crates by default, just as if each one contained an extern crate std; import at the crate root. Therefore the standard library can be accessed in use statements through the path std, as in use std::env, or in expressions through the absolute path ::std, as in ::std::env::args.","How to read this documentation","If you already know the name of what you are looking for, the fastest way to find it is to use the search bar at the top of the page.","Otherwise, you may want to jump to one of these useful sections:","std::* modules Primitive types Standard macros The Rust Prelude","If this is your first time, the documentation for the standard library is written to be casually perused. Clicking on interesting things should generally lead you to interesting places. Still, there are important bits you don't want to miss, so read on for a tour of the standard library and its documentation!","Once you are familiar with the contents of the standard library you may begin to find the verbosity of the prose distracting. At this stage in your development you may want to press the [-] button near the top of the page to collapse it into a more skimmable view.","While you are looking at that [-] button also notice the [src] button. Rust's API documentation comes with the source code and you are encouraged to read it. The standard library source is generally high quality and a peek behind the curtains is often enlightening.","What is in the standard library documentation?","First of all, The Rust Standard Library is divided into a number of focused modules, all listed further down this page. These modules are the bedrock upon which all of Rust is forged, and they have mighty names like std::slice and std::cmp. Modules' documentation typically includes an overview of the module along with examples, and are a smart place to start familiarizing yourself with the library.","Second, implicit methods on primitive types are documented here. This can be a source of confusion for two reasons:","While primitives are implemented by the compiler, the standard library implements methods directly on the primitive types (and it is the only library that does so), which are documented in the section on primitives. The standard library exports many modules with the same name as primitive types. These define additional items related to the primitive type, but not the all-important methods.","So for example there is a page for the primitive type i32 that lists all the methods that can be called on 32-bit integers (very useful), and there is a page for the module std::i32 that documents the constant values MIN and MAX (rarely useful).","Note the documentation for the primitives str and [T] (also called 'slice'). Many method calls on String and Vec<T> are actually calls to methods on str and [T] respectively, via deref coercions.","Third, the standard library defines The Rust Prelude, a small collection of items - mostly traits - that are imported into every module of every crate. The traits in the prelude are pervasive, making the prelude documentation a good entry point to learning about the library.","And finally, the standard library exports a number of standard macros, and lists them on this page (technically, not all of the standard macros are defined by the standard library - some are defined by the compiler - but they are documented here the same). Like the prelude, the standard macros are imported by default into all crates.","Contributing changes to the documentation","Check out the rust contribution guidelines here. The source for this documentation can be found on Github. To contribute changes, make sure you read the guidelines first, then submit pull-requests for your suggested changes.","Contributions are appreciated! If you see a part of the docs that can be improved, submit a PR, or chat with us first on irc.mozilla.org #rust-docs.","A Tour of The Rust Standard Library","The rest of this crate documentation is dedicated to pointing out notable features of The Rust Standard Library.","Containers and collections","The option and result modules define optional and error-handling types, Option<T> and Result<T, E>. The iter module defines Rust's iterator trait, Iterator, which works with the for loop to access collections.","The standard library exposes three common ways to deal with contiguous regions of memory:","Vec<T> - A heap-allocated vector that is resizable at runtime. [T; n] - An inline array with a fixed size at compile time. [T] - A dynamically sized slice into any other kind of contiguous storage, whether heap-allocated or not.","Slices can only be handled through some kind of pointer, and as such come in many flavors such as:","&[T] - shared slice &mut [T] - mutable slice Box<[T]> - owned slice","str, a UTF-8 string slice, is a primitive type, and the standard library defines many methods for it. Rust strs are typically accessed as immutable references: &str. Use the owned String for building and mutating strings.","For converting to strings use the format! macro, and for converting from strings use the FromStr trait.","Data may be shared by placing it in a reference-counted box or the Rc type, and if further contained in a Cell or RefCell, may be mutated as well as shared. Likewise, in a concurrent setting it is common to pair an atomically-reference-counted box, Arc, with a Mutex to get the same effect.","The collections module defines maps, sets, linked lists and other typical collection types, including the common HashMap<K, V>.","Platform abstractions and I/O","Besides basic data types, the standard library is largely concerned with abstracting over differences in common platforms, most notably Windows and Unix derivatives.","Common types of I/O, including files, TCP, UDP, are defined in the io, fs, and net modules.","The thread module contains Rust's threading abstractions. sync contains further primitive shared memory types, including atomic and mpsc, which contains the channel types for message passing."]},"children":["std::alloc","std::any","std::arch","std::ascii","std::borrow","std::boxed","std::cell","std::char","std::clone","std::cmp","std::collections","std::convert","std::default","std::env","std::error","std::f32","std::f64","std::ffi","std::fmt","std::fs","std::hash","std::hint","std::i8","std::i16","std::i32","std::i64","std::i128","std::io","std::isize","std::iter","std::marker","std::mem","std::net","std::num","std::ops","std::option","std::os","std::panic","std::path","std::prelude","std::process","std::ptr","std::rc","std::result","std::slice","std::str","std::string","std::sync","std::thread","std::time","std::u8","std::u16","std::u32","std::u64","std::u128","std::usize","std::vec","std::future","std::intrinsics","std::pin","std::raw","std::task","std::assert","std::assert_eq","std::assert_ne","std::cfg","std::column","std::compile_error","std::concat","std::debug_assert","std::debug_assert_eq","std::debug_assert_ne","std::env","std::eprint","std::eprintln","std::file","std::format","std::format_args","std::include","std::include_bytes","std::include_str","std::is_x86_feature_detected","std::line","std::module_path","std::option_env","std::panic","std::print","std::println","std::stringify","std::thread_local","std::try","std::unimplemented","std::unreachable","std::vec","std::write","std::writeln","std::await","std::concat_idents","std::is_aarch64_feature_detected","std::is_arm_feature_detected","std::is_mips64_feature_detected","std::is_mips_feature_detected","std::is_powerpc64_feature_detected","std::is_powerpc_feature_detected","std::select"]}