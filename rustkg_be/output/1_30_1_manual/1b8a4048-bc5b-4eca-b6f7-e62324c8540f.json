{"stability":{"stable since":"1.0.0"},"apiName":"std::intrinsics::copy_nonoverlapping","apiType":"function","apiDocumentation":{"apiDescription":["Copies count * size_of<T> bytes from src to dst. The source and destination may not overlap.","copy_nonoverlapping is semantically equivalent to C's memcpy.","Safety","Beyond requiring that the program must be allowed to access both regions of memory, it is Undefined Behavior for source and destination to overlap. Care must also be taken with the ownership of src and dst. This method semantically moves the values of src into dst. However it does not drop the contents of dst, or prevent the contents of src from being dropped or used."],"examples":["A safe swap function:","use std::mem;\nuse std::ptr;\n\nfn swap<T>(x: &mut T, y: &mut T) {\n    unsafe {\n        // Give ourselves some scratch space to work with\n        let mut t: T = mem::uninitialized();\n\n        // Perform the swap, `&mut` pointers never alias\n        ptr::copy_nonoverlapping(x, &mut t, 1);\n        ptr::copy_nonoverlapping(y, x, 1);\n        ptr::copy_nonoverlapping(&t, y, 1);\n\n        // y and t now point to the same thing, but we need to completely forget `t`\n        // because it's no longer relevant.\n        mem::forget(t);\n    }\n}"]}}