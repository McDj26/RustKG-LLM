{"stability":{"stable since":"1.0.0"},"apiName":"std::sync::atomic::AtomicBool","apiType":"struct","apiDocumentation":{"apiDescription":["A boolean type which can be safely shared between threads.","This type has the same in-memory representation as a bool."]},"trait implementations":[{"name":"impl std::fmt::Debug for std::sync::atomic::AtomicBool","stable since":"1.3.0"},{"name":"impl std::convert::From<bool> for std::sync::atomic::AtomicBool","stable since":"1.24.0"},{"name":"impl std::marker::Sync for std::sync::atomic::AtomicBool","stable since":"1.0.0"},{"name":"impl std::default::Default for std::sync::atomic::AtomicBool","stable since":"1.0.0"},{"name":"impl std::panic::RefUnwindSafe for std::sync::atomic::AtomicBool","stable since":"1.14.0"},{"name":"impl std::marker::Send for std::sync::atomic::AtomicBool","stable since":"1.0.0"}],"methods":[{"name":"pub const fn new(v: bool) -> AtomicBool","details":{"description":["Creates a new AtomicBool."],"example":["use std::sync::atomic::AtomicBool;\n\nlet atomic_true  = AtomicBool::new(true);\nlet atomic_false = AtomicBool::new(false);"]}},{"name":"pub fn get_mut(&mut self) -> &mut bool","details":{"description":["Returns a mutable reference to the underlying bool.","This is safe because the mutable reference guarantees that no other threads are concurrently accessing the atomic data."],"example":["use std::sync::atomic::{AtomicBool, Ordering};\n\nlet mut some_bool = AtomicBool::new(true);\nassert_eq!(*some_bool.get_mut(), true);\n*some_bool.get_mut() = false;\nassert_eq!(some_bool.load(Ordering::SeqCst), false);"]}},{"name":"pub fn into_inner(self) -> bool","details":{"description":["Consumes the atomic and returns the contained value.","This is safe because passing self by value guarantees that no other threads are concurrently accessing the atomic data."],"example":["use std::sync::atomic::AtomicBool;\n\nlet some_bool = AtomicBool::new(true);\nassert_eq!(some_bool.into_inner(), true);"]}},{"name":"pub fn load(&self, order: Ordering) -> bool","details":{"description":["Loads a value from the bool.","load takes an Ordering argument which describes the memory ordering of this operation. Possible values are SeqCst, Acquire and Relaxed.","Panics","Panics if order is Release or AcqRel."],"example":["use std::sync::atomic::{AtomicBool, Ordering};\n\nlet some_bool = AtomicBool::new(true);\n\nassert_eq!(some_bool.load(Ordering::Relaxed), true);"]}},{"name":"pub fn store(&self, val: bool, order: Ordering)","details":{"description":["Stores a value into the bool.","store takes an Ordering argument which describes the memory ordering of this operation. Possible values are SeqCst, Release and Relaxed.","Panics","Panics if order is Acquire or AcqRel."],"example":["use std::sync::atomic::{AtomicBool, Ordering};\n\nlet some_bool = AtomicBool::new(true);\n\nsome_bool.store(false, Ordering::Relaxed);\nassert_eq!(some_bool.load(Ordering::Relaxed), false);"]}},{"name":"pub fn swap(&self, val: bool, order: Ordering) -> bool","details":{"description":["Stores a value into the bool, returning the previous value.","swap takes an Ordering argument which describes the memory ordering of this operation. All ordering modes are possible. Note that using Acquire makes the store part of this operation Relaxed, and using Release makes the load part Relaxed."],"example":["use std::sync::atomic::{AtomicBool, Ordering};\n\nlet some_bool = AtomicBool::new(true);\n\nassert_eq!(some_bool.swap(false, Ordering::Relaxed), true);\nassert_eq!(some_bool.load(Ordering::Relaxed), false);"]}},{"name":"pub fn compare_and_swap( &self, current: bool, new: bool, order: Ordering) -> bool","details":{"description":["Stores a value into the bool if the current value is the same as the current value.","The return value is always the previous value. If it is equal to current, then the value was updated.","compare_and_swap also takes an Ordering argument which describes the memory ordering of this operation. Notice that even when using AcqRel, the operation might fail and hence just perform an Acquire load, but not have Release semantics. Using Acquire makes the store part of this operation Relaxed if it happens, and using Release makes the load part Relaxed."],"example":["use std::sync::atomic::{AtomicBool, Ordering};\n\nlet some_bool = AtomicBool::new(true);\n\nassert_eq!(some_bool.compare_and_swap(true, false, Ordering::Relaxed), true);\nassert_eq!(some_bool.load(Ordering::Relaxed), false);\n\nassert_eq!(some_bool.compare_and_swap(true, true, Ordering::Relaxed), false);\nassert_eq!(some_bool.load(Ordering::Relaxed), false);"]}},{"name":"pub fn compare_exchange( &self, current: bool, new: bool, success: Ordering, failure: Ordering) -> Result<bool, bool>","details":{"description":["Stores a value into the bool if the current value is the same as the current value.","The return value is a result indicating whether the new value was written and containing the previous value. On success this value is guaranteed to be equal to current.","compare_exchange takes two Ordering arguments to describe the memory ordering of this operation. The first describes the required ordering if the operation succeeds while the second describes the required ordering when the operation fails. Using Acquire as success ordering makes the store part of this operation Relaxed, and using Release makes the successful load Relaxed. The failure ordering can only be SeqCst, Acquire or Relaxed and must be equivalent to or weaker than the success ordering."],"example":["use std::sync::atomic::{AtomicBool, Ordering};\n\nlet some_bool = AtomicBool::new(true);\n\nassert_eq!(some_bool.compare_exchange(true,\n                                      false,\n                                      Ordering::Acquire,\n                                      Ordering::Relaxed),\n           Ok(true));\nassert_eq!(some_bool.load(Ordering::Relaxed), false);\n\nassert_eq!(some_bool.compare_exchange(true, true,\n                                      Ordering::SeqCst,\n                                      Ordering::Acquire),\n           Err(false));\nassert_eq!(some_bool.load(Ordering::Relaxed), false);"]}},{"name":"pub fn compare_exchange_weak( &self, current: bool, new: bool, success: Ordering, failure: Ordering) -> Result<bool, bool>","details":{"description":["Stores a value into the bool if the current value is the same as the current value.","Unlike compare_exchange, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.","compare_exchange_weak takes two Ordering arguments to describe the memory ordering of this operation. The first describes the required ordering if the operation succeeds while the second describes the required ordering when the operation fails. Using Acquire as success ordering makes the store part of this operation Relaxed, and using Release makes the successful load Relaxed. The failure ordering can only be SeqCst, Acquire or Relaxed and must be equivalent to or weaker than the success ordering."],"example":["use std::sync::atomic::{AtomicBool, Ordering};\n\nlet val = AtomicBool::new(false);\n\nlet new = true;\nlet mut old = val.load(Ordering::Relaxed);\nloop {\n    match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n        Ok(_) => break,\n        Err(x) => old = x,\n    }\n}"]}},{"name":"pub fn fetch_and(&self, val: bool, order: Ordering) -> bool","details":{"description":["Logical \"and\" with a boolean value.","Performs a logical \"and\" operation on the current value and the argument val, and sets the new value to the result.","Returns the previous value.","fetch_and takes an Ordering argument which describes the memory ordering of this operation. All ordering modes are possible. Note that using Acquire makes the store part of this operation Relaxed, and using Release makes the load part Relaxed."],"example":["use std::sync::atomic::{AtomicBool, Ordering};\n\nlet foo = AtomicBool::new(true);\nassert_eq!(foo.fetch_and(false, Ordering::SeqCst), true);\nassert_eq!(foo.load(Ordering::SeqCst), false);\n\nlet foo = AtomicBool::new(true);\nassert_eq!(foo.fetch_and(true, Ordering::SeqCst), true);\nassert_eq!(foo.load(Ordering::SeqCst), true);\n\nlet foo = AtomicBool::new(false);\nassert_eq!(foo.fetch_and(false, Ordering::SeqCst), false);\nassert_eq!(foo.load(Ordering::SeqCst), false);"]}},{"name":"pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool","details":{"description":["Logical \"nand\" with a boolean value.","Performs a logical \"nand\" operation on the current value and the argument val, and sets the new value to the result.","Returns the previous value.","fetch_nand takes an Ordering argument which describes the memory ordering of this operation. All ordering modes are possible. Note that using Acquire makes the store part of this operation Relaxed, and using Release makes the load part Relaxed."],"example":["use std::sync::atomic::{AtomicBool, Ordering};\n\nlet foo = AtomicBool::new(true);\nassert_eq!(foo.fetch_nand(false, Ordering::SeqCst), true);\nassert_eq!(foo.load(Ordering::SeqCst), true);\n\nlet foo = AtomicBool::new(true);\nassert_eq!(foo.fetch_nand(true, Ordering::SeqCst), true);\nassert_eq!(foo.load(Ordering::SeqCst) as usize, 0);\nassert_eq!(foo.load(Ordering::SeqCst), false);\n\nlet foo = AtomicBool::new(false);\nassert_eq!(foo.fetch_nand(false, Ordering::SeqCst), false);\nassert_eq!(foo.load(Ordering::SeqCst), true);"]}},{"name":"pub fn fetch_or(&self, val: bool, order: Ordering) -> bool","details":{"description":["Logical \"or\" with a boolean value.","Performs a logical \"or\" operation on the current value and the argument val, and sets the new value to the result.","Returns the previous value.","fetch_or takes an Ordering argument which describes the memory ordering of this operation. All ordering modes are possible. Note that using Acquire makes the store part of this operation Relaxed, and using Release makes the load part Relaxed."],"example":["use std::sync::atomic::{AtomicBool, Ordering};\n\nlet foo = AtomicBool::new(true);\nassert_eq!(foo.fetch_or(false, Ordering::SeqCst), true);\nassert_eq!(foo.load(Ordering::SeqCst), true);\n\nlet foo = AtomicBool::new(true);\nassert_eq!(foo.fetch_or(true, Ordering::SeqCst), true);\nassert_eq!(foo.load(Ordering::SeqCst), true);\n\nlet foo = AtomicBool::new(false);\nassert_eq!(foo.fetch_or(false, Ordering::SeqCst), false);\nassert_eq!(foo.load(Ordering::SeqCst), false);"]}},{"name":"pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool","details":{"description":["Logical \"xor\" with a boolean value.","Performs a logical \"xor\" operation on the current value and the argument val, and sets the new value to the result.","Returns the previous value.","fetch_xor takes an Ordering argument which describes the memory ordering of this operation. All ordering modes are possible. Note that using Acquire makes the store part of this operation Relaxed, and using Release makes the load part Relaxed."],"example":["use std::sync::atomic::{AtomicBool, Ordering};\n\nlet foo = AtomicBool::new(true);\nassert_eq!(foo.fetch_xor(false, Ordering::SeqCst), true);\nassert_eq!(foo.load(Ordering::SeqCst), true);\n\nlet foo = AtomicBool::new(true);\nassert_eq!(foo.fetch_xor(true, Ordering::SeqCst), true);\nassert_eq!(foo.load(Ordering::SeqCst), false);\n\nlet foo = AtomicBool::new(false);\nassert_eq!(foo.fetch_xor(false, Ordering::SeqCst), false);\nassert_eq!(foo.load(Ordering::SeqCst), false);"]}}]}