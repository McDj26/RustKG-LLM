{"stability":{"stable since":"1.17.0"},"apiName":"std::ops::Bound","apiType":"enum","apiDocumentation":{"apiDescription":["An endpoint of a range of keys."],"examples":["Bounds are range endpoints:","use std::ops::Bound::*;\nuse std::ops::RangeBounds;\n\nassert_eq!((..100).start_bound(), Unbounded);\nassert_eq!((1..12).start_bound(), Included(&1));\nassert_eq!((1..12).end_bound(), Excluded(&12));","Using a tuple of Bounds as an argument to BTreeMap::range.\nNote that in most cases, it's better to use range syntax (1..5) instead.","use std::collections::BTreeMap;\nuse std::ops::Bound::{Excluded, Included, Unbounded};\n\nlet mut map = BTreeMap::new();\nmap.insert(3, \"a\");\nmap.insert(5, \"b\");\nmap.insert(8, \"c\");\n\nfor (key, value) in map.range((Excluded(3), Included(8))) {\n    println!(\"{}: {}\", key, value);\n}\n\nassert_eq!(Some((&3, &\"a\")), map.range((Unbounded, Included(5))).next());"]},"enum variants":["Included(T)","An inclusive bound.\n","Excluded(T)","An exclusive bound.\n","Unbounded","An infinite endpoint. Indicates that there is no bound in this direction.\n"],"trait implementations":[{"name":"impl<T> std::hash::Hash for std::ops::Bound<T> where T: std::hash::Hash","stable since":"1.0.0"},{"name":"impl<T> std::clone::Clone for std::ops::Bound<T> where T: std::clone::Clone","stable since":"1.0.0"},{"name":"impl<T> std::fmt::Debug for std::ops::Bound<T> where T: std::fmt::Debug","stable since":"1.0.0"},{"name":"impl<T> std::cmp::Eq for std::ops::Bound<T> where T: std::cmp::Eq","stable since":"1.0.0"},{"name":"impl<T> std::cmp::PartialEq<std::ops::Bound<T>> for std::ops::Bound<T> where T: std::cmp::PartialEq<T>","stable since":"1.0.0"},{"name":"impl<T> std::marker::Copy for std::ops::Bound<T> where T: std::marker::Copy","stable since":"1.0.0"},{"name":"impl<T> std::marker::Send for std::ops::Bound<T> where T: std::marker::Send","stable since":"1.0.0"},{"name":"impl<T> std::marker::Sync for std::ops::Bound<T> where T: std::marker::Sync","stable since":"1.0.0"}]}