{"stability":{"stable since":"1.0.0"},"apiName":"std::sync::mpsc::channel","apiType":"function","apiDocumentation":{"apiDescription":["Creates a new asynchronous channel, returning the sender/receiver halves. All data sent on the Sender will become available on the Receiver in the same order as it was sent, and no send will block the calling thread (this channel has an \"infinite buffer\", unlike sync_channel, which will block after its buffer limit is reached). recv will block until a message is available.","The Sender can be cloned to send to the same channel multiple times, but only one Receiver is supported.","If the Receiver is disconnected while trying to send with the Sender, the send method will return a SendError. Similarly, if the Sender is disconnected while trying to recv, the recv method will return a RecvError."],"examples":["use std::sync::mpsc::channel;\nuse std::thread;\n\nlet (sender, receiver) = channel();\n\n// Spawn off an expensive computation\nthread::spawn(move|| {\n    sender.send(expensive_computation()).unwrap();\n});\n\n// Do some useful work for awhile\n\n// Let's see what that answer was\nprintln!(\"{:?}\", receiver.recv().unwrap());"]}}