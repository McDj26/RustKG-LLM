{"stability":{"stable since":"1.8.0"},"apiName":"std::ops::BitAndAssign","apiType":"trait","apiDocumentation":{"apiDescription":["The bitwise AND assignment operator &=."],"examples":["An implementation of BitAndAssign that lifts the &= operator to a\nwrapper around bool.","use std::ops::BitAndAssign;\n\n#[derive(Debug, PartialEq)]\nstruct Scalar(bool);\n\nimpl BitAndAssign for Scalar {\n    // rhs is the \"right-hand side\" of the expression `a &= b`\n    fn bitand_assign(&mut self, rhs: Self) {\n        *self = Scalar(self.0 & rhs.0)\n    }\n}\n\nlet mut scalar = Scalar(true);\nscalar &= Scalar(true);\nassert_eq!(scalar, Scalar(true));\n\nlet mut scalar = Scalar(true);\nscalar &= Scalar(false);\nassert_eq!(scalar, Scalar(false));\n\nlet mut scalar = Scalar(false);\nscalar &= Scalar(true);\nassert_eq!(scalar, Scalar(false));\n\nlet mut scalar = Scalar(false);\nscalar &= Scalar(false);\nassert_eq!(scalar, Scalar(false));","Here, the BitAndAssign trait is implemented for a wrapper around\nVec<bool>.","use std::ops::BitAndAssign;\n\n#[derive(Debug, PartialEq)]\nstruct BooleanVector(Vec<bool>);\n\nimpl BitAndAssign for BooleanVector {\n    // `rhs` is the \"right-hand side\" of the expression `a &= b`.\n    fn bitand_assign(&mut self, rhs: Self) {\n        assert_eq!(self.0.len(), rhs.0.len());\n        *self = BooleanVector(self.0\n                                  .iter()\n                                  .zip(rhs.0.iter())\n                                  .map(|(x, y)| *x && *y)\n                                  .collect());\n    }\n}\n\nlet mut bv = BooleanVector(vec![true, true, false, false]);\nbv &= BooleanVector(vec![true, false, true, false]);\nlet expected = BooleanVector(vec![true, false, false, false]);\nassert_eq!(bv, expected);"]},"trait required methods":[{"name":"fn bitand_assign(&mut self, rhs: Rhs)","details":{"description":"Performs the &= operation."}}]}