{"stability":{"stable since":"1.0.0"},"apiName":"std::iter::Iterator","apiType":"trait","apiDocumentation":{"apiDescription":["An interface for dealing with iterators.","This is the main iterator trait. For more about the concept of iterators generally, please see the module-level documentation. In particular, you may want to know how to implement Iterator."]},"trait required methods":[{"name":"fn next(&mut self) -> Option<Self::Item>","details":{"description":"Advances the iterator and returns the next value.","example":["Basic usage:","let a = [1, 2, 3];\n\nlet mut iter = a.iter();\n\n// A call to next() returns the next value...\nassert_eq!(Some(&1), iter.next());\nassert_eq!(Some(&2), iter.next());\nassert_eq!(Some(&3), iter.next());\n\n// ... and then None once it's over.\nassert_eq!(None, iter.next());\n\n// More calls may or may not return None. Here, they always will.\nassert_eq!(None, iter.next());\nassert_eq!(None, iter.next());"]}}],"trait provided methods":[{"name":"fn size_hint(&self) -> (usize, Option<usize>)","details":{"description":"Returns the bounds on the remaining length of the iterator.","example":["Basic usage:","let a = [1, 2, 3];\nlet iter = a.iter();\n\nassert_eq!((3, Some(3)), iter.size_hint());","A more complex example:","// The even numbers from zero to ten.\nlet iter = (0..10).filter(|x| x % 2 == 0);\n\n// We might iterate from zero to ten times. Knowing that it's five\n// exactly wouldn't be possible without executing filter().\nassert_eq!((0, Some(10)), iter.size_hint());\n\n// Let's add five more numbers with chain()\nlet iter = (0..10).filter(|x| x % 2 == 0).chain(15..20);\n\n// now both bounds are increased by five\nassert_eq!((5, Some(15)), iter.size_hint());","Returning None for an upper bound:","// an infinite iterator has no upper bound\n// and the maximum possible lower bound\nlet iter = 0..;\n\nassert_eq!((usize::max_value(), None), iter.size_hint());"]}},{"name":"fn count(self) -> usize","details":{"description":"Consumes the iterator, counting the number of iterations and returning it.","example":["Basic usage:","let a = [1, 2, 3];\nassert_eq!(a.iter().count(), 3);\n\nlet a = [1, 2, 3, 4, 5];\nassert_eq!(a.iter().count(), 5);"]}},{"name":"fn last(self) -> Option<Self::Item>","details":{"description":"Consumes the iterator, returning the last element.","example":["Basic usage:","let a = [1, 2, 3];\nassert_eq!(a.iter().last(), Some(&3));\n\nlet a = [1, 2, 3, 4, 5];\nassert_eq!(a.iter().last(), Some(&5));"]}},{"name":"fn nth(&mut self, n: usize) -> Option<Self::Item>","details":{"description":"Returns the nth element of the iterator.","example":["Basic usage:","let a = [1, 2, 3];\nassert_eq!(a.iter().nth(1), Some(&2));","Calling nth() multiple times doesn't rewind the iterator:","let a = [1, 2, 3];\n\nlet mut iter = a.iter();\n\nassert_eq!(iter.nth(1), Some(&2));\nassert_eq!(iter.nth(1), None);","Returning None if there are less than n + 1 elements:","let a = [1, 2, 3];\nassert_eq!(a.iter().nth(10), None);"]}},{"name":"fn step_by(self, step: usize) -> StepBy<Self>","details":{"description":"Creates an iterator starting at the same point, but stepping by\nthe given amount at each iteration.","example":["Basic usage:","let a = [0, 1, 2, 3, 4, 5];\nlet mut iter = a.into_iter().step_by(2);\n\nassert_eq!(iter.next(), Some(&0));\nassert_eq!(iter.next(), Some(&2));\nassert_eq!(iter.next(), Some(&4));\nassert_eq!(iter.next(), None);"]}},{"name":"fn chain<U>(self, other: U) -> Chain<Self, <U as IntoIterator>::IntoIter> where U: IntoIterator<Item = Self::Item>","details":{"description":"Takes two iterators and creates a new iterator over both in sequence.","example":["Basic usage:","let a1 = [1, 2, 3];\nlet a2 = [4, 5, 6];\n\nlet mut iter = a1.iter().chain(a2.iter());\n\nassert_eq!(iter.next(), Some(&1));\nassert_eq!(iter.next(), Some(&2));\nassert_eq!(iter.next(), Some(&3));\nassert_eq!(iter.next(), Some(&4));\nassert_eq!(iter.next(), Some(&5));\nassert_eq!(iter.next(), Some(&6));\nassert_eq!(iter.next(), None);","Since the argument to chain() uses IntoIterator, we can pass\nanything that can be converted into an Iterator, not just an\nIterator itself. For example, slices (&[T]) implement\nIntoIterator, and so can be passed to chain() directly:","let s1 = &[1, 2, 3];\nlet s2 = &[4, 5, 6];\n\nlet mut iter = s1.iter().chain(s2);\n\nassert_eq!(iter.next(), Some(&1));\nassert_eq!(iter.next(), Some(&2));\nassert_eq!(iter.next(), Some(&3));\nassert_eq!(iter.next(), Some(&4));\nassert_eq!(iter.next(), Some(&5));\nassert_eq!(iter.next(), Some(&6));\nassert_eq!(iter.next(), None);"]}},{"name":"fn zip<U>(self, other: U) -> Zip<Self, <U as IntoIterator>::IntoIter> where U: IntoIterator","details":{"description":"'Zips up' two iterators into a single iterator of pairs.","example":["Basic usage:","let a1 = [1, 2, 3];\nlet a2 = [4, 5, 6];\n\nlet mut iter = a1.iter().zip(a2.iter());\n\nassert_eq!(iter.next(), Some((&1, &4)));\nassert_eq!(iter.next(), Some((&2, &5)));\nassert_eq!(iter.next(), Some((&3, &6)));\nassert_eq!(iter.next(), None);","Since the argument to zip() uses IntoIterator, we can pass\nanything that can be converted into an Iterator, not just an\nIterator itself. For example, slices (&[T]) implement\nIntoIterator, and so can be passed to zip() directly:","let s1 = &[1, 2, 3];\nlet s2 = &[4, 5, 6];\n\nlet mut iter = s1.iter().zip(s2);\n\nassert_eq!(iter.next(), Some((&1, &4)));\nassert_eq!(iter.next(), Some((&2, &5)));\nassert_eq!(iter.next(), Some((&3, &6)));\nassert_eq!(iter.next(), None);","zip() is often used to zip an infinite iterator to a finite one.\nThis works because the finite iterator will eventually return None,\nending the zipper. Zipping with (0..) can look a lot like enumerate:","let enumerate: Vec<_> = \"foo\".chars().enumerate().collect();\n\nlet zipper: Vec<_> = (0..).zip(\"foo\".chars()).collect();\n\nassert_eq!((0, 'f'), enumerate[0]);\nassert_eq!((0, 'f'), zipper[0]);\n\nassert_eq!((1, 'o'), enumerate[1]);\nassert_eq!((1, 'o'), zipper[1]);\n\nassert_eq!((2, 'o'), enumerate[2]);\nassert_eq!((2, 'o'), zipper[2]);"]}},{"name":"fn map<B, F>(self, f: F) -> Map<Self, F> where F: FnMut(Self::Item) -> B","details":{"description":"Takes a closure and creates an iterator which calls that closure on each\nelement.","example":["Basic usage:","let a = [1, 2, 3];\n\nlet mut iter = a.into_iter().map(|x| 2 * x);\n\nassert_eq!(iter.next(), Some(2));\nassert_eq!(iter.next(), Some(4));\nassert_eq!(iter.next(), Some(6));\nassert_eq!(iter.next(), None);","If you're doing some sort of side effect, prefer for to map():","// don't do this:\n(0..5).map(|x| println!(\"{}\", x));\n\n// it won't even execute, as it is lazy. Rust will warn you about this.\n\n// Instead, use for:\nfor x in 0..5 {\n    println!(\"{}\", x);\n}"]}},{"name":"fn for_each<F>(self, f: F) where F: FnMut(Self::Item)","details":{"description":"Calls a closure on each element of an iterator.","example":["Basic usage:","use std::sync::mpsc::channel;\n\nlet (tx, rx) = channel();\n(0..5).map(|x| x * 2 + 1)\n      .for_each(move |x| tx.send(x).unwrap());\n\nlet v: Vec<_> =  rx.iter().collect();\nassert_eq!(v, vec![1, 3, 5, 7, 9]);","For such a small example, a for loop may be cleaner, but for_each\nmight be preferable to keep a functional style with longer iterators:","(0..5).flat_map(|x| x * 100 .. x * 110)\n      .enumerate()\n      .filter(|&(i, x)| (i + x) % 3 == 0)\n      .for_each(|(i, x)| println!(\"{}:{}\", i, x));"]}},{"name":"fn filter<P>(self, predicate: P) -> Filter<Self, P> where P: FnMut(&Self::Item) -> bool","details":{"description":"Creates an iterator which uses a closure to determine if an element\nshould be yielded.","example":["Basic usage:","let a = [0i32, 1, 2];\n\nlet mut iter = a.into_iter().filter(|x| x.is_positive());\n\nassert_eq!(iter.next(), Some(&1));\nassert_eq!(iter.next(), Some(&2));\nassert_eq!(iter.next(), None);","Because the closure passed to filter() takes a reference, and many\niterators iterate over references, this leads to a possibly confusing\nsituation, where the type of the closure is a double reference:","let a = [0, 1, 2];\n\nlet mut iter = a.into_iter().filter(|x| **x > 1); // need two *s!\n\nassert_eq!(iter.next(), Some(&2));\nassert_eq!(iter.next(), None);","It's common to instead use destructuring on the argument to strip away\none:","let a = [0, 1, 2];\n\nlet mut iter = a.into_iter().filter(|&x| *x > 1); // both & and *\n\nassert_eq!(iter.next(), Some(&2));\nassert_eq!(iter.next(), None);","or both:","let a = [0, 1, 2];\n\nlet mut iter = a.into_iter().filter(|&&x| x > 1); // two &s\n\nassert_eq!(iter.next(), Some(&2));\nassert_eq!(iter.next(), None);","of these layers."]}},{"name":"fn filter_map<B, F>(self, f: F) -> FilterMap<Self, F> where F: FnMut(Self::Item) -> Option<B>","details":{"description":"Creates an iterator that both filters and maps.","example":["Basic usage:","let a = [\"1\", \"lol\", \"3\", \"NaN\", \"5\"];\n\nlet mut iter = a.iter().filter_map(|s| s.parse().ok());\n\nassert_eq!(iter.next(), Some(1));\nassert_eq!(iter.next(), Some(3));\nassert_eq!(iter.next(), Some(5));\nassert_eq!(iter.next(), None);","Here's the same example, but with filter and map:","let a = [\"1\", \"lol\", \"3\", \"NaN\", \"5\"];\nlet mut iter = a.iter().map(|s| s.parse()).filter(|s| s.is_ok()).map(|s| s.unwrap());\nassert_eq!(iter.next(), Some(1));\nassert_eq!(iter.next(), Some(3));\nassert_eq!(iter.next(), Some(5));\nassert_eq!(iter.next(), None);"]}},{"name":"fn enumerate(self) -> Enumerate<Self>","details":{"description":"Creates an iterator which gives the current iteration count as well as\nthe next value.","example":["let a = ['a', 'b', 'c'];\n\nlet mut iter = a.iter().enumerate();\n\nassert_eq!(iter.next(), Some((0, &'a')));\nassert_eq!(iter.next(), Some((1, &'b')));\nassert_eq!(iter.next(), Some((2, &'c')));\nassert_eq!(iter.next(), None);"]}},{"name":"fn peekable(self) -> Peekable<Self>","details":{"description":"Creates an iterator which can use peek to look at the next element of\nthe iterator without consuming it.","example":["Basic usage:","let xs = [1, 2, 3];\n\nlet mut iter = xs.iter().peekable();\n\n// peek() lets us see into the future\nassert_eq!(iter.peek(), Some(&&1));\nassert_eq!(iter.next(), Some(&1));\n\nassert_eq!(iter.next(), Some(&2));\n\n// we can peek() multiple times, the iterator won't advance\nassert_eq!(iter.peek(), Some(&&3));\nassert_eq!(iter.peek(), Some(&&3));\n\nassert_eq!(iter.next(), Some(&3));\n\n// after the iterator is finished, so is peek()\nassert_eq!(iter.peek(), None);\nassert_eq!(iter.next(), None);"]}},{"name":"fn skip_while<P>(self, predicate: P) -> SkipWhile<Self, P> where P: FnMut(&Self::Item) -> bool","details":{"description":"Creates an iterator that skips elements based on a predicate.","example":["Basic usage:","let a = [-1i32, 0, 1];\n\nlet mut iter = a.into_iter().skip_while(|x| x.is_negative());\n\nassert_eq!(iter.next(), Some(&0));\nassert_eq!(iter.next(), Some(&1));\nassert_eq!(iter.next(), None);","Because the closure passed to skip_while() takes a reference, and many\niterators iterate over references, this leads to a possibly confusing\nsituation, where the type of the closure is a double reference:","let a = [-1, 0, 1];\n\nlet mut iter = a.into_iter().skip_while(|x| **x < 0); // need two *s!\n\nassert_eq!(iter.next(), Some(&0));\nassert_eq!(iter.next(), Some(&1));\nassert_eq!(iter.next(), None);","Stopping after an initial false:","let a = [-1, 0, 1, -2];\n\nlet mut iter = a.into_iter().skip_while(|x| **x < 0);\n\nassert_eq!(iter.next(), Some(&0));\nassert_eq!(iter.next(), Some(&1));\n\n// while this would have been false, since we already got a false,\n// skip_while() isn't used any more\nassert_eq!(iter.next(), Some(&-2));\n\nassert_eq!(iter.next(), None);"]}},{"name":"fn take_while<P>(self, predicate: P) -> TakeWhile<Self, P> where P: FnMut(&Self::Item) -> bool","details":{"description":"Creates an iterator that yields elements based on a predicate.","example":["Basic usage:","let a = [-1i32, 0, 1];\n\nlet mut iter = a.into_iter().take_while(|x| x.is_negative());\n\nassert_eq!(iter.next(), Some(&-1));\nassert_eq!(iter.next(), None);","Because the closure passed to take_while() takes a reference, and many\niterators iterate over references, this leads to a possibly confusing\nsituation, where the type of the closure is a double reference:","let a = [-1, 0, 1];\n\nlet mut iter = a.into_iter().take_while(|x| **x < 0); // need two *s!\n\nassert_eq!(iter.next(), Some(&-1));\nassert_eq!(iter.next(), None);","Stopping after an initial false:","let a = [-1, 0, 1, -2];\n\nlet mut iter = a.into_iter().take_while(|x| **x < 0);\n\nassert_eq!(iter.next(), Some(&-1));\n\n// We have more elements that are less than zero, but since we already\n// got a false, take_while() isn't used any more\nassert_eq!(iter.next(), None);","Because take_while() needs to look at the value in order to see if it\nshould be included or not, consuming iterators will see that it is\nremoved:","let a = [1, 2, 3, 4];\nlet mut iter = a.into_iter();\n\nlet result: Vec<i32> = iter.by_ref()\n                           .take_while(|n| **n != 3)\n                           .cloned()\n                           .collect();\n\nassert_eq!(result, &[1, 2]);\n\nlet result: Vec<i32> = iter.cloned().collect();\n\nassert_eq!(result, &[4]);","The 3 is no longer there, because it was consumed in order to see if\nthe iteration should stop, but wasn't placed back into the iterator or\nsome similar thing."]}},{"name":"fn skip(self, n: usize) -> Skip<Self>","details":{"description":"Creates an iterator that skips the first n elements.","example":["Basic usage:","let a = [1, 2, 3];\n\nlet mut iter = a.iter().skip(2);\n\nassert_eq!(iter.next(), Some(&3));\nassert_eq!(iter.next(), None);"]}},{"name":"fn take(self, n: usize) -> Take<Self>","details":{"description":"Creates an iterator that yields its first n elements.","example":["Basic usage:","let a = [1, 2, 3];\n\nlet mut iter = a.iter().take(2);\n\nassert_eq!(iter.next(), Some(&1));\nassert_eq!(iter.next(), Some(&2));\nassert_eq!(iter.next(), None);","take() is often used with an infinite iterator, to make it finite:","let mut iter = (0..).take(3);\n\nassert_eq!(iter.next(), Some(0));\nassert_eq!(iter.next(), Some(1));\nassert_eq!(iter.next(), Some(2));\nassert_eq!(iter.next(), None);"]}},{"name":"fn scan<St, B, F>(self, initial_state: St, f: F) -> Scan<Self, St, F> where F: FnMut(&mut St, Self::Item) -> Option<B>","details":{"description":"An iterator adaptor similar to fold that holds internal state and\nproduces a new iterator.","example":["Basic usage:","let a = [1, 2, 3];\n\nlet mut iter = a.iter().scan(1, |state, &x| {\n    // each iteration, we'll multiply the state by the element\n    *state = *state * x;\n\n    // then, we'll yield the negation of the state\n    Some(-*state)\n});\n\nassert_eq!(iter.next(), Some(-1));\nassert_eq!(iter.next(), Some(-2));\nassert_eq!(iter.next(), Some(-6));\nassert_eq!(iter.next(), None);"]}},{"name":"fn flat_map<U, F>(self, f: F) -> FlatMap<Self, U, F> where F: FnMut(Self::Item) -> U, U: IntoIterator","details":{"description":"Creates an iterator that works like map, but flattens nested structure.","example":["Basic usage:","let words = [\"alpha\", \"beta\", \"gamma\"];\n\n// chars() returns an iterator\nlet merged: String = words.iter()\n                          .flat_map(|s| s.chars())\n                          .collect();\nassert_eq!(merged, \"alphabetagamma\");"]}},{"name":"fn flatten(self) -> Flatten<Self> where Self::Item: IntoIterator","details":{"description":"Creates an iterator that flattens nested structure.","example":["Basic usage:","let data = vec![vec![1, 2, 3, 4], vec![5, 6]];\nlet flattened = data.into_iter().flatten().collect::<Vec<u8>>();\nassert_eq!(flattened, &[1, 2, 3, 4, 5, 6]);","Mapping and then flattening:","let words = [\"alpha\", \"beta\", \"gamma\"];\n\n// chars() returns an iterator\nlet merged: String = words.iter()\n                          .map(|s| s.chars())\n                          .flatten()\n                          .collect();\nassert_eq!(merged, \"alphabetagamma\");","You can also rewrite this in terms of flat_map(), which is preferable\nin this case since it conveys intent more clearly:","let words = [\"alpha\", \"beta\", \"gamma\"];\n\n// chars() returns an iterator\nlet merged: String = words.iter()\n                          .flat_map(|s| s.chars())\n                          .collect();\nassert_eq!(merged, \"alphabetagamma\");","Flattening once only removes one level of nesting:","let d3 = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]];\n\nlet d2 = d3.iter().flatten().collect::<Vec<_>>();\nassert_eq!(d2, [&[1, 2], &[3, 4], &[5, 6], &[7, 8]]);\n\nlet d1 = d3.iter().flatten().flatten().collect::<Vec<_>>();\nassert_eq!(d1, [&1, &2, &3, &4, &5, &6, &7, &8]);","Here we see that flatten() does not perform a \"deep\" flatten.\nInstead, only one level of nesting is removed. That is, if you\nflatten() a three-dimensional array the result will be\ntwo-dimensional and not one-dimensional. To get a one-dimensional\nstructure, you have to flatten() again."]}},{"name":"fn fuse(self) -> Fuse<Self>","details":{"description":"Creates an iterator which ends after the first None.","example":["Basic usage:","// an iterator which alternates between Some and None\nstruct Alternate {\n    state: i32,\n}\n\nimpl Iterator for Alternate {\n    type Item = i32;\n\n    fn next(&mut self) -> Option<i32> {\n        let val = self.state;\n        self.state = self.state + 1;\n\n        // if it's even, Some(i32), else None\n        if val % 2 == 0 {\n            Some(val)\n        } else {\n            None\n        }\n    }\n}\n\nlet mut iter = Alternate { state: 0 };\n\n// we can see our iterator going back and forth\nassert_eq!(iter.next(), Some(0));\nassert_eq!(iter.next(), None);\nassert_eq!(iter.next(), Some(2));\nassert_eq!(iter.next(), None);\n\n// however, once we fuse it...\nlet mut iter = iter.fuse();\n\nassert_eq!(iter.next(), Some(4));\nassert_eq!(iter.next(), None);\n\n// it will always return None after the first time.\nassert_eq!(iter.next(), None);\nassert_eq!(iter.next(), None);\nassert_eq!(iter.next(), None);"]}},{"name":"fn inspect<F>(self, f: F) -> Inspect<Self, F> where F: FnMut(&Self::Item)","details":{"description":"Do something with each element of an iterator, passing the value on.","example":["Basic usage:","let a = [1, 4, 2, 3];\n\n// this iterator sequence is complex.\nlet sum = a.iter()\n    .cloned()\n    .filter(|x| x % 2 == 0)\n    .fold(0, |sum, i| sum + i);\n\nprintln!(\"{}\", sum);\n\n// let's add some inspect() calls to investigate what's happening\nlet sum = a.iter()\n    .cloned()\n    .inspect(|x| println!(\"about to filter: {}\", x))\n    .filter(|x| x % 2 == 0)\n    .inspect(|x| println!(\"made it through filter: {}\", x))\n    .fold(0, |sum, i| sum + i);\n\nprintln!(\"{}\", sum);","This will print:","6\nabout to filter: 1\nabout to filter: 4\nmade it through filter: 4\nabout to filter: 2\nmade it through filter: 2\nabout to filter: 3\n6\n","Logging errors before discarding them:","let lines = [\"1\", \"2\", \"a\"];\n\nlet sum: i32 = lines\n    .iter()\n    .map(|line| line.parse::<i32>())\n    .inspect(|num| {\n        if let Err(ref e) = *num {\n            println!(\"Parsing error: {}\", e);\n        }\n    })\n    .filter_map(Result::ok)\n    .sum();\n\nprintln!(\"Sum: {}\", sum);","This will print:","Parsing error: invalid digit found in string\nSum: 3\n"]}},{"name":"fn by_ref(&mut self) -> &mut Self","details":{"description":"Borrows an iterator, rather than consuming it.","example":["Basic usage:","let a = [1, 2, 3];\n\nlet iter = a.into_iter();\n\nlet sum: i32 = iter.take(5).fold(0, |acc, i| acc + i );\n\nassert_eq!(sum, 6);\n\n// if we try to use iter again, it won't work. The following line\n// gives \"error: use of moved value: `iter`\n// assert_eq!(iter.next(), None);\n\n// let's try that again\nlet a = [1, 2, 3];\n\nlet mut iter = a.into_iter();\n\n// instead, we add in a .by_ref()\nlet sum: i32 = iter.by_ref().take(2).fold(0, |acc, i| acc + i );\n\nassert_eq!(sum, 3);\n\n// now this is just fine:\nassert_eq!(iter.next(), Some(&3));\nassert_eq!(iter.next(), None);"]}},{"name":"[+] Expand attributes#[must_use = \"if you really need to exhaust the iterator, consider `.for_each(drop)` instead\"] fn collect<B>(self) -> B where B: FromIterator<Self::Item>","details":{"description":"Transforms an iterator into a collection.","example":["Basic usage:","let a = [1, 2, 3];\n\nlet doubled: Vec<i32> = a.iter()\n                         .map(|&x| x * 2)\n                         .collect();\n\nassert_eq!(vec![2, 4, 6], doubled);","Note that we needed the : Vec<i32> on the left-hand side. This is because\nwe could collect into, for example, a VecDeque<T> instead:","use std::collections::VecDeque;\n\nlet a = [1, 2, 3];\n\nlet doubled: VecDeque<i32> = a.iter().map(|&x| x * 2).collect();\n\nassert_eq!(2, doubled[0]);\nassert_eq!(4, doubled[1]);\nassert_eq!(6, doubled[2]);","Using the 'turbofish' instead of annotating doubled:","let a = [1, 2, 3];\n\nlet doubled = a.iter().map(|x| x * 2).collect::<Vec<i32>>();\n\nassert_eq!(vec![2, 4, 6], doubled);","Because collect() only cares about what you're collecting into, you can\nstill use a partial type hint, _, with the turbofish:","let a = [1, 2, 3];\n\nlet doubled = a.iter().map(|x| x * 2).collect::<Vec<_>>();\n\nassert_eq!(vec![2, 4, 6], doubled);","Using collect() to make a String:","let chars = ['g', 'd', 'k', 'k', 'n'];\n\nlet hello: String = chars.iter()\n    .map(|&x| x as u8)\n    .map(|x| (x + 1) as char)\n    .collect();\n\nassert_eq!(\"hello\", hello);","If you have a list of Result<T, E>s, you can use collect() to\nsee if any of them failed:","let results = [Ok(1), Err(\"nope\"), Ok(3), Err(\"bad\")];\n\nlet result: Result<Vec<_>, &str> = results.iter().cloned().collect();\n\n// gives us the first error\nassert_eq!(Err(\"nope\"), result);\n\nlet results = [Ok(1), Ok(3)];\n\nlet result: Result<Vec<_>, &str> = results.iter().cloned().collect();\n\n// gives us the list of answers\nassert_eq!(Ok(vec![1, 3]), result);"]}},{"name":"fn partition<B, F>(self, f: F) -> (B, B) where B: Default + Extend<Self::Item>, F: FnMut(&Self::Item) -> bool","details":{"description":"Consumes an iterator, creating two collections from it.","example":["Basic usage:","let a = [1, 2, 3];\n\nlet (even, odd): (Vec<i32>, Vec<i32>) = a\n    .into_iter()\n    .partition(|&n| n % 2 == 0);\n\nassert_eq!(even, vec![2]);\nassert_eq!(odd, vec![1, 3]);"]}},{"name":"fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R where F: FnMut(B, Self::Item) -> R, R: Try<Ok = B>","details":{"description":"An iterator method that applies a function as long as it returns\nsuccessfully, producing a single, final value.","example":["Basic usage:","let a = [1, 2, 3];\n\n// the checked sum of all of the elements of the array\nlet sum = a.iter().try_fold(0i8, |acc, &x| acc.checked_add(x));\n\nassert_eq!(sum, Some(6));","Short-circuiting:","let a = [10, 20, 30, 100, 40, 50];\nlet mut it = a.iter();\n\n// This sum overflows when adding the 100 element\nlet sum = it.try_fold(0i8, |acc, &x| acc.checked_add(x));\nassert_eq!(sum, None);\n\n// Because it short-circuited, the remaining elements are still\n// available through the iterator.\nassert_eq!(it.len(), 2);\nassert_eq!(it.next(), Some(&40));"]}},{"name":"fn try_for_each<F, R>(&mut self, f: F) -> R where F: FnMut(Self::Item) -> R, R: Try<Ok = ()>","details":{"description":"An iterator method that applies a fallible function to each item in the\niterator, stopping at the first error and returning that error.","example":["use std::fs::rename;\nuse std::io::{stdout, Write};\nuse std::path::Path;\n\nlet data = [\"no_tea.txt\", \"stale_bread.json\", \"torrential_rain.png\"];\n\nlet res = data.iter().try_for_each(|x| writeln!(stdout(), \"{}\", x));\nassert!(res.is_ok());\n\nlet mut it = data.iter().cloned();\nlet res = it.try_for_each(|x| rename(x, Path::new(x).with_extension(\"old\")));\nassert!(res.is_err());\n// It short-circuited, so the remaining items are still in the iterator:\nassert_eq!(it.next(), Some(\"stale_bread.json\"));"]}},{"name":"fn fold<B, F>(self, init: B, f: F) -> B where F: FnMut(B, Self::Item) -> B","details":{"description":"An iterator method that applies a function, producing a single, final value.","example":["Basic usage:","let a = [1, 2, 3];\n\n// the sum of all of the elements of the array\nlet sum = a.iter().fold(0, |acc, x| acc + x);\n\nassert_eq!(sum, 6);","Let's walk through each step of the iteration here:"," element  acc  x  result \n          0              \n 1        0    1  1      \n 2        1    2  3      \n 3        3    3  6      \n","And so, our final result, 6.","It's common for people who haven't used iterators a lot to\nuse a for loop with a list of things to build up a result. Those\ncan be turned into fold()s:","let numbers = [1, 2, 3, 4, 5];\n\nlet mut result = 0;\n\n// for loop:\nfor i in &numbers {\n    result = result + i;\n}\n\n// fold:\nlet result2 = numbers.iter().fold(0, |acc, &x| acc + x);\n\n// they're the same\nassert_eq!(result, result2);"]}},{"name":"fn all<F>(&mut self, f: F) -> bool where F: FnMut(Self::Item) -> bool","details":{"description":"Tests if every element of the iterator matches a predicate.","example":["Basic usage:","let a = [1, 2, 3];\n\nassert!(a.iter().all(|&x| x > 0));\n\nassert!(!a.iter().all(|&x| x > 2));","Stopping at the first false:","let a = [1, 2, 3];\n\nlet mut iter = a.iter();\n\nassert!(!iter.all(|&x| x != 2));\n\n// we can still use `iter`, as there are more elements.\nassert_eq!(iter.next(), Some(&3));"]}},{"name":"fn any<F>(&mut self, f: F) -> bool where F: FnMut(Self::Item) -> bool","details":{"description":"Tests if any element of the iterator matches a predicate.","example":["Basic usage:","let a = [1, 2, 3];\n\nassert!(a.iter().any(|&x| x > 0));\n\nassert!(!a.iter().any(|&x| x > 5));","Stopping at the first true:","let a = [1, 2, 3];\n\nlet mut iter = a.iter();\n\nassert!(iter.any(|&x| x != 2));\n\n// we can still use `iter`, as there are more elements.\nassert_eq!(iter.next(), Some(&2));"]}},{"name":"fn find<P>(&mut self, predicate: P) -> Option<Self::Item> where P: FnMut(&Self::Item) -> bool","details":{"description":"Searches for an element of an iterator that satisfies a predicate.","example":["Basic usage:","let a = [1, 2, 3];\n\nassert_eq!(a.iter().find(|&&x| x == 2), Some(&2));\n\nassert_eq!(a.iter().find(|&&x| x == 5), None);","Stopping at the first true:","let a = [1, 2, 3];\n\nlet mut iter = a.iter();\n\nassert_eq!(iter.find(|&&x| x == 2), Some(&2));\n\n// we can still use `iter`, as there are more elements.\nassert_eq!(iter.next(), Some(&3));"]}},{"name":"fn find_map<B, F>(&mut self, f: F) -> Option<B> where F: FnMut(Self::Item) -> Option<B>","details":{"description":"Applies function to the elements of iterator and returns\nthe first non-none result.","example":["let a = [\"lol\", \"NaN\", \"2\", \"5\"];\n\nlet mut first_number = a.iter().find_map(|s| s.parse().ok());\n\nassert_eq!(first_number, Some(2));"]}},{"name":"fn position<P>(&mut self, predicate: P) -> Option<usize> where P: FnMut(Self::Item) -> bool","details":{"description":"Searches for an element in an iterator, returning its index.","example":["Basic usage:","let a = [1, 2, 3];\n\nassert_eq!(a.iter().position(|&x| x == 2), Some(1));\n\nassert_eq!(a.iter().position(|&x| x == 5), None);","Stopping at the first true:","let a = [1, 2, 3, 4];\n\nlet mut iter = a.iter();\n\nassert_eq!(iter.position(|&x| x >= 2), Some(1));\n\n// we can still use `iter`, as there are more elements.\nassert_eq!(iter.next(), Some(&3));\n\n// The returned index depends on iterator state\nassert_eq!(iter.position(|&x| x == 4), Some(0));\n"]}},{"name":"fn rposition<P>(&mut self, predicate: P) -> Option<usize> where P: FnMut(Self::Item) -> bool, Self: ExactSizeIterator + DoubleEndedIterator","details":{"description":"Searches for an element in an iterator from the right, returning its\nindex.","example":["Basic usage:","let a = [1, 2, 3];\n\nassert_eq!(a.iter().rposition(|&x| x == 3), Some(2));\n\nassert_eq!(a.iter().rposition(|&x| x == 5), None);","Stopping at the first true:","let a = [1, 2, 3];\n\nlet mut iter = a.iter();\n\nassert_eq!(iter.rposition(|&x| x == 2), Some(1));\n\n// we can still use `iter`, as there are more elements.\nassert_eq!(iter.next(), Some(&1));"]}},{"name":"fn max(self) -> Option<Self::Item> where Self::Item: Ord","details":{"description":"Returns the maximum element of an iterator.","example":["Basic usage:","let a = [1, 2, 3];\nlet b: Vec<u32> = Vec::new();\n\nassert_eq!(a.iter().max(), Some(&3));\nassert_eq!(b.iter().max(), None);"]}},{"name":"fn min(self) -> Option<Self::Item> where Self::Item: Ord","details":{"description":"Returns the minimum element of an iterator.","example":["Basic usage:","let a = [1, 2, 3];\nlet b: Vec<u32> = Vec::new();\n\nassert_eq!(a.iter().min(), Some(&1));\nassert_eq!(b.iter().min(), None);"]}},{"name":"fn max_by_key<B, F>(self, f: F) -> Option<Self::Item> where B: Ord, F: FnMut(&Self::Item) -> B","details":{"description":"Returns the element that gives the maximum value from the\nspecified function.","example":["let a = [-3_i32, 0, 1, 5, -10];\nassert_eq!(*a.iter().max_by_key(|x| x.abs()).unwrap(), -10);"]}},{"name":"fn max_by<F>(self, compare: F) -> Option<Self::Item> where F: FnMut(&Self::Item, &Self::Item) -> Ordering","details":{"description":"Returns the element that gives the maximum value with respect to the\nspecified comparison function.","example":["let a = [-3_i32, 0, 1, 5, -10];\nassert_eq!(*a.iter().max_by(|x, y| x.cmp(y)).unwrap(), 5);"]}},{"name":"fn min_by_key<B, F>(self, f: F) -> Option<Self::Item> where B: Ord, F: FnMut(&Self::Item) -> B","details":{"description":"Returns the element that gives the minimum value from the\nspecified function.","example":["let a = [-3_i32, 0, 1, 5, -10];\nassert_eq!(*a.iter().min_by_key(|x| x.abs()).unwrap(), 0);"]}},{"name":"fn min_by<F>(self, compare: F) -> Option<Self::Item> where F: FnMut(&Self::Item, &Self::Item) -> Ordering","details":{"description":"Returns the element that gives the minimum value with respect to the\nspecified comparison function.","example":["let a = [-3_i32, 0, 1, 5, -10];\nassert_eq!(*a.iter().min_by(|x, y| x.cmp(y)).unwrap(), -10);"]}},{"name":"fn rev(self) -> Rev<Self> where Self: DoubleEndedIterator","details":{"description":"Reverses an iterator's direction.","example":["let a = [1, 2, 3];\n\nlet mut iter = a.iter().rev();\n\nassert_eq!(iter.next(), Some(&3));\nassert_eq!(iter.next(), Some(&2));\nassert_eq!(iter.next(), Some(&1));\n\nassert_eq!(iter.next(), None);"]}},{"name":"fn unzip<A, B, FromA, FromB>(self) -> (FromA, FromB) where FromA: Default + Extend<A>, FromB: Default + Extend<B>, Self: Iterator<Item = (A, B)>","details":{"description":"Converts an iterator of pairs into a pair of containers.","example":["Basic usage:","let a = [(1, 2), (3, 4)];\n\nlet (left, right): (Vec<_>, Vec<_>) = a.iter().cloned().unzip();\n\nassert_eq!(left, [1, 3]);\nassert_eq!(right, [2, 4]);"]}},{"name":"fn cloned<'a, T>(self) -> Cloned<Self> where Self: Iterator<Item = &'a T>, T: 'a + Clone","details":{"description":"Creates an iterator which clones all of its elements.","example":["Basic usage:","let a = [1, 2, 3];\n\nlet v_cloned: Vec<_> = a.iter().cloned().collect();\n\n// cloned is the same as .map(|&x| x), for integers\nlet v_map: Vec<_> = a.iter().map(|&x| x).collect();\n\nassert_eq!(v_cloned, vec![1, 2, 3]);\nassert_eq!(v_map, vec![1, 2, 3]);"]}},{"name":"fn cycle(self) -> Cycle<Self> where Self: Clone","details":{"description":"Repeats an iterator endlessly.","example":["Basic usage:","let a = [1, 2, 3];\n\nlet mut it = a.iter().cycle();\n\nassert_eq!(it.next(), Some(&1));\nassert_eq!(it.next(), Some(&2));\nassert_eq!(it.next(), Some(&3));\nassert_eq!(it.next(), Some(&1));\nassert_eq!(it.next(), Some(&2));\nassert_eq!(it.next(), Some(&3));\nassert_eq!(it.next(), Some(&1));"]}},{"name":"fn sum<S>(self) -> S where S: Sum<Self::Item>","details":{"description":"Sums the elements of an iterator.","example":["Basic usage:","let a = [1, 2, 3];\nlet sum: i32 = a.iter().sum();\n\nassert_eq!(sum, 6);"]}},{"name":"fn product<P>(self) -> P where P: Product<Self::Item>","details":{"description":"Iterates over the entire iterator, multiplying all the elements","example":["fn factorial(n: u32) -> u32 {\n    (1..).take_while(|&i| i <= n).product()\n}\nassert_eq!(factorial(0), 1);\nassert_eq!(factorial(1), 1);\nassert_eq!(factorial(5), 120);"]}},{"name":"fn cmp<I>(self, other: I) -> Ordering where I: IntoIterator<Item = Self::Item>, Self::Item: Ord","details":{"description":"Lexicographically compares the elements of this Iterator with those\nof another."}},{"name":"fn partial_cmp<I>(self, other: I) -> Option<Ordering> where I: IntoIterator, Self::Item: PartialOrd<<I as IntoIterator>::Item>","details":{"description":"Lexicographically compares the elements of this Iterator with those\nof another."}},{"name":"fn eq<I>(self, other: I) -> bool where I: IntoIterator, Self::Item: PartialEq<<I as IntoIterator>::Item>","details":{"description":"Determines if the elements of this Iterator are equal to those of\nanother."}},{"name":"fn ne<I>(self, other: I) -> bool where I: IntoIterator, Self::Item: PartialEq<<I as IntoIterator>::Item>","details":{"description":"Determines if the elements of this Iterator are unequal to those of\nanother."}},{"name":"fn lt<I>(self, other: I) -> bool where I: IntoIterator, Self::Item: PartialOrd<<I as IntoIterator>::Item>","details":{"description":"Determines if the elements of this Iterator are lexicographically\nless than those of another."}},{"name":"fn le<I>(self, other: I) -> bool where I: IntoIterator, Self::Item: PartialOrd<<I as IntoIterator>::Item>","details":{"description":"Determines if the elements of this Iterator are lexicographically\nless or equal to those of another."}},{"name":"fn gt<I>(self, other: I) -> bool where I: IntoIterator, Self::Item: PartialOrd<<I as IntoIterator>::Item>","details":{"description":"Determines if the elements of this Iterator are lexicographically\ngreater than those of another."}},{"name":"fn ge<I>(self, other: I) -> bool where I: IntoIterator, Self::Item: PartialOrd<<I as IntoIterator>::Item>","details":{"description":"Determines if the elements of this Iterator are lexicographically\ngreater than or equal to those of another."}}]}