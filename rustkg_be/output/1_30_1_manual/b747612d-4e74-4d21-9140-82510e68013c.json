{"stability":{"stable since":"1.0.0"},"apiName":"std::collections::BTreeSet","apiType":"struct","apiDocumentation":{"apiDescription":["A set based on a B-Tree.","See BTreeMap's documentation for a detailed discussion of this collection's performance benefits and drawbacks.","It is a logic error for an item to be modified in such a way that the item's ordering relative to any other item, as determined by the Ord trait, changes while it is in the set. This is normally only possible through Cell, RefCell, global state, I/O, or unsafe code."],"examples":["use std::collections::BTreeSet;\n\n// Type inference lets us omit an explicit type signature (which\n// would be `BTreeSet<&str>` in this example).\nlet mut books = BTreeSet::new();\n\n// Add some books.\nbooks.insert(\"A Dance With Dragons\");\nbooks.insert(\"To Kill a Mockingbird\");\nbooks.insert(\"The Odyssey\");\nbooks.insert(\"The Great Gatsby\");\n\n// Check for a specific one.\nif !books.contains(\"The Winds of Winter\") {\n    println!(\"We have {} books, but The Winds of Winter ain't one.\",\n             books.len());\n}\n\n// Remove a book.\nbooks.remove(\"The Odyssey\");\n\n// Iterate over everything.\nfor book in &books {\n    println!(\"{}\", book);\n}"]},"trait implementations":[{"name":"impl<T> std::cmp::PartialOrd<std::collections::btree_set::BTreeSet<T>> for std::collections::btree_set::BTreeSet<T> where T: std::cmp::PartialOrd<T>","stable since":"1.0.0"},{"name":"impl<T> std::iter::IntoIterator for std::collections::btree_set::BTreeSet<T>","stable since":"1.0.0"},{"name":"impl<'a, T> std::iter::IntoIterator for &'a std::collections::btree_set::BTreeSet<T>","stable since":"1.0.0"},{"name":"impl<T> std::cmp::Eq for std::collections::btree_set::BTreeSet<T> where T: std::cmp::Eq","stable since":"1.0.0"},{"name":"impl<'a, 'b, T> std::ops::BitOr<&'b std::collections::btree_set::BTreeSet<T>> for &'a std::collections::btree_set::BTreeSet<T> where T: std::cmp::Ord + std::clone::Clone","stable since":"1.0.0"},{"name":"impl<'a, 'b, T> std::ops::BitAnd<&'b std::collections::btree_set::BTreeSet<T>> for &'a std::collections::btree_set::BTreeSet<T> where T: std::cmp::Ord + std::clone::Clone","stable since":"1.0.0"},{"name":"impl<T> std::default::Default for std::collections::btree_set::BTreeSet<T> where T: std::cmp::Ord","stable since":"1.0.0"},{"name":"impl<T> std::iter::FromIterator<T> for std::collections::btree_set::BTreeSet<T> where T: std::cmp::Ord","stable since":"1.0.0"},{"name":"impl<T> std::clone::Clone for std::collections::btree_set::BTreeSet<T> where T: std::clone::Clone","stable since":"1.0.0"},{"name":"impl<T> std::iter::Extend<T> for std::collections::btree_set::BTreeSet<T> where T: std::cmp::Ord","stable since":"1.0.0"},{"name":"impl<'a, T> std::iter::Extend<&'a T> for std::collections::btree_set::BTreeSet<T> where T: 'a + std::marker::Copy + std::cmp::Ord","stable since":"1.2.0"},{"name":"impl<T> std::hash::Hash for std::collections::btree_set::BTreeSet<T> where T: std::hash::Hash","stable since":"1.0.0"},{"name":"impl<'a, 'b, T> std::ops::BitXor<&'b std::collections::btree_set::BTreeSet<T>> for &'a std::collections::btree_set::BTreeSet<T> where T: std::cmp::Ord + std::clone::Clone","stable since":"1.0.0"},{"name":"impl<T> std::fmt::Debug for std::collections::btree_set::BTreeSet<T> where T: std::fmt::Debug","stable since":"1.0.0"},{"name":"impl<T> std::cmp::PartialEq<std::collections::btree_set::BTreeSet<T>> for std::collections::btree_set::BTreeSet<T> where T: std::cmp::PartialEq<T>","stable since":"1.0.0"},{"name":"impl<'a, 'b, T> std::ops::Sub<&'b std::collections::btree_set::BTreeSet<T>> for &'a std::collections::btree_set::BTreeSet<T> where T: std::cmp::Ord + std::clone::Clone","stable since":"1.0.0"},{"name":"impl<T> std::cmp::Ord for std::collections::btree_set::BTreeSet<T> where T: std::cmp::Ord","stable since":"1.0.0"},{"name":"impl<T> std::marker::Send for std::collections::btree_set::BTreeSet<T> where T: std::marker::Send","stable since":"1.0.0"},{"name":"impl<T> std::marker::Sync for std::collections::btree_set::BTreeSet<T> where T: std::marker::Sync","stable since":"1.0.0"}],"methods":[{"name":"pub fn new() -> BTreeSet<T>","details":{"description":["Makes a new BTreeSet with a reasonable choice of B."],"example":["use std::collections::BTreeSet;\n\nlet mut set: BTreeSet<i32> = BTreeSet::new();"]}},{"name":"pub fn range<K, R>(&self, range: R) -> Range<T> where K: Ord + ?Sized, R: RangeBounds<K>, T: Borrow<K>","details":{"description":["Constructs a double-ended iterator over a sub-range of elements in the set. The simplest way is to use the range syntax min..max, thus range(min..max) will yield elements from min (inclusive) to max (exclusive). The range may also be entered as (Bound<T>, Bound<T>), so for example range((Excluded(4), Included(10))) will yield a left-exclusive, right-inclusive range from 4 to 10."],"example":["use std::collections::BTreeSet;\nuse std::ops::Bound::Included;\n\nlet mut set = BTreeSet::new();\nset.insert(3);\nset.insert(5);\nset.insert(8);\nfor &elem in set.range((Included(&4), Included(&8))) {\n    println!(\"{}\", elem);\n}\nassert_eq!(Some(&5), set.range(4..).next());"]}},{"name":"pub fn difference(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T>","details":{"description":["Visits the values representing the difference, i.e. the values that are in self but not in other, in ascending order."],"example":["use std::collections::BTreeSet;\n\nlet mut a = BTreeSet::new();\na.insert(1);\na.insert(2);\n\nlet mut b = BTreeSet::new();\nb.insert(2);\nb.insert(3);\n\nlet diff: Vec<_> = a.difference(&b).cloned().collect();\nassert_eq!(diff, [1]);"]}},{"name":"pub fn symmetric_difference( &'a self, other: &'a BTreeSet<T>) -> SymmetricDifference<'a, T>","details":{"description":["Visits the values representing the symmetric difference, i.e. the values that are in self or in other but not in both, in ascending order."],"example":["use std::collections::BTreeSet;\n\nlet mut a = BTreeSet::new();\na.insert(1);\na.insert(2);\n\nlet mut b = BTreeSet::new();\nb.insert(2);\nb.insert(3);\n\nlet sym_diff: Vec<_> = a.symmetric_difference(&b).cloned().collect();\nassert_eq!(sym_diff, [1, 3]);"]}},{"name":"pub fn intersection(&'a self, other: &'a BTreeSet<T>) -> Intersection<'a, T>","details":{"description":["Visits the values representing the intersection, i.e. the values that are both in self and other, in ascending order."],"example":["use std::collections::BTreeSet;\n\nlet mut a = BTreeSet::new();\na.insert(1);\na.insert(2);\n\nlet mut b = BTreeSet::new();\nb.insert(2);\nb.insert(3);\n\nlet intersection: Vec<_> = a.intersection(&b).cloned().collect();\nassert_eq!(intersection, [2]);"]}},{"name":"pub fn union(&'a self, other: &'a BTreeSet<T>) -> Union<'a, T>","details":{"description":["Visits the values representing the union, i.e. all the values in self or other, without duplicates, in ascending order."],"example":["use std::collections::BTreeSet;\n\nlet mut a = BTreeSet::new();\na.insert(1);\n\nlet mut b = BTreeSet::new();\nb.insert(2);\n\nlet union: Vec<_> = a.union(&b).cloned().collect();\nassert_eq!(union, [1, 2]);"]}},{"name":"pub fn clear(&mut self)","details":{"description":["Clears the set, removing all values."],"example":["use std::collections::BTreeSet;\n\nlet mut v = BTreeSet::new();\nv.insert(1);\nv.clear();\nassert!(v.is_empty());"]}},{"name":"pub fn contains<Q>(&self, value: &Q) -> bool where Q: Ord + ?Sized, T: Borrow<Q>","details":{"description":["Returns true if the set contains a value.","The value may be any borrowed form of the set's value type, but the ordering on the borrowed form must match the ordering on the value type."],"example":["use std::collections::BTreeSet;\n\nlet set: BTreeSet<_> = [1, 2, 3].iter().cloned().collect();\nassert_eq!(set.contains(&1), true);\nassert_eq!(set.contains(&4), false);"]}},{"name":"pub fn get<Q>(&self, value: &Q) -> Option<&T> where Q: Ord + ?Sized, T: Borrow<Q>","details":{"description":["Returns a reference to the value in the set, if any, that is equal to the given value.","The value may be any borrowed form of the set's value type, but the ordering on the borrowed form must match the ordering on the value type."],"example":["use std::collections::BTreeSet;\n\nlet set: BTreeSet<_> = [1, 2, 3].iter().cloned().collect();\nassert_eq!(set.get(&2), Some(&2));\nassert_eq!(set.get(&4), None);"]}},{"name":"pub fn is_disjoint(&self, other: &BTreeSet<T>) -> bool","details":{"description":["Returns true if self has no elements in common with other. This is equivalent to checking for an empty intersection."],"example":["use std::collections::BTreeSet;\n\nlet a: BTreeSet<_> = [1, 2, 3].iter().cloned().collect();\nlet mut b = BTreeSet::new();\n\nassert_eq!(a.is_disjoint(&b), true);\nb.insert(4);\nassert_eq!(a.is_disjoint(&b), true);\nb.insert(1);\nassert_eq!(a.is_disjoint(&b), false);"]}},{"name":"pub fn is_subset(&self, other: &BTreeSet<T>) -> bool","details":{"description":["Returns true if the set is a subset of another, i.e. other contains at least all the values in self."],"example":["use std::collections::BTreeSet;\n\nlet sup: BTreeSet<_> = [1, 2, 3].iter().cloned().collect();\nlet mut set = BTreeSet::new();\n\nassert_eq!(set.is_subset(&sup), true);\nset.insert(2);\nassert_eq!(set.is_subset(&sup), true);\nset.insert(4);\nassert_eq!(set.is_subset(&sup), false);"]}},{"name":"pub fn is_superset(&self, other: &BTreeSet<T>) -> bool","details":{"description":["Returns true if the set is a superset of another, i.e. self contains at least all the values in other."],"example":["use std::collections::BTreeSet;\n\nlet sub: BTreeSet<_> = [1, 2].iter().cloned().collect();\nlet mut set = BTreeSet::new();\n\nassert_eq!(set.is_superset(&sub), false);\n\nset.insert(0);\nset.insert(1);\nassert_eq!(set.is_superset(&sub), false);\n\nset.insert(2);\nassert_eq!(set.is_superset(&sub), true);"]}},{"name":"pub fn insert(&mut self, value: T) -> bool","details":{"description":["Adds a value to the set.","If the set did not have this value present, true is returned.","If the set did have this value present, false is returned, and the entry is not updated. See the module-level documentation for more."],"example":["use std::collections::BTreeSet;\n\nlet mut set = BTreeSet::new();\n\nassert_eq!(set.insert(2), true);\nassert_eq!(set.insert(2), false);\nassert_eq!(set.len(), 1);"]}},{"name":"pub fn replace(&mut self, value: T) -> Option<T>","details":{"description":["Adds a value to the set, replacing the existing value, if any, that is equal to the given one. Returns the replaced value."],"example":["use std::collections::BTreeSet;\n\nlet mut set = BTreeSet::new();\nset.insert(Vec::<i32>::new());\n\nassert_eq!(set.get(&[][..]).unwrap().capacity(), 0);\nset.replace(Vec::with_capacity(10));\nassert_eq!(set.get(&[][..]).unwrap().capacity(), 10);"]}},{"name":"pub fn remove<Q>(&mut self, value: &Q) -> bool where Q: Ord + ?Sized, T: Borrow<Q>","details":{"description":["Removes a value from the set. Returns true if the value was present in the set.","The value may be any borrowed form of the set's value type, but the ordering on the borrowed form must match the ordering on the value type."],"example":["use std::collections::BTreeSet;\n\nlet mut set = BTreeSet::new();\n\nset.insert(2);\nassert_eq!(set.remove(&2), true);\nassert_eq!(set.remove(&2), false);"]}},{"name":"pub fn take<Q>(&mut self, value: &Q) -> Option<T> where Q: Ord + ?Sized, T: Borrow<Q>","details":{"description":["Removes and returns the value in the set, if any, that is equal to the given one.","The value may be any borrowed form of the set's value type, but the ordering on the borrowed form must match the ordering on the value type."],"example":["use std::collections::BTreeSet;\n\nlet mut set: BTreeSet<_> = [1, 2, 3].iter().cloned().collect();\nassert_eq!(set.take(&2), Some(2));\nassert_eq!(set.take(&2), None);"]}},{"name":"pub fn append(&mut self, other: &mut BTreeSet<T>)","details":{"description":["Moves all elements from other into Self, leaving other empty."],"example":["use std::collections::BTreeSet;\n\nlet mut a = BTreeSet::new();\na.insert(1);\na.insert(2);\na.insert(3);\n\nlet mut b = BTreeSet::new();\nb.insert(3);\nb.insert(4);\nb.insert(5);\n\na.append(&mut b);\n\nassert_eq!(a.len(), 5);\nassert_eq!(b.len(), 0);\n\nassert!(a.contains(&1));\nassert!(a.contains(&2));\nassert!(a.contains(&3));\nassert!(a.contains(&4));\nassert!(a.contains(&5));"]}},{"name":"pub fn split_off<Q>(&mut self, key: &Q) -> BTreeSet<T> where Q: Ord + ?Sized, T: Borrow<Q>","details":{"description":["Splits the collection into two at the given key. Returns everything after the given key, including the key."],"example":["Basic usage:","use std::collections::BTreeSet;\n\nlet mut a = BTreeSet::new();\na.insert(1);\na.insert(2);\na.insert(3);\na.insert(17);\na.insert(41);\n\nlet b = a.split_off(&3);\n\nassert_eq!(a.len(), 2);\nassert_eq!(b.len(), 3);\n\nassert!(a.contains(&1));\nassert!(a.contains(&2));\n\nassert!(b.contains(&3));\nassert!(b.contains(&17));\nassert!(b.contains(&41));"]}},{"name":"pub fn iter(&self) -> Iter<T>","details":{"description":["Gets an iterator that visits the values in the BTreeSet in ascending order."],"example":["use std::collections::BTreeSet;\n\nlet set: BTreeSet<usize> = [1, 2, 3].iter().cloned().collect();\nlet mut set_iter = set.iter();\nassert_eq!(set_iter.next(), Some(&1));\nassert_eq!(set_iter.next(), Some(&2));\nassert_eq!(set_iter.next(), Some(&3));\nassert_eq!(set_iter.next(), None);","Values returned by the iterator are returned in ascending order:","use std::collections::BTreeSet;\n\nlet set: BTreeSet<usize> = [3, 1, 2].iter().cloned().collect();\nlet mut set_iter = set.iter();\nassert_eq!(set_iter.next(), Some(&1));\nassert_eq!(set_iter.next(), Some(&2));\nassert_eq!(set_iter.next(), Some(&3));\nassert_eq!(set_iter.next(), None);"]}},{"name":"pub fn len(&self) -> usize","details":{"description":["Returns the number of elements in the set."],"example":["use std::collections::BTreeSet;\n\nlet mut v = BTreeSet::new();\nassert_eq!(v.len(), 0);\nv.insert(1);\nassert_eq!(v.len(), 1);"]}},{"name":"pub fn is_empty(&self) -> bool","details":{"description":["Returns true if the set contains no elements."],"example":["use std::collections::BTreeSet;\n\nlet mut v = BTreeSet::new();\nassert!(v.is_empty());\nv.insert(1);\nassert!(!v.is_empty());"]}}]}