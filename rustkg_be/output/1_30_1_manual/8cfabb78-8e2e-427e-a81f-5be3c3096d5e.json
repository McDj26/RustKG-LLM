{"stability":{"stable since":"1.0.0"},"apiName":"std::fs::DirEntry","apiType":"struct","apiDocumentation":{"apiDescription":["Entries returned by the ReadDir iterator.","An instance of DirEntry represents an entry inside of a directory on the filesystem. Each entry can be inspected via methods to learn about the full path or possibly other metadata through per-platform extension traits."]},"trait implementations":[{"name":"impl std::fmt::Debug for std::fs::DirEntry","stable since":"1.13.0"},{"name":"impl std::os::unix::fs::DirEntryExt for std::fs::DirEntry","stable since":"1.1.0"},{"name":"impl std::marker::Send for std::fs::DirEntry","stable since":"1.0.0"},{"name":"impl std::marker::Sync for std::fs::DirEntry","stable since":"1.0.0"}],"methods":[{"name":"pub fn path(&self) -> PathBuf","details":{"description":["Returns the full path to the file that this entry represents.","The full path is created by joining the original path to read_dir with the filename of this entry."],"example":["use std::fs;\n\nfn main() -> std::io::Result<()> {\n    for entry in fs::read_dir(\".\")? {\n        let dir = entry?;\n        println!(\"{:?}\", dir.path());\n    }\n    Ok(())\n}","This prints output like:","\"./whatever.txt\"\n\"./foo.html\"\n\"./hello_world.rs\"\n","The exact text, of course, depends on what files you have in .."]}},{"name":"pub fn metadata(&self) -> Result<Metadata>","details":{"description":["Return the metadata for the file that this entry points at.","This function will not traverse symlinks if this entry points at a symlink.","Platform-specific behavior","On Windows this function is cheap to call (no extra system calls needed), but on Unix platforms this function is the equivalent of calling symlink_metadata on the path."],"example":["use std::fs;\n\nif let Ok(entries) = fs::read_dir(\".\") {\n    for entry in entries {\n        if let Ok(entry) = entry {\n            // Here, `entry` is a `DirEntry`.\n            if let Ok(metadata) = entry.metadata() {\n                // Now let's show our entry's permissions!\n                println!(\"{:?}: {:?}\", entry.path(), metadata.permissions());\n            } else {\n                println!(\"Couldn't get metadata for {:?}\", entry.path());\n            }\n        }\n    }\n}"]}},{"name":"pub fn file_type(&self) -> Result<FileType>","details":{"description":["Return the file type for the file that this entry points at.","This function will not traverse symlinks if this entry points at a symlink.","Platform-specific behavior","On Windows and most Unix platforms this function is free (no extra system calls needed), but some Unix platforms may require the equivalent call to symlink_metadata to learn about the target file type."],"example":["use std::fs;\n\nif let Ok(entries) = fs::read_dir(\".\") {\n    for entry in entries {\n        if let Ok(entry) = entry {\n            // Here, `entry` is a `DirEntry`.\n            if let Ok(file_type) = entry.file_type() {\n                // Now let's show our entry's file type!\n                println!(\"{:?}: {:?}\", entry.path(), file_type);\n            } else {\n                println!(\"Couldn't get file type for {:?}\", entry.path());\n            }\n        }\n    }\n}"]}},{"name":"pub fn file_name(&self) -> OsString","details":{"description":["Returns the bare file name of this directory entry without any other leading path component."],"example":["use std::fs;\n\nif let Ok(entries) = fs::read_dir(\".\") {\n    for entry in entries {\n        if let Ok(entry) = entry {\n            // Here, `entry` is a `DirEntry`.\n            println!(\"{:?}\", entry.file_name());\n        }\n    }\n}"]}}]}