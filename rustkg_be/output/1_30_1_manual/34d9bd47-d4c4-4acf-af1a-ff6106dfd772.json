{"stability":{"stable since":"1.0.0"},"apiName":"std::sync::atomic::AtomicPtr","apiType":"struct","apiDocumentation":{"apiDescription":["A raw pointer type which can be safely shared between threads.","This type has the same in-memory representation as a *mut T."]},"trait implementations":[{"name":"impl<T> std::fmt::Pointer for std::sync::atomic::AtomicPtr<T>","stable since":"1.24.0"},{"name":"impl<T> std::fmt::Debug for std::sync::atomic::AtomicPtr<T>","stable since":"1.3.0"},{"name":"impl<T> std::convert::From<*mut T> for std::sync::atomic::AtomicPtr<T>","stable since":"1.23.0"},{"name":"impl<T> std::marker::Sync for std::sync::atomic::AtomicPtr<T>","stable since":"1.0.0"},{"name":"impl<T> std::default::Default for std::sync::atomic::AtomicPtr<T>","stable since":"1.0.0"},{"name":"impl<T> std::marker::Send for std::sync::atomic::AtomicPtr<T>","stable since":"1.0.0"},{"name":"impl<T> std::panic::RefUnwindSafe for std::sync::atomic::AtomicPtr<T>","stable since":"1.14.0"}],"methods":[{"name":"pub const fn new(p: *mut T) -> AtomicPtr<T>","details":{"description":["Creates a new AtomicPtr."],"example":["use std::sync::atomic::AtomicPtr;\n\nlet ptr = &mut 5;\nlet atomic_ptr  = AtomicPtr::new(ptr);"]}},{"name":"pub fn get_mut(&mut self) -> &mut *mut T","details":{"description":["Returns a mutable reference to the underlying pointer.","This is safe because the mutable reference guarantees that no other threads are concurrently accessing the atomic data."],"example":["use std::sync::atomic::{AtomicPtr, Ordering};\n\nlet mut atomic_ptr = AtomicPtr::new(&mut 10);\n*atomic_ptr.get_mut() = &mut 5;\nassert_eq!(unsafe { *atomic_ptr.load(Ordering::SeqCst) }, 5);"]}},{"name":"pub fn into_inner(self) -> *mut T","details":{"description":["Consumes the atomic and returns the contained value.","This is safe because passing self by value guarantees that no other threads are concurrently accessing the atomic data."],"example":["use std::sync::atomic::AtomicPtr;\n\nlet atomic_ptr = AtomicPtr::new(&mut 5);\nassert_eq!(unsafe { *atomic_ptr.into_inner() }, 5);"]}},{"name":"pub fn load(&self, order: Ordering) -> *mut T","details":{"description":["Loads a value from the pointer.","load takes an Ordering argument which describes the memory ordering of this operation. Possible values are SeqCst, Acquire and Relaxed.","Panics","Panics if order is Release or AcqRel."],"example":["use std::sync::atomic::{AtomicPtr, Ordering};\n\nlet ptr = &mut 5;\nlet some_ptr  = AtomicPtr::new(ptr);\n\nlet value = some_ptr.load(Ordering::Relaxed);"]}},{"name":"pub fn store(&self, ptr: *mut T, order: Ordering)","details":{"description":["Stores a value into the pointer.","store takes an Ordering argument which describes the memory ordering of this operation. Possible values are SeqCst, Release and Relaxed.","Panics","Panics if order is Acquire or AcqRel."],"example":["use std::sync::atomic::{AtomicPtr, Ordering};\n\nlet ptr = &mut 5;\nlet some_ptr  = AtomicPtr::new(ptr);\n\nlet other_ptr = &mut 10;\n\nsome_ptr.store(other_ptr, Ordering::Relaxed);"]}},{"name":"pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T","details":{"description":["Stores a value into the pointer, returning the previous value.","swap takes an Ordering argument which describes the memory ordering of this operation. All ordering modes are possible. Note that using Acquire makes the store part of this operation Relaxed, and using Release makes the load part Relaxed."],"example":["use std::sync::atomic::{AtomicPtr, Ordering};\n\nlet ptr = &mut 5;\nlet some_ptr  = AtomicPtr::new(ptr);\n\nlet other_ptr = &mut 10;\n\nlet value = some_ptr.swap(other_ptr, Ordering::Relaxed);"]}},{"name":"pub fn compare_and_swap( &self, current: *mut T, new: *mut T, order: Ordering) -> *mut T","details":{"description":["Stores a value into the pointer if the current value is the same as the current value.","The return value is always the previous value. If it is equal to current, then the value was updated.","compare_and_swap also takes an Ordering argument which describes the memory ordering of this operation. Notice that even when using AcqRel, the operation might fail and hence just perform an Acquire load, but not have Release semantics. Using Acquire makes the store part of this operation Relaxed if it happens, and using Release makes the load part Relaxed."],"example":["use std::sync::atomic::{AtomicPtr, Ordering};\n\nlet ptr = &mut 5;\nlet some_ptr  = AtomicPtr::new(ptr);\n\nlet other_ptr   = &mut 10;\nlet another_ptr = &mut 10;\n\nlet value = some_ptr.compare_and_swap(other_ptr, another_ptr, Ordering::Relaxed);"]}},{"name":"pub fn compare_exchange( &self, current: *mut T, new: *mut T, success: Ordering, failure: Ordering) -> Result<*mut T, *mut T>","details":{"description":["Stores a value into the pointer if the current value is the same as the current value.","The return value is a result indicating whether the new value was written and containing the previous value. On success this value is guaranteed to be equal to current.","compare_exchange takes two Ordering arguments to describe the memory ordering of this operation. The first describes the required ordering if the operation succeeds while the second describes the required ordering when the operation fails. Using Acquire as success ordering makes the store part of this operation Relaxed, and using Release makes the successful load Relaxed. The failure ordering can only be SeqCst, Acquire or Relaxed and must be equivalent to or weaker than the success ordering."],"example":["use std::sync::atomic::{AtomicPtr, Ordering};\n\nlet ptr = &mut 5;\nlet some_ptr  = AtomicPtr::new(ptr);\n\nlet other_ptr   = &mut 10;\nlet another_ptr = &mut 10;\n\nlet value = some_ptr.compare_exchange(other_ptr, another_ptr,\n                                      Ordering::SeqCst, Ordering::Relaxed);"]}},{"name":"pub fn compare_exchange_weak( &self, current: *mut T, new: *mut T, success: Ordering, failure: Ordering) -> Result<*mut T, *mut T>","details":{"description":["Stores a value into the pointer if the current value is the same as the current value.","Unlike compare_exchange, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.","compare_exchange_weak takes two Ordering arguments to describe the memory ordering of this operation. The first describes the required ordering if the operation succeeds while the second describes the required ordering when the operation fails. Using Acquire as success ordering makes the store part of this operation Relaxed, and using Release makes the successful load Relaxed. The failure ordering can only be SeqCst, Acquire or Relaxed and must be equivalent to or weaker than the success ordering."],"example":["use std::sync::atomic::{AtomicPtr, Ordering};\n\nlet some_ptr = AtomicPtr::new(&mut 5);\n\nlet new = &mut 10;\nlet mut old = some_ptr.load(Ordering::Relaxed);\nloop {\n    match some_ptr.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n        Ok(_) => break,\n        Err(x) => old = x,\n    }\n}"]}}]}