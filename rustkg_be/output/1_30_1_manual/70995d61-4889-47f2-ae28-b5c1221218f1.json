{"stability":{"stable since":"1.0.0"},"apiName":"std::sync::Once","apiType":"struct","apiDocumentation":{"apiDescription":["A synchronization primitive which can be used to run a one-time global initialization. Useful for one-time initialization for FFI or related functionality. This type can only be constructed with the ONCE_INIT value or the equivalent Once::new constructor."],"examples":["use std::sync::Once;\n\nstatic START: Once = Once::new();\n\nSTART.call_once(|| {\n    // run initialization here\n});"]},"trait implementations":[{"name":"impl std::marker::Sync for std::sync::Once","stable since":"1.0.0"},{"name":"impl std::marker::Send for std::sync::Once","stable since":"1.0.0"},{"name":"impl std::fmt::Debug for std::sync::Once","stable since":"1.16.0"}],"methods":[{"name":"pub const fn new() -> Once","details":{"description":["Creates a new Once value."]}},{"name":"pub fn call_once<F>(&self, f: F) where F: FnOnce()","details":{"description":["Performs an initialization routine once and only once. The given closure will be executed if this is the first time call_once has been called, and otherwise the routine will not be invoked.","This method will block the calling thread if another initialization routine is currently running.","When this function returns, it is guaranteed that some initialization has run and completed (it may not be the closure specified). It is also guaranteed that any memory writes performed by the executed closure can be reliably observed by other threads at this point (there is a happens-before relation between the closure and code executing after the return).","If the given closure recursively invokes call_once on the same Once instance the exact behavior is not specified, allowed outcomes are a panic or a deadlock."],"example":["use std::sync::Once;\n\nstatic mut VAL: usize = 0;\nstatic INIT: Once = Once::new();\n\n// Accessing a `static mut` is unsafe much of the time, but if we do so\n// in a synchronized fashion (e.g. write once or read all) then we're\n// good to go!\n//\n// This function will only call `expensive_computation` once, and will\n// otherwise always return the value returned from the first invocation.\nfn get_cached_val() -> usize {\n    unsafe {\n        INIT.call_once(|| {\n            VAL = expensive_computation();\n        });\n        VAL\n    }\n}\n\nfn expensive_computation() -> usize {\n    // ...\n}","Panics","The closure f will only be executed once if this is called\nconcurrently amongst many threads. If that closure panics, however, then\nit will poison this Once instance, causing all future invocations of\ncall_once to also panic.","This is similar to poisoning with mutexes."]}},{"name":"pub fn call_once_force<F>(&self, f: F) where F: FnOnce(&OnceState)","stability":["ðŸ”¬ This is a nightly-only experimental API.  (once_poison #33577)"]},{"name":"pub fn is_completed(&self) -> bool","stability":["ðŸ”¬ This is a nightly-only experimental API.  (once_is_completed #42)"]}]}