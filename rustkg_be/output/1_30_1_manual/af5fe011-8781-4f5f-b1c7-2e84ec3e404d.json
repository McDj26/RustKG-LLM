{"stability":{"stable since":"1.0.0"},"apiName":"std::ffi::CString","apiType":"struct","apiDocumentation":{"apiDescription":["A type representing an owned, C-compatible, nul-terminated string with no nul bytes in the middle.","This type serves the purpose of being able to safely generate a C-compatible string from a Rust byte slice or vector. An instance of this type is a static guarantee that the underlying bytes contain no interior 0 bytes (\"nul characters\") and that the final byte is 0 (\"nul terminator\").","CString is to &CStr as String is to &str: the former in each pair are owned strings; the latter are borrowed references.","Creating a CString","A CString is created from either a byte slice or a byte vector, or anything that implements Into<Vec<u8>> (for example, you can build a CString straight out of a String or a &str, since both implement that trait).","The new method will actually check that the provided &[u8] does not have 0 bytes in the middle, and return an error if it finds one.","Extracting a raw pointer to the whole C string","CString implements a as_ptr method through the Deref trait. This method will give you a *const c_char which you can feed directly to extern functions that expect a nul-terminated string, like C's strdup().","Extracting a slice of the whole C string","Alternatively, you can obtain a &[u8] slice from a CString with the as_bytes method. Slices produced in this way do not contain the trailing nul terminator. This is useful when you will be calling an extern function that takes a *const u8 argument which is not necessarily nul-terminated, plus another argument with the length of the string — like C's strndup(). You can of course get the slice's length with its len method.","If you need a &[u8] slice with the nul terminator, you can use as_bytes_with_nul instead.","Once you have the kind of slice you need (with or without a nul terminator), you can call the slice's own as_ptr method to get a raw pointer to pass to extern functions. See the documentation for that function for a discussion on ensuring the lifetime of the raw pointer.","CString is intended for working with traditional C-style strings (a sequence of non-nul bytes terminated by a single nul byte); the primary use case for these kinds of strings is interoperating with C-like code. Often you will need to transfer ownership to/from that external code. It is strongly recommended that you thoroughly read through the documentation of CString before use, as improper ownership management of CString instances can lead to invalid memory accesses, memory leaks, and other memory errors."],"examples":["ⓘThis example is not tested","use std::ffi::CString;\nuse std::os::raw::c_char;\n\nextern {\n    fn my_printer(s: *const c_char);\n}\n\n// We are certain that our string doesn't have 0 bytes in the middle,\n// so we can .expect()\nlet c_to_print = CString::new(\"Hello, world!\").expect(\"CString::new failed\");\nunsafe {\n    my_printer(c_to_print.as_ptr());\n}"]},"trait implementations":[{"name":"impl std::cmp::PartialEq for std::ffi::CString","stable since":"1.0.0"},{"name":"impl std::cmp::PartialOrd for std::ffi::CString","stable since":"1.0.0"},{"name":"impl std::cmp::Eq for std::ffi::CString","stable since":"1.0.0"},{"name":"impl std::cmp::Ord for std::ffi::CString","stable since":"1.0.0"},{"name":"impl std::hash::Hash for std::ffi::CString","stable since":"1.0.0"},{"name":"impl std::clone::Clone for std::ffi::CString","stable since":"1.0.0"},{"name":"impl std::ops::Drop for std::ffi::CString","stable since":"1.13.0"},{"name":"impl std::ops::Deref for std::ffi::CString","stable since":"1.0.0"},{"name":"impl std::fmt::Debug for std::ffi::CString","stable since":"1.0.0"},{"name":"impl std::convert::From<std::ffi::CString> for std::vec::Vec<u8>","stable since":"1.7.0"},{"name":"impl std::default::Default for std::ffi::CString","stable since":"1.10.0"},{"name":"impl std::borrow::Borrow<std::ffi::CStr> for std::ffi::CString","stable since":"1.3.0"},{"name":"impl<'a> std::convert::From<std::borrow::Cow<'a, std::ffi::CStr>> for std::ffi::CString","stable since":"1.28.0"},{"name":"impl std::convert::From<std::boxed::Box<std::ffi::CStr>> for std::ffi::CString","stable since":"1.18.0"},{"name":"impl std::convert::From<std::ffi::CString> for std::boxed::Box<std::ffi::CStr>","stable since":"1.20.0"},{"name":"impl<'a> std::convert::From<std::ffi::CString> for std::borrow::Cow<'a, std::ffi::CStr>","stable since":"1.28.0"},{"name":"impl<'a> std::convert::From<&'a std::ffi::CString> for std::borrow::Cow<'a, std::ffi::CStr>","stable since":"1.28.0"},{"name":"impl std::convert::From<std::ffi::CString> for std::sync::Arc<std::ffi::CStr>","stable since":"1.24.0"},{"name":"impl std::convert::From<std::ffi::CString> for std::rc::Rc<std::ffi::CStr>","stable since":"1.24.0"},{"name":"impl<'a> std::convert::From<&'a std::ffi::CStr> for std::ffi::CString","stable since":"1.7.0"},{"name":"impl std::ops::Index<std::ops::RangeFull> for std::ffi::CString","stable since":"1.7.0"},{"name":"impl std::convert::AsRef<std::ffi::CStr> for std::ffi::CString","stable since":"1.7.0"},{"name":"impl std::marker::Send for std::ffi::CString","stable since":"1.0.0"},{"name":"impl std::marker::Sync for std::ffi::CString","stable since":"1.0.0"}],"methods":[{"name":"pub fn new<T: Into<Vec<u8>>>(t: T) -> Result<CString, NulError>","details":{"description":["Creates a new C-compatible string from a container of bytes.","This function will consume the provided data and use the underlying bytes to construct a new string, ensuring that there is a trailing 0 byte. This trailing 0 byte will be appended by this function; the provided data should not contain any 0 bytes in it."],"example":["ⓘThis example is not tested","use std::ffi::CString;\nuse std::os::raw::c_char;\n\nextern { fn puts(s: *const c_char); }\n\nlet to_print = CString::new(\"Hello!\").expect(\"CString::new failed\");\nunsafe {\n    puts(to_print.as_ptr());\n}","Errors","This function will return an error if the supplied bytes contain an\ninternal 0 byte. The NulError returned will contain the bytes as well as\nthe position of the nul byte."]}},{"name":"pub unsafe fn from_vec_unchecked(v: Vec<u8>) -> CString","details":{"description":["Creates a C-compatible string by consuming a byte vector, without checking for interior 0 bytes.","This method is equivalent to new except that no runtime assertion is made that v contains no 0 bytes, and it requires an actual byte vector, not anything that can be converted to one with Into."],"example":["use std::ffi::CString;\n\nlet raw = b\"foo\".to_vec();\nunsafe {\n    let c_string = CString::from_vec_unchecked(raw);\n}"]}},{"name":"pub unsafe fn from_raw(ptr: *mut c_char) -> CString","details":{"description":["Retakes ownership of a CString that was transferred to C via into_raw.","Additionally, the length of the string will be recalculated from the pointer.","Safety","This should only ever be called with a pointer that was earlier obtained by calling into_raw on a CString. Other usage (e.g. trying to take ownership of a string that was allocated by foreign code) is likely to lead to undefined behavior or allocator corruption.","Note: If you need to borrow a string that was allocated by foreign code, use CStr. If you need to take ownership of a string that was allocated by foreign code, you will need to make your own provisions for freeing it appropriately, likely with the foreign code's API to do that."],"example":["Create a CString, pass ownership to an extern function (via raw pointer), then retake\nownership with from_raw:","ⓘThis example is not tested","use std::ffi::CString;\nuse std::os::raw::c_char;\n\nextern {\n    fn some_extern_function(s: *mut c_char);\n}\n\nlet c_string = CString::new(\"Hello!\").expect(\"CString::new failed\");\nlet raw = c_string.into_raw();\nunsafe {\n    some_extern_function(raw);\n    let c_string = CString::from_raw(raw);\n}"]}},{"name":"pub fn into_raw(self) -> *mut c_char","details":{"description":["Consumes the CString and transfers ownership of the string to a C caller.","The pointer which this function returns must be returned to Rust and reconstituted using from_raw to be properly deallocated. Specifically, one should not use the standard C free() function to deallocate this string.","Failure to call from_raw will lead to a memory leak."],"example":["use std::ffi::CString;\n\nlet c_string = CString::new(\"foo\").expect(\"CString::new failed\");\n\nlet ptr = c_string.into_raw();\n\nunsafe {\n    assert_eq!(b'f', *ptr as u8);\n    assert_eq!(b'o', *ptr.offset(1) as u8);\n    assert_eq!(b'o', *ptr.offset(2) as u8);\n    assert_eq!(b'\\0', *ptr.offset(3) as u8);\n\n    // retake pointer to free memory\n    let _ = CString::from_raw(ptr);\n}"]}},{"name":"pub fn into_string(self) -> Result<String, IntoStringError>","details":{"description":["Converts the CString into a String if it contains valid UTF-8 data.","On failure, ownership of the original CString is returned."],"example":["use std::ffi::CString;\n\nlet valid_utf8 = vec![b'f', b'o', b'o'];\nlet cstring = CString::new(valid_utf8).expect(\"CString::new failed\");\nassert_eq!(cstring.into_string().expect(\"into_string() call failed\"), \"foo\");\n\nlet invalid_utf8 = vec![b'f', 0xff, b'o', b'o'];\nlet cstring = CString::new(invalid_utf8).expect(\"CString::new failed\");\nlet err = cstring.into_string().err().expect(\"into_string().err() failed\");\nassert_eq!(err.utf8_error().valid_up_to(), 1);"]}},{"name":"pub fn into_bytes(self) -> Vec<u8>","details":{"description":["Consumes the CString and returns the underlying byte buffer.","The returned buffer does not contain the trailing nul terminator, and it is guaranteed to not have any interior nul bytes."],"example":["use std::ffi::CString;\n\nlet c_string = CString::new(\"foo\").expect(\"CString::new failed\");\nlet bytes = c_string.into_bytes();\nassert_eq!(bytes, vec![b'f', b'o', b'o']);"]}},{"name":"pub fn into_bytes_with_nul(self) -> Vec<u8>","details":{"description":["Equivalent to the into_bytes function except that the returned vector includes the trailing nul terminator."],"example":["use std::ffi::CString;\n\nlet c_string = CString::new(\"foo\").expect(\"CString::new failed\");\nlet bytes = c_string.into_bytes_with_nul();\nassert_eq!(bytes, vec![b'f', b'o', b'o', b'\\0']);"]}},{"name":"pub fn as_bytes(&self) -> &[u8]","details":{"description":["Returns the contents of this CString as a slice of bytes.","The returned slice does not contain the trailing nul terminator, and it is guaranteed to not have any interior nul bytes. If you need the nul terminator, use as_bytes_with_nul instead."],"example":["use std::ffi::CString;\n\nlet c_string = CString::new(\"foo\").expect(\"CString::new failed\");\nlet bytes = c_string.as_bytes();\nassert_eq!(bytes, &[b'f', b'o', b'o']);"]}},{"name":"pub fn as_bytes_with_nul(&self) -> &[u8]","details":{"description":["Equivalent to the as_bytes function except that the returned slice includes the trailing nul terminator."],"example":["use std::ffi::CString;\n\nlet c_string = CString::new(\"foo\").expect(\"CString::new failed\");\nlet bytes = c_string.as_bytes_with_nul();\nassert_eq!(bytes, &[b'f', b'o', b'o', b'\\0']);"]}},{"name":"pub fn as_c_str(&self) -> &CStr","details":{"description":["Extracts a CStr slice containing the entire string."],"example":["use std::ffi::{CString, CStr};\n\nlet c_string = CString::new(b\"foo\".to_vec()).expect(\"CString::new failed\");\nlet c_str = c_string.as_c_str();\nassert_eq!(c_str,\n           CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\"));"]}},{"name":"pub fn into_boxed_c_str(self) -> Box<CStr>","details":{"description":["Converts this CString into a boxed CStr."],"example":["use std::ffi::{CString, CStr};\n\nlet c_string = CString::new(b\"foo\".to_vec()).expect(\"CString::new failed\");\nlet boxed = c_string.into_boxed_c_str();\nassert_eq!(&*boxed,\n           CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\"));"]}}]}