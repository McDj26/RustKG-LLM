{"stability":{"stable since":"1.26.0"},"apiName":"i128","apiType":"primitive","apiDocumentation":{"apiDescription":["The 128-bit signed integer type.","See also the std::i128 module."]},"trait implementations":[{"name":"impl std::convert::TryFrom<u128> for i128","stable since":"1.0.0"},{"name":"impl std::convert::TryFrom<isize> for i128","stable since":"1.0.0"},{"name":"impl std::convert::TryFrom<usize> for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::RemAssign<&'a i128> for i128","stable since":"1.22.0"},{"name":"impl std::ops::RemAssign<i128> for i128","stable since":"1.8.0"},{"name":"impl std::str::FromStr for i128","stable since":"1.0.0"},{"name":"impl std::ops::DivAssign<i128> for i128","stable since":"1.8.0"},{"name":"impl<'a> std::ops::DivAssign<&'a i128> for i128","stable since":"1.22.0"},{"name":"impl std::ops::MulAssign<i128> for i128","stable since":"1.8.0"},{"name":"impl<'a> std::ops::MulAssign<&'a i128> for i128","stable since":"1.22.0"},{"name":"impl<'a> std::ops::SubAssign<&'a i128> for i128","stable since":"1.22.0"},{"name":"impl std::ops::SubAssign<i128> for i128","stable since":"1.8.0"},{"name":"impl std::hash::Hash for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::AddAssign<&'a i128> for i128","stable since":"1.22.0"},{"name":"impl std::ops::AddAssign<i128> for i128","stable since":"1.8.0"},{"name":"impl<'a> std::ops::Neg for &'a i128","stable since":"1.0.0"},{"name":"impl std::ops::Neg for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::ShrAssign<&'a i8> for i128","stable since":"1.22.0"},{"name":"impl<'a> std::ops::ShrAssign<&'a i128> for i128","stable since":"1.22.0"},{"name":"impl<'a> std::ops::ShrAssign<&'a i32> for i128","stable since":"1.22.0"},{"name":"impl std::ops::ShrAssign<u16> for i128","stable since":"1.8.0"},{"name":"impl std::ops::ShrAssign<usize> for i128","stable since":"1.8.0"},{"name":"impl<'a> std::ops::ShrAssign<&'a u128> for i128","stable since":"1.22.0"},{"name":"impl std::ops::ShrAssign<i32> for i128","stable since":"1.8.0"},{"name":"impl std::ops::ShrAssign<isize> for i128","stable since":"1.8.0"},{"name":"impl<'a> std::ops::ShrAssign<&'a isize> for i128","stable since":"1.22.0"},{"name":"impl<'a> std::ops::ShrAssign<&'a i64> for i128","stable since":"1.22.0"},{"name":"impl<'a> std::ops::ShrAssign<&'a u8> for i128","stable since":"1.22.0"},{"name":"impl std::ops::ShrAssign<i128> for i128","stable since":"1.8.0"},{"name":"impl std::ops::ShrAssign<i64> for i128","stable since":"1.8.0"},{"name":"impl<'a> std::ops::ShrAssign<&'a u32> for i128","stable since":"1.22.0"},{"name":"impl<'a> std::ops::ShrAssign<&'a usize> for i128","stable since":"1.22.0"},{"name":"impl<'a> std::ops::ShrAssign<&'a u16> for i128","stable since":"1.22.0"},{"name":"impl std::ops::ShrAssign<u64> for i128","stable since":"1.8.0"},{"name":"impl std::ops::ShrAssign<i8> for i128","stable since":"1.8.0"},{"name":"impl std::ops::ShrAssign<u32> for i128","stable since":"1.8.0"},{"name":"impl std::ops::ShrAssign<u8> for i128","stable since":"1.8.0"},{"name":"impl<'a> std::ops::ShrAssign<&'a u64> for i128","stable since":"1.22.0"},{"name":"impl std::ops::ShrAssign<i16> for i128","stable since":"1.8.0"},{"name":"impl<'a> std::ops::ShrAssign<&'a i16> for i128","stable since":"1.22.0"},{"name":"impl std::ops::ShrAssign<u128> for i128","stable since":"1.8.0"},{"name":"impl std::clone::Clone for i128","stable since":"1.0.0"},{"name":"impl std::cmp::PartialOrd<i128> for i128","stable since":"1.0.0"},{"name":"impl std::cmp::Ord for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Sub<&'a i128> for i128","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Sub<&'a i128> for &'b i128","stable since":"1.0.0"},{"name":"impl std::ops::Sub<i128> for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Sub<i128> for &'a i128","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shr<&'a i64> for &'b i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<i8> for &'a i128","stable since":"1.0.0"},{"name":"impl std::ops::Shr<i128> for i128","stable since":"1.0.0"},{"name":"impl std::ops::Shr<isize> for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<u128> for &'a i128","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shr<&'a usize> for &'b i128","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shr<&'a i8> for &'b i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<&'a u64> for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<&'a i128> for i128","stable since":"1.0.0"},{"name":"impl std::ops::Shr<i64> for i128","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shr<&'a u16> for &'b i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<&'a usize> for i128","stable since":"1.0.0"},{"name":"impl std::ops::Shr<u64> for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<&'a u32> for i128","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shr<&'a u8> for &'b i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<&'a i8> for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<isize> for &'a i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<u64> for &'a i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<&'a i32> for i128","stable since":"1.0.0"},{"name":"impl std::ops::Shr<usize> for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<&'a u8> for i128","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shr<&'a u32> for &'b i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<usize> for &'a i128","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shr<&'a u64> for &'b i128","stable since":"1.0.0"},{"name":"impl std::ops::Shr<i8> for i128","stable since":"1.0.0"},{"name":"impl std::ops::Shr<i32> for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<&'a u16> for i128","stable since":"1.0.0"},{"name":"impl std::ops::Shr<u128> for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<u16> for &'a i128","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shr<&'a i32> for &'b i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<u8> for &'a i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<u32> for &'a i128","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shr<&'a isize> for &'b i128","stable since":"1.0.0"},{"name":"impl std::ops::Shr<i16> for i128","stable since":"1.0.0"},{"name":"impl std::ops::Shr<u32> for i128","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shr<&'a i128> for &'b i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<&'a isize> for i128","stable since":"1.0.0"},{"name":"impl std::ops::Shr<u16> for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<&'a i16> for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<i16> for &'a i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<&'a i64> for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<i64> for &'a i128","stable since":"1.0.0"},{"name":"impl std::ops::Shr<u8> for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<&'a u128> for i128","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shr<&'a i16> for &'b i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<i128> for &'a i128","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shr<&'a u128> for &'b i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<i32> for &'a i128","stable since":"1.0.0"},{"name":"impl std::fmt::Binary for i128","stable since":"1.0.0"},{"name":"impl std::iter::Sum<i128> for i128","stable since":"1.12.0"},{"name":"impl<'a> std::iter::Sum<&'a i128> for i128","stable since":"1.12.0"},{"name":"impl std::iter::Step for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::BitXor<i128> for &'a i128","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::BitXor<&'a i128> for &'b i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::BitXor<&'a i128> for i128","stable since":"1.0.0"},{"name":"impl std::ops::BitXor<i128> for i128","stable since":"1.0.0"},{"name":"impl std::fmt::Debug for i128","stable since":"1.0.0"},{"name":"impl std::cmp::Eq for i128","stable since":"1.0.0"},{"name":"impl std::cmp::PartialEq<i128> for i128","stable since":"1.0.0"},{"name":"impl std::convert::From<u16> for i128","stable since":"1.0.0"},{"name":"impl std::convert::From<i16> for i128","stable since":"1.0.0"},{"name":"impl std::convert::From<i8> for i128","stable since":"1.0.0"},{"name":"impl std::convert::From<u8> for i128","stable since":"1.0.0"},{"name":"impl std::convert::From<u32> for i128","stable since":"1.0.0"},{"name":"impl std::convert::From<i32> for i128","stable since":"1.0.0"},{"name":"impl std::convert::From<bool> for i128","stable since":"1.28.0"},{"name":"impl std::convert::From<u64> for i128","stable since":"1.0.0"},{"name":"impl std::convert::From<i64> for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Not for &'a i128","stable since":"1.0.0"},{"name":"impl std::ops::Not for i128","stable since":"1.0.0"},{"name":"impl std::marker::Copy for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Rem<i128> for &'a i128","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Rem<&'a i128> for &'b i128","stable since":"1.0.0"},{"name":"impl std::ops::Rem<i128> for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Rem<&'a i128> for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Mul<i128> for &'a i128","stable since":"1.0.0"},{"name":"impl std::ops::Mul<i128> for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Mul<&'a i128> for i128","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Mul<&'a i128> for &'b i128","stable since":"1.0.0"},{"name":"impl std::fmt::UpperHex for i128","stable since":"1.0.0"},{"name":"impl std::ops::Shl<u8> for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<&'a isize> for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<i8> for &'a i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<usize> for &'a i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<&'a i32> for i128","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shl<&'a u128> for &'b i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<u16> for &'a i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<u8> for &'a i128","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shl<&'a u64> for &'b i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<u64> for &'a i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<&'a i8> for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<i16> for &'a i128","stable since":"1.0.0"},{"name":"impl std::ops::Shl<u32> for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<&'a u32> for i128","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shl<&'a u32> for &'b i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<i64> for &'a i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<u128> for &'a i128","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shl<&'a u16> for &'b i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<&'a u16> for i128","stable since":"1.0.0"},{"name":"impl std::ops::Shl<u16> for i128","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shl<&'a i8> for &'b i128","stable since":"1.0.0"},{"name":"impl std::ops::Shl<usize> for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<i32> for &'a i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<&'a u8> for i128","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shl<&'a i64> for &'b i128","stable since":"1.0.0"},{"name":"impl std::ops::Shl<i32> for i128","stable since":"1.0.0"},{"name":"impl std::ops::Shl<i128> for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<i128> for &'a i128","stable since":"1.0.0"},{"name":"impl std::ops::Shl<i16> for i128","stable since":"1.0.0"},{"name":"impl std::ops::Shl<i8> for i128","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shl<&'a i128> for &'b i128","stable since":"1.0.0"},{"name":"impl std::ops::Shl<i64> for i128","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shl<&'a usize> for &'b i128","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shl<&'a isize> for &'b i128","stable since":"1.0.0"},{"name":"impl std::ops::Shl<u128> for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<&'a u128> for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<&'a i16> for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<&'a i64> for i128","stable since":"1.0.0"},{"name":"impl std::ops::Shl<isize> for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<&'a u64> for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<&'a usize> for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<u32> for &'a i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<isize> for &'a i128","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shl<&'a i16> for &'b i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<&'a i128> for i128","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shl<&'a u8> for &'b i128","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shl<&'a i32> for &'b i128","stable since":"1.0.0"},{"name":"impl std::ops::Shl<u64> for i128","stable since":"1.0.0"},{"name":"impl std::fmt::Octal for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::BitAnd<i128> for &'a i128","stable since":"1.0.0"},{"name":"impl std::ops::BitAnd<i128> for i128","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::BitAnd<&'a i128> for &'b i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::BitAnd<&'a i128> for i128","stable since":"1.0.0"},{"name":"impl std::default::Default for i128","stable since":"1.0.0"},{"name":"impl std::ops::ShlAssign<u32> for i128","stable since":"1.8.0"},{"name":"impl<'a> std::ops::ShlAssign<&'a i64> for i128","stable since":"1.22.0"},{"name":"impl<'a> std::ops::ShlAssign<&'a u32> for i128","stable since":"1.22.0"},{"name":"impl std::ops::ShlAssign<isize> for i128","stable since":"1.8.0"},{"name":"impl<'a> std::ops::ShlAssign<&'a u128> for i128","stable since":"1.22.0"},{"name":"impl<'a> std::ops::ShlAssign<&'a isize> for i128","stable since":"1.22.0"},{"name":"impl std::ops::ShlAssign<u8> for i128","stable since":"1.8.0"},{"name":"impl<'a> std::ops::ShlAssign<&'a i16> for i128","stable since":"1.22.0"},{"name":"impl std::ops::ShlAssign<usize> for i128","stable since":"1.8.0"},{"name":"impl std::ops::ShlAssign<u16> for i128","stable since":"1.8.0"},{"name":"impl<'a> std::ops::ShlAssign<&'a i8> for i128","stable since":"1.22.0"},{"name":"impl<'a> std::ops::ShlAssign<&'a usize> for i128","stable since":"1.22.0"},{"name":"impl std::ops::ShlAssign<i128> for i128","stable since":"1.8.0"},{"name":"impl std::ops::ShlAssign<i64> for i128","stable since":"1.8.0"},{"name":"impl<'a> std::ops::ShlAssign<&'a u16> for i128","stable since":"1.22.0"},{"name":"impl std::ops::ShlAssign<u128> for i128","stable since":"1.8.0"},{"name":"impl<'a> std::ops::ShlAssign<&'a i32> for i128","stable since":"1.22.0"},{"name":"impl std::ops::ShlAssign<u64> for i128","stable since":"1.8.0"},{"name":"impl std::ops::ShlAssign<i8> for i128","stable since":"1.8.0"},{"name":"impl std::ops::ShlAssign<i16> for i128","stable since":"1.8.0"},{"name":"impl<'a> std::ops::ShlAssign<&'a u64> for i128","stable since":"1.22.0"},{"name":"impl std::ops::ShlAssign<i32> for i128","stable since":"1.8.0"},{"name":"impl<'a> std::ops::ShlAssign<&'a u8> for i128","stable since":"1.22.0"},{"name":"impl<'a> std::ops::ShlAssign<&'a i128> for i128","stable since":"1.22.0"},{"name":"impl<'a> std::ops::BitXorAssign<&'a i128> for i128","stable since":"1.22.0"},{"name":"impl std::ops::BitXorAssign<i128> for i128","stable since":"1.8.0"},{"name":"impl std::ops::Div<i128> for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Div<&'a i128> for i128","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Div<&'a i128> for &'b i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Div<i128> for &'a i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::BitOrAssign<&'a i128> for i128","stable since":"1.22.0"},{"name":"impl std::ops::BitOrAssign<i128> for i128","stable since":"1.8.0"},{"name":"impl<'a> std::ops::BitAndAssign<&'a i128> for i128","stable since":"1.22.0"},{"name":"impl std::ops::BitAndAssign<i128> for i128","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::ops::Add<&'a i128> for &'b i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Add<i128> for &'a i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Add<&'a i128> for i128","stable since":"1.0.0"},{"name":"impl std::ops::Add<i128> for i128","stable since":"1.0.0"},{"name":"impl std::fmt::LowerHex for i128","stable since":"1.0.0"},{"name":"impl<'a> std::iter::Product<&'a i128> for i128","stable since":"1.12.0"},{"name":"impl std::iter::Product<i128> for i128","stable since":"1.12.0"},{"name":"impl std::fmt::Display for i128","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::BitOr<&'a i128> for &'b i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::BitOr<&'a i128> for i128","stable since":"1.0.0"},{"name":"impl std::ops::BitOr<i128> for i128","stable since":"1.0.0"},{"name":"impl<'a> std::ops::BitOr<i128> for &'a i128","stable since":"1.0.0"},{"name":"impl compiler_builtins::int::Int for i128","stable since":"1.0.0"},{"name":"impl compiler_builtins::int::CastInto<u32> for i128","stable since":"1.0.0"},{"name":"impl compiler_builtins::int::CastInto<i32> for i128","stable since":"1.0.0"},{"name":"impl compiler_builtins::int::CastInto<i64> for i128","stable since":"1.0.0"},{"name":"impl compiler_builtins::int::CastInto<isize> for i128","stable since":"1.0.0"},{"name":"impl compiler_builtins::int::CastInto<usize> for i128","stable since":"1.0.0"},{"name":"impl compiler_builtins::int::CastInto<u64> for i128","stable since":"1.0.0"},{"name":"impl compiler_builtins::int::CastInto<i128> for i128","stable since":"1.0.0"},{"name":"impl compiler_builtins::int::CastInto<u128> for i128","stable since":"1.0.0"},{"name":"impl compiler_builtins::int::LargeInt for i128","stable since":"1.0.0"},{"name":"impl std::marker::Send for i128","stable since":"1.0.0"},{"name":"impl std::marker::Sync for i128","stable since":"1.0.0"}],"methods":[{"name":"pub const fn min_value() -> i128","details":{"description":["Returns the smallest value that can be represented by this integer type."],"example":["Basic usage:","assert_eq!(i128::min_value(), -170141183460469231731687303715884105728);"]}},{"name":"pub const fn max_value() -> i128","details":{"description":["Returns the largest value that can be represented by this integer type."],"example":["Basic usage:","assert_eq!(i128::max_value(), 170141183460469231731687303715884105727);"]}},{"name":"pub fn from_str_radix(src: &str, radix: u32) -> Result<i128, ParseIntError>","details":{"description":["Converts a string slice in a given base to an integer.","The string is expected to be an optional + or - sign followed by digits. Leading and trailing whitespace represent an error. Digits are a subset of these characters, depending on radix:","0-9 a-z A-Z","Panics","This function panics if radix is not in the range from 2 to 36."],"example":["Basic usage:","assert_eq!(i128::from_str_radix(\"A\", 16), Ok(10));"]}},{"name":"pub const fn count_ones(self) -> u32","details":{"description":["Returns the number of ones in the binary representation of self."],"example":["Basic usage:","let n = 0b100_0000i128;\n\nassert_eq!(n.count_ones(), 1);"]}},{"name":"pub const fn count_zeros(self) -> u32","details":{"description":["Returns the number of zeros in the binary representation of self."],"example":["Basic usage:","assert_eq!(i128::max_value().count_zeros(), 1);"]}},{"name":"pub const fn leading_zeros(self) -> u32","details":{"description":["Returns the number of leading zeros in the binary representation of self."],"example":["Basic usage:","let n = -1i128;\n\nassert_eq!(n.leading_zeros(), 0);"]}},{"name":"pub const fn trailing_zeros(self) -> u32","details":{"description":["Returns the number of trailing zeros in the binary representation of self."],"example":["Basic usage:","let n = -4i128;\n\nassert_eq!(n.trailing_zeros(), 2);"]}},{"name":"pub const fn rotate_left(self, n: u32) -> i128","details":{"description":["Shifts the bits to the left by a specified amount, n, wrapping the truncated bits to the end of the resulting integer.","Please note this isn't the same operation as <<!"],"example":["Basic usage:","let n = 0x13f40000000000000000000000004f76i128;\nlet m = 0x4f7613f4;\n\nassert_eq!(n.rotate_left(16), m);"]}},{"name":"pub const fn rotate_right(self, n: u32) -> i128","details":{"description":["Shifts the bits to the right by a specified amount, n, wrapping the truncated bits to the beginning of the resulting integer.","Please note this isn't the same operation as >>!"],"example":["Basic usage:","let n = 0x4f7613f4i128;\nlet m = 0x13f40000000000000000000000004f76;\n\nassert_eq!(n.rotate_right(16), m);"]}},{"name":"pub const fn swap_bytes(self) -> i128","details":{"description":["Reverses the byte order of the integer."],"example":["Basic usage:","let n = 0x12345678901234567890123456789012i128;\n\nlet m = n.swap_bytes();\n\nassert_eq!(m, 0x12907856341290785634129078563412);"]}},{"name":"pub const fn reverse_bits(self) -> i128","stability":["🔬 This is a nightly-only experimental API.  (reverse_bits #48763)"]},{"name":"pub const fn from_be(x: i128) -> i128","details":{"description":["Converts an integer from big endian to the target's endianness.","On big endian this is a no-op. On little endian the bytes are swapped."],"example":["Basic usage:","let n = 0x1Ai128;\n\nif cfg!(target_endian = \"big\") {\n    assert_eq!(i128::from_be(n), n)\n} else {\n    assert_eq!(i128::from_be(n), n.swap_bytes())\n}"]}},{"name":"pub const fn from_le(x: i128) -> i128","details":{"description":["Converts an integer from little endian to the target's endianness.","On little endian this is a no-op. On big endian the bytes are swapped."],"example":["Basic usage:","let n = 0x1Ai128;\n\nif cfg!(target_endian = \"little\") {\n    assert_eq!(i128::from_le(n), n)\n} else {\n    assert_eq!(i128::from_le(n), n.swap_bytes())\n}"]}},{"name":"pub const fn to_be(self) -> i128","details":{"description":["Converts self to big endian from the target's endianness.","On big endian this is a no-op. On little endian the bytes are swapped."],"example":["Basic usage:","let n = 0x1Ai128;\n\nif cfg!(target_endian = \"big\") {\n    assert_eq!(n.to_be(), n)\n} else {\n    assert_eq!(n.to_be(), n.swap_bytes())\n}"]}},{"name":"pub const fn to_le(self) -> i128","details":{"description":["Converts self to little endian from the target's endianness.","On little endian this is a no-op. On big endian the bytes are swapped."],"example":["Basic usage:","let n = 0x1Ai128;\n\nif cfg!(target_endian = \"little\") {\n    assert_eq!(n.to_le(), n)\n} else {\n    assert_eq!(n.to_le(), n.swap_bytes())\n}"]}},{"name":"pub fn checked_add(self, rhs: i128) -> Option<i128>","details":{"description":["Checked integer addition. Computes self + rhs, returning None if overflow occurred."],"example":["Basic usage:","assert_eq!((i128::max_value() - 2).checked_add(1), Some(i128::max_value() - 1));\nassert_eq!((i128::max_value() - 2).checked_add(3), None);"]}},{"name":"pub fn checked_sub(self, rhs: i128) -> Option<i128>","details":{"description":["Checked integer subtraction. Computes self - rhs, returning None if overflow occurred."],"example":["Basic usage:","assert_eq!((i128::min_value() + 2).checked_sub(1), Some(i128::min_value() + 1));\nassert_eq!((i128::min_value() + 2).checked_sub(3), None);"]}},{"name":"pub fn checked_mul(self, rhs: i128) -> Option<i128>","details":{"description":["Checked integer multiplication. Computes self * rhs, returning None if overflow occurred."],"example":["Basic usage:","assert_eq!(i128::max_value().checked_mul(1), Some(i128::max_value()));\nassert_eq!(i128::max_value().checked_mul(2), None);"]}},{"name":"pub fn checked_div(self, rhs: i128) -> Option<i128>","details":{"description":["Checked integer division. Computes self / rhs, returning None if rhs == 0 or the division results in overflow."],"example":["Basic usage:","assert_eq!((i128::min_value() + 1).checked_div(-1), Some(170141183460469231731687303715884105727));\nassert_eq!(i128::min_value().checked_div(-1), None);\nassert_eq!((1i128).checked_div(0), None);"]}},{"name":"pub fn checked_div_euc(self, rhs: i128) -> Option<i128>","stability":["🔬 This is a nightly-only experimental API.  (euclidean_division #49048)"]},{"name":"pub fn checked_rem(self, rhs: i128) -> Option<i128>","details":{"description":["Checked integer remainder. Computes self % rhs, returning None if rhs == 0 or the division results in overflow."],"example":["Basic usage:","use std::i128;\n\nassert_eq!(5i128.checked_rem(2), Some(1));\nassert_eq!(5i128.checked_rem(0), None);\nassert_eq!(i128::MIN.checked_rem(-1), None);"]}},{"name":"pub fn checked_mod_euc(self, rhs: i128) -> Option<i128>","stability":["🔬 This is a nightly-only experimental API.  (euclidean_division #49048)"]},{"name":"pub fn checked_neg(self) -> Option<i128>","details":{"description":["Checked negation. Computes -self, returning None if self == MIN."],"example":["Basic usage:","use std::i128;\n\nassert_eq!(5i128.checked_neg(), Some(-5));\nassert_eq!(i128::MIN.checked_neg(), None);"]}},{"name":"pub fn checked_shl(self, rhs: u32) -> Option<i128>","details":{"description":["Checked shift left. Computes self << rhs, returning None if rhs is larger than or equal to the number of bits in self."],"example":["Basic usage:","assert_eq!(0x1i128.checked_shl(4), Some(0x10));\nassert_eq!(0x1i128.checked_shl(129), None);"]}},{"name":"pub fn checked_shr(self, rhs: u32) -> Option<i128>","details":{"description":["Checked shift right. Computes self >> rhs, returning None if rhs is larger than or equal to the number of bits in self."],"example":["Basic usage:","assert_eq!(0x10i128.checked_shr(4), Some(0x1));\nassert_eq!(0x10i128.checked_shr(128), None);"]}},{"name":"pub fn checked_abs(self) -> Option<i128>","details":{"description":["Checked absolute value. Computes self.abs(), returning None if self == MIN."],"example":["Basic usage:","use std::i128;\n\nassert_eq!((-5i128).checked_abs(), Some(5));\nassert_eq!(i128::MIN.checked_abs(), None);"]}},{"name":"pub fn checked_pow(self, exp: u32) -> Option<i128>","stability":["🔬 This is a nightly-only experimental API.  (no_panic_pow #48320)"]},{"name":"pub fn saturating_add(self, rhs: i128) -> i128","details":{"description":["Saturating integer addition. Computes self + rhs, saturating at the numeric bounds instead of overflowing."],"example":["Basic usage:","assert_eq!(100i128.saturating_add(1), 101);\nassert_eq!(i128::max_value().saturating_add(100), i128::max_value());"]}},{"name":"pub fn saturating_sub(self, rhs: i128) -> i128","details":{"description":["Saturating integer subtraction. Computes self - rhs, saturating at the numeric bounds instead of overflowing."],"example":["Basic usage:","assert_eq!(100i128.saturating_sub(127), -27);\nassert_eq!(i128::min_value().saturating_sub(100), i128::min_value());"]}},{"name":"pub fn saturating_mul(self, rhs: i128) -> i128","details":{"description":["Saturating integer multiplication. Computes self * rhs, saturating at the numeric bounds instead of overflowing."],"example":["Basic usage:","use std::i128;\n\nassert_eq!(10i128.saturating_mul(12), 120);\nassert_eq!(i128::MAX.saturating_mul(10), i128::MAX);\nassert_eq!(i128::MIN.saturating_mul(10), i128::MIN);"]}},{"name":"pub fn saturating_pow(self, exp: u32) -> i128","stability":["🔬 This is a nightly-only experimental API.  (no_panic_pow #48320)"]},{"name":"pub const fn wrapping_add(self, rhs: i128) -> i128","details":{"description":["Wrapping (modular) addition. Computes self + rhs, wrapping around at the boundary of the type."],"example":["Basic usage:","assert_eq!(100i128.wrapping_add(27), 127);\nassert_eq!(i128::max_value().wrapping_add(2), i128::min_value() + 1);"]}},{"name":"pub const fn wrapping_sub(self, rhs: i128) -> i128","details":{"description":["Wrapping (modular) subtraction. Computes self - rhs, wrapping around at the boundary of the type."],"example":["Basic usage:","assert_eq!(0i128.wrapping_sub(127), -127);\nassert_eq!((-2i128).wrapping_sub(i128::max_value()), i128::max_value());"]}},{"name":"pub const fn wrapping_mul(self, rhs: i128) -> i128","details":{"description":["Wrapping (modular) multiplication. Computes self * rhs, wrapping around at the boundary of the type."],"example":["Basic usage:","assert_eq!(10i128.wrapping_mul(12), 120);\nassert_eq!(11i8.wrapping_mul(12), -124);"]}},{"name":"pub fn wrapping_div(self, rhs: i128) -> i128","details":{"description":["Wrapping (modular) division. Computes self / rhs, wrapping around at the boundary of the type.","The only case where such wrapping can occur is when one divides MIN / -1 on a signed type (where MIN is the negative minimal value for the type); this is equivalent to -MIN, a positive value that is too large to represent in the type. In such a case, this function returns MIN itself.","Panics","This function will panic if rhs is 0."],"example":["Basic usage:","assert_eq!(100i128.wrapping_div(10), 10);\nassert_eq!((-128i8).wrapping_div(-1), -128);"]}},{"name":"pub fn wrapping_div_euc(self, rhs: i128) -> i128","stability":["🔬 This is a nightly-only experimental API.  (euclidean_division #49048)"]},{"name":"pub fn wrapping_rem(self, rhs: i128) -> i128","details":{"description":["Wrapping (modular) remainder. Computes self % rhs, wrapping around at the boundary of the type.","Such wrap-around never actually occurs mathematically; implementation artifacts make x % y invalid for MIN / -1 on a signed type (where MIN is the negative minimal value). In such a case, this function returns 0.","Panics","This function will panic if rhs is 0."],"example":["Basic usage:","assert_eq!(100i128.wrapping_rem(10), 0);\nassert_eq!((-128i8).wrapping_rem(-1), 0);"]}},{"name":"pub fn wrapping_mod_euc(self, rhs: i128) -> i128","stability":["🔬 This is a nightly-only experimental API.  (euclidean_division #49048)"]},{"name":"pub fn wrapping_neg(self) -> i128","details":{"description":["Wrapping (modular) negation. Computes -self, wrapping around at the boundary of the type.","The only case where such wrapping can occur is when one negates MIN on a signed type (where MIN is the negative minimal value for the type); this is a positive value that is too large to represent in the type. In such a case, this function returns MIN itself."],"example":["Basic usage:","assert_eq!(100i128.wrapping_neg(), -100);\nassert_eq!(i128::min_value().wrapping_neg(), i128::min_value());"]}},{"name":"pub const fn wrapping_shl(self, rhs: u32) -> i128","details":{"description":["Panic-free bitwise shift-left; yields self << mask(rhs), where mask removes any high-order bits of rhs that would cause the shift to exceed the bitwidth of the type.","Note that this is not the same as a rotate-left; the RHS of a wrapping shift-left is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a rotate_left function, which may be what you want instead."],"example":["Basic usage:","assert_eq!((-1i128).wrapping_shl(7), -128);\nassert_eq!((-1i128).wrapping_shl(128), -1);"]}},{"name":"pub const fn wrapping_shr(self, rhs: u32) -> i128","details":{"description":["Panic-free bitwise shift-right; yields self >> mask(rhs), where mask removes any high-order bits of rhs that would cause the shift to exceed the bitwidth of the type.","Note that this is not the same as a rotate-right; the RHS of a wrapping shift-right is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a rotate_right function, which may be what you want instead."],"example":["Basic usage:","assert_eq!((-128i128).wrapping_shr(7), -1);\nassert_eq!((-128i16).wrapping_shr(64), -128);"]}},{"name":"pub fn wrapping_abs(self) -> i128","details":{"description":["Wrapping (modular) absolute value. Computes self.abs(), wrapping around at the boundary of the type.","The only case where such wrapping can occur is when one takes the absolute value of the negative minimal value for the type this is a positive value that is too large to represent in the type. In such a case, this function returns MIN itself."],"example":["Basic usage:","assert_eq!(100i128.wrapping_abs(), 100);\nassert_eq!((-100i128).wrapping_abs(), 100);\nassert_eq!(i128::min_value().wrapping_abs(), i128::min_value());\nassert_eq!((-128i8).wrapping_abs() as u8, 128);"]}},{"name":"pub fn wrapping_pow(self, exp: u32) -> i128","stability":["🔬 This is a nightly-only experimental API.  (no_panic_pow #48320)"]},{"name":"pub const fn overflowing_add(self, rhs: i128) -> (i128, bool)","details":{"description":["Calculates self + rhs","Returns a tuple of the addition along with a boolean indicating whether an arithmetic overflow would occur. If an overflow would have occurred then the wrapped value is returned."],"example":["Basic usage:","use std::i128;\n\nassert_eq!(5i128.overflowing_add(2), (7, false));\nassert_eq!(i128::MAX.overflowing_add(1), (i128::MIN, true));"]}},{"name":"pub const fn overflowing_sub(self, rhs: i128) -> (i128, bool)","details":{"description":["Calculates self - rhs","Returns a tuple of the subtraction along with a boolean indicating whether an arithmetic overflow would occur. If an overflow would have occurred then the wrapped value is returned."],"example":["Basic usage:","use std::i128;\n\nassert_eq!(5i128.overflowing_sub(2), (3, false));\nassert_eq!(i128::MIN.overflowing_sub(1), (i128::MAX, true));"]}},{"name":"pub const fn overflowing_mul(self, rhs: i128) -> (i128, bool)","details":{"description":["Calculates the multiplication of self and rhs.","Returns a tuple of the multiplication along with a boolean indicating whether an arithmetic overflow would occur. If an overflow would have occurred then the wrapped value is returned."],"example":["Basic usage:","assert_eq!(5i128.overflowing_mul(2), (10, false));\nassert_eq!(1_000_000_000i32.overflowing_mul(10), (1410065408, true));"]}},{"name":"pub fn overflowing_div(self, rhs: i128) -> (i128, bool)","details":{"description":["Calculates the divisor when self is divided by rhs.","Returns a tuple of the divisor along with a boolean indicating whether an arithmetic overflow would occur. If an overflow would occur then self is returned.","Panics","This function will panic if rhs is 0."],"example":["Basic usage:","use std::i128;\n\nassert_eq!(5i128.overflowing_div(2), (2, false));\nassert_eq!(i128::MIN.overflowing_div(-1), (i128::MIN, true));"]}},{"name":"pub fn overflowing_div_euc(self, rhs: i128) -> (i128, bool)","stability":["🔬 This is a nightly-only experimental API.  (euclidean_division #49048)"]},{"name":"pub fn overflowing_rem(self, rhs: i128) -> (i128, bool)","details":{"description":["Calculates the remainder when self is divided by rhs.","Returns a tuple of the remainder after dividing along with a boolean indicating whether an arithmetic overflow would occur. If an overflow would occur then 0 is returned.","Panics","This function will panic if rhs is 0."],"example":["Basic usage:","use std::i128;\n\nassert_eq!(5i128.overflowing_rem(2), (1, false));\nassert_eq!(i128::MIN.overflowing_rem(-1), (0, true));"]}},{"name":"pub fn overflowing_mod_euc(self, rhs: i128) -> (i128, bool)","stability":["🔬 This is a nightly-only experimental API.  (euclidean_division #49048)"]},{"name":"pub fn overflowing_neg(self) -> (i128, bool)","details":{"description":["Negates self, overflowing if this is equal to the minimum value.","Returns a tuple of the negated version of self along with a boolean indicating whether an overflow happened. If self is the minimum value (e.g. i32::MIN for values of type i32), then the minimum value will be returned again and true will be returned for an overflow happening."],"example":["Basic usage:","use std::i128;\n\nassert_eq!(2i128.overflowing_neg(), (-2, false));\nassert_eq!(i128::MIN.overflowing_neg(), (i128::MIN, true));"]}},{"name":"pub const fn overflowing_shl(self, rhs: u32) -> (i128, bool)","details":{"description":["Shifts self left by rhs bits.","Returns a tuple of the shifted version of self along with a boolean indicating whether the shift value was larger than or equal to the number of bits. If the shift value is too large, then value is masked (N-1) where N is the number of bits, and this value is then used to perform the shift."],"example":["Basic usage:","assert_eq!(0x1i128.overflowing_shl(4), (0x10, false));\nassert_eq!(0x1i32.overflowing_shl(36), (0x10, true));"]}},{"name":"pub const fn overflowing_shr(self, rhs: u32) -> (i128, bool)","details":{"description":["Shifts self right by rhs bits.","Returns a tuple of the shifted version of self along with a boolean indicating whether the shift value was larger than or equal to the number of bits. If the shift value is too large, then value is masked (N-1) where N is the number of bits, and this value is then used to perform the shift."],"example":["Basic usage:","assert_eq!(0x10i128.overflowing_shr(4), (0x1, false));\nassert_eq!(0x10i32.overflowing_shr(36), (0x1, true));"]}},{"name":"pub fn overflowing_abs(self) -> (i128, bool)","details":{"description":["Computes the absolute value of self.","Returns a tuple of the absolute version of self along with a boolean indicating whether an overflow happened. If self is the minimum value (e.g. i128::MIN for values of type i128), then the minimum value will be returned again and true will be returned for an overflow happening."],"example":["Basic usage:","assert_eq!(10i128.overflowing_abs(), (10, false));\nassert_eq!((-10i128).overflowing_abs(), (10, false));\nassert_eq!((i128::min_value()).overflowing_abs(), (i128::min_value(), true));"]}},{"name":"pub fn overflowing_pow(self, exp: u32) -> (i128, bool)","stability":["🔬 This is a nightly-only experimental API.  (no_panic_pow #48320)"]},{"name":"pub fn pow(self, exp: u32) -> i128","details":{"description":["Raises self to the power of exp, using exponentiation by squaring."],"example":["Basic usage:","let x: i128 = 2; // or any other integer type\n\nassert_eq!(x.pow(5), 32);"]}},{"name":"pub fn div_euc(self, rhs: i128) -> i128","stability":["🔬 This is a nightly-only experimental API.  (euclidean_division #49048)"]},{"name":"pub fn mod_euc(self, rhs: i128) -> i128","stability":["🔬 This is a nightly-only experimental API.  (euclidean_division #49048)"]},{"name":"pub fn abs(self) -> i128","details":{"description":["Computes the absolute value of self.","Overflow behavior","The absolute value of i128::min_value() cannot be represented as an i128, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return i128::min_value() without a panic."],"example":["Basic usage:","assert_eq!(10i128.abs(), 10);\nassert_eq!((-10i128).abs(), 10);"]}},{"name":"pub fn signum(self) -> i128","details":{"description":["Returns a number representing sign of self.","0 if the number is zero 1 if the number is positive -1 if the number is negative"],"example":["Basic usage:","assert_eq!(10i128.signum(), 1);\nassert_eq!(0i128.signum(), 0);\nassert_eq!((-10i128).signum(), -1);"]}},{"name":"pub const fn is_positive(self) -> bool","details":{"description":["Returns true if self is positive and false if the number is zero or negative."],"example":["Basic usage:","assert!(10i128.is_positive());\nassert!(!(-10i128).is_positive());"]}},{"name":"pub const fn is_negative(self) -> bool","details":{"description":["Returns true if self is negative and false if the number is zero or positive."],"example":["Basic usage:","assert!((-10i128).is_negative());\nassert!(!10i128.is_negative());"]}},{"name":"pub const fn to_be_bytes(self) -> [u8; 16]","stability":["🔬 This is a nightly-only experimental API.  (int_to_from_bytes #52963)"]},{"name":"pub const fn to_le_bytes(self) -> [u8; 16]","stability":["🔬 This is a nightly-only experimental API.  (int_to_from_bytes #52963)"]},{"name":"pub const fn to_ne_bytes(self) -> [u8; 16]","stability":["🔬 This is a nightly-only experimental API.  (int_to_from_bytes #52963)"]},{"name":"pub const fn from_be_bytes(bytes: [u8; 16]) -> i128","stability":["🔬 This is a nightly-only experimental API.  (int_to_from_bytes #52963)"]},{"name":"pub const fn from_le_bytes(bytes: [u8; 16]) -> i128","stability":["🔬 This is a nightly-only experimental API.  (int_to_from_bytes #52963)"]},{"name":"pub const fn from_ne_bytes(bytes: [u8; 16]) -> i128","stability":["🔬 This is a nightly-only experimental API.  (int_to_from_bytes #52963)"]}]}