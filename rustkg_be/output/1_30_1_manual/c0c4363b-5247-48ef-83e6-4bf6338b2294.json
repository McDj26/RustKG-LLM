{"stability":{"stable since":"1.0.0"},"apiName":"std::mem::transmute_copy","apiType":"function","apiDocumentation":{"apiDescription":["Interprets src as having type &U, and then reads src without moving the contained value.","This function will unsafely assume the pointer src is valid for size_of::<U> bytes by transmuting &T to &U and then reading the &U. It will also unsafely create a copy of the contained value instead of moving out of src.","It is not a compile-time error if T and U have different sizes, but it is highly encouraged to only invoke this function where T and U have the same size. This function triggers undefined behavior if U is larger than T."],"examples":["use std::mem;\n\n#[repr(packed)]\nstruct Foo {\n    bar: u8,\n}\n\nlet foo_slice = [10u8];\n\nunsafe {\n    // Copy the data from 'foo_slice' and treat it as a 'Foo'\n    let mut foo_struct: Foo = mem::transmute_copy(&foo_slice);\n    assert_eq!(foo_struct.bar, 10);\n\n    // Modify the copied data\n    foo_struct.bar = 20;\n    assert_eq!(foo_struct.bar, 20);\n}\n\n// The contents of 'foo_slice' should not have changed\nassert_eq!(foo_slice, [10]);"]}}