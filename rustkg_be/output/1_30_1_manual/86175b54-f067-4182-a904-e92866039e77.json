{"stability":{"stable since":"1.0.0"},"apiName":"std::fs::File","apiType":"struct","apiDocumentation":{"apiDescription":["A reference to an open file on the filesystem.","An instance of a File can be read and/or written depending on what options it was opened with. Files also implement Seek to alter the logical cursor that the file contains internally.","Files are automatically closed when they go out of scope."],"examples":["Create a new file and write bytes to it:","use std::fs::File;\nuse std::io::prelude::*;\n\nfn main() -> std::io::Result<()> {\n    let mut file = File::create(\"foo.txt\")?;\n    file.write_all(b\"Hello, world!\")?;\n    Ok(())\n}","Read the contents of a file into a String:","use std::fs::File;\nuse std::io::prelude::*;\n\nfn main() -> std::io::Result<()> {\n    let mut file = File::open(\"foo.txt\")?;\n    let mut contents = String::new();\n    file.read_to_string(&mut contents)?;\n    assert_eq!(contents, \"Hello, world!\");\n    Ok(())\n}","It can be more efficient to read the contents of a file with a buffered\nReader. This can be accomplished with BufReader<R>:","use std::fs::File;\nuse std::io::BufReader;\nuse std::io::prelude::*;\n\nfn main() -> std::io::Result<()> {\n    let file = File::open(\"foo.txt\")?;\n    let mut buf_reader = BufReader::new(file);\n    let mut contents = String::new();\n    buf_reader.read_to_string(&mut contents)?;\n    assert_eq!(contents, \"Hello, world!\");\n    Ok(())\n}","Note that, although read and write methods require a &mut File, because\nof the interfaces for Read and Write, the holder of a &File can\nstill modify the file, either through methods that take &File or by\nretrieving the underlying OS object and modifying the file that way.\nAdditionally, many operating systems allow concurrent modification of files\nby different processes. Avoid assuming that holding a &File means that the\nfile will not change."]},"trait implementations":[{"name":"impl std::fmt::Debug for std::fs::File","stable since":"1.0.0"},{"name":"impl std::io::Read for std::fs::File","stable since":"1.0.0"},{"name":"impl std::io::Write for std::fs::File","stable since":"1.0.0"},{"name":"impl std::io::Seek for std::fs::File","stable since":"1.0.0"},{"name":"impl<'a> std::io::Read for &'a std::fs::File","stable since":"1.0.0"},{"name":"impl<'a> std::io::Write for &'a std::fs::File","stable since":"1.0.0"},{"name":"impl<'a> std::io::Seek for &'a std::fs::File","stable since":"1.0.0"},{"name":"impl std::convert::From<std::fs::File> for std::process::Stdio","stable since":"1.20.0"},{"name":"impl std::os::windows::fs::FileExt for std::fs::File","stable since":"1.15.0"},{"name":"impl std::os::windows::io::AsRawHandle for std::fs::File","stable since":"1.0.0"},{"name":"impl std::os::windows::io::FromRawHandle for std::fs::File","stable since":"1.1.0"},{"name":"impl std::os::windows::io::IntoRawHandle for std::fs::File","stable since":"1.4.0"},{"name":"impl std::os::unix::io::AsRawFd for std::fs::File","stable since":"1.0.0"},{"name":"impl std::os::unix::io::FromRawFd for std::fs::File","stable since":"1.1.0"},{"name":"impl std::os::unix::io::IntoRawFd for std::fs::File","stable since":"1.4.0"},{"name":"impl std::os::unix::fs::FileExt for std::fs::File","stable since":"1.15.0"},{"name":"impl std::marker::Send for std::fs::File","stable since":"1.0.0"},{"name":"impl std::marker::Sync for std::fs::File","stable since":"1.0.0"}],"methods":[{"name":"pub fn open<P: AsRef<Path>>(path: P) -> Result<File>","details":{"description":["Attempts to open a file in read-only mode.","See the OpenOptions::open method for more details.","Errors","This function will return an error if path does not already exist. Other errors may also be returned according to OpenOptions::open."],"example":["use std::fs::File;\n\nfn main() -> std::io::Result<()> {\n    let mut f = File::open(\"foo.txt\")?;\n    Ok(())\n}"]}},{"name":"pub fn create<P: AsRef<Path>>(path: P) -> Result<File>","details":{"description":["Opens a file in write-only mode.","This function will create a file if it does not exist, and will truncate it if it does.","See the OpenOptions::open function for more details."],"example":["use std::fs::File;\n\nfn main() -> std::io::Result<()> {\n    let mut f = File::create(\"foo.txt\")?;\n    Ok(())\n}"]}},{"name":"pub fn sync_all(&self) -> Result<()>","details":{"description":["Attempts to sync all OS-internal metadata to disk.","This function will attempt to ensure that all in-core data reaches the filesystem before returning."],"example":["use std::fs::File;\nuse std::io::prelude::*;\n\nfn main() -> std::io::Result<()> {\n    let mut f = File::create(\"foo.txt\")?;\n    f.write_all(b\"Hello, world!\")?;\n\n    f.sync_all()?;\n    Ok(())\n}"]}},{"name":"pub fn sync_data(&self) -> Result<()>","details":{"description":["This function is similar to sync_all, except that it may not synchronize file metadata to the filesystem.","This is intended for use cases that must synchronize content, but don't need the metadata on disk. The goal of this method is to reduce disk operations.","Note that some platforms may simply implement this in terms of sync_all."],"example":["use std::fs::File;\nuse std::io::prelude::*;\n\nfn main() -> std::io::Result<()> {\n    let mut f = File::create(\"foo.txt\")?;\n    f.write_all(b\"Hello, world!\")?;\n\n    f.sync_data()?;\n    Ok(())\n}"]}},{"name":"pub fn set_len(&self, size: u64) -> Result<()>","details":{"description":["Truncates or extends the underlying file, updating the size of this file to become size.","If the size is less than the current file's size, then the file will be shrunk. If it is greater than the current file's size, then the file will be extended to size and have all of the intermediate data filled in with 0s.","The file's cursor isn't changed. In particular, if the cursor was at the end and the file is shrunk using this operation, the cursor will now be past the end.","Errors","This function will return an error if the file is not opened for writing."],"example":["use std::fs::File;\n\nfn main() -> std::io::Result<()> {\n    let mut f = File::create(\"foo.txt\")?;\n    f.set_len(10)?;\n    Ok(())\n}","Note that this method alters the content of the underlying file, even\nthough it takes &self rather than &mut self."]}},{"name":"pub fn metadata(&self) -> Result<Metadata>","details":{"description":["Queries metadata about the underlying file."],"example":["use std::fs::File;\n\nfn main() -> std::io::Result<()> {\n    let mut f = File::open(\"foo.txt\")?;\n    let metadata = f.metadata()?;\n    Ok(())\n}"]}},{"name":"pub fn try_clone(&self) -> Result<File>","details":{"description":["Create a new File instance that shares the same underlying file handle as the existing File instance. Reads, writes, and seeks will affect both File instances simultaneously."],"example":["Create two handles for a file named foo.txt:","use std::fs::File;\n\nfn main() -> std::io::Result<()> {\n    let mut file = File::open(\"foo.txt\")?;\n    let file_copy = file.try_clone()?;\n    Ok(())\n}","Assuming thereâ€™s a file named foo.txt with contents abcdef\\n, create\ntwo handles, seek one of them, and read the remaining bytes from the\nother handle:","use std::fs::File;\nuse std::io::SeekFrom;\nuse std::io::prelude::*;\n\nfn main() -> std::io::Result<()> {\n    let mut file = File::open(\"foo.txt\")?;\n    let mut file_copy = file.try_clone()?;\n\n    file.seek(SeekFrom::Start(3))?;\n\n    let mut contents = vec![];\n    file_copy.read_to_end(&mut contents)?;\n    assert_eq!(contents, b\"def\\n\");\n    Ok(())\n}"]}},{"name":"pub fn set_permissions(&self, perm: Permissions) -> Result<()>","details":{"description":["Changes the permissions on the underlying file.","Platform-specific behavior","This function currently corresponds to the fchmod function on Unix and the SetFileInformationByHandle function on Windows. Note that, this may change in the future.","Errors","This function will return an error if the user lacks permission change attributes on the underlying file. It may also return an error in other os-specific unspecified cases."],"example":["fn main() -> std::io::Result<()> {\n    use std::fs::File;\n\n    let file = File::open(\"foo.txt\")?;\n    let mut perms = file.metadata()?.permissions();\n    perms.set_readonly(true);\n    file.set_permissions(perms)?;\n    Ok(())\n}","Note that this method alters the permissions of the underlying file,\neven though it takes &self rather than &mut self."]}}]}