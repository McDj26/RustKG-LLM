{"stability":{"stable since":"1.28.0"},"apiName":"std::iter::repeat_with","apiType":"function","apiDocumentation":{"apiDescription":["Creates a new iterator that repeats elements of type A endlessly by applying the provided closure, the repeater, F: FnMut() -> A.","The repeat_with() function calls the repeater over and over and over and over and over and üîÅ.","Infinite iterators like repeat_with() are often used with adapters like take, in order to make them finite.","If the element type of the iterator you need implements Clone, and it is OK to keep the source element in memory, you should instead use the repeat function.","An iterator produced by repeat_with() is not a DoubleEndedIterator. If you need repeat_with() to return a DoubleEndedIterator, please open a GitHub issue explaining your use case."],"examples":["Basic usage:","use std::iter;\n\n// let's assume we have some value of a type that is not `Clone`\n// or which don't want to have in memory just yet because it is expensive:\n#[derive(PartialEq, Debug)]\nstruct Expensive;\n\n// a particular value forever:\nlet mut things = iter::repeat_with(|| Expensive);\n\nassert_eq!(Some(Expensive), things.next());\nassert_eq!(Some(Expensive), things.next());\nassert_eq!(Some(Expensive), things.next());\nassert_eq!(Some(Expensive), things.next());\nassert_eq!(Some(Expensive), things.next());","Using mutation and going finite:","use std::iter;\n\n// From the zeroth to the third power of two:\nlet mut curr = 1;\nlet mut pow2 = iter::repeat_with(|| { let tmp = curr; curr *= 2; tmp })\n                    .take(4);\n\nassert_eq!(Some(1), pow2.next());\nassert_eq!(Some(2), pow2.next());\nassert_eq!(Some(4), pow2.next());\nassert_eq!(Some(8), pow2.next());\n\n// ... and now we're done\nassert_eq!(None, pow2.next());"]}}