{"stability":{"stable since":"1.0.0"},"apiName":"std::collections::binary_heap","apiType":"module","apiDocumentation":{"apiDescription":["A priority queue implemented with a binary heap.","Insertion and popping the largest element have O(log n) time complexity. Checking the largest element is O(1). Converting a vector to a binary heap can be done in-place, and has O(n) complexity. A binary heap can also be converted to a sorted vector in-place, allowing it to be used for an O(n log n) in-place heapsort."],"examples":["This is a larger example that implements Dijkstra's algorithm\nto solve the shortest path problem on a directed graph.\nIt shows how to use BinaryHeap with custom types.","use std::cmp::Ordering;\nuse std::collections::BinaryHeap;\nuse std::usize;\n\n#[derive(Copy, Clone, Eq, PartialEq)]\nstruct State {\n    cost: usize,\n    position: usize,\n}\n\n// The priority queue depends on `Ord`.\n// Explicitly implement the trait so the queue becomes a min-heap\n// instead of a max-heap.\nimpl Ord for State {\n    fn cmp(&self, other: &State) -> Ordering {\n        // Notice that the we flip the ordering on costs.\n        // In case of a tie we compare positions - this step is necessary\n        // to make implementations of `PartialEq` and `Ord` consistent.\n        other.cost.cmp(&self.cost)\n            .then_with(|| self.position.cmp(&other.position))\n    }\n}\n\n// `PartialOrd` needs to be implemented as well.\nimpl PartialOrd for State {\n    fn partial_cmp(&self, other: &State) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\n// Each node is represented as an `usize`, for a shorter implementation.\nstruct Edge {\n    node: usize,\n    cost: usize,\n}\n\n// Dijkstra's shortest path algorithm.\n\n// Start at `start` and use `dist` to track the current shortest distance\n// to each node. This implementation isn't memory-efficient as it may leave duplicate\n// nodes in the queue. It also uses `usize::MAX` as a sentinel value,\n// for a simpler implementation.\nfn shortest_path(adj_list: &Vec<Vec<Edge>>, start: usize, goal: usize) -> Option<usize> {\n    // dist[node] = current shortest distance from `start` to `node`\n    let mut dist: Vec<_> = (0..adj_list.len()).map(|_| usize::MAX).collect();\n\n    let mut heap = BinaryHeap::new();\n\n    // We're at `start`, with a zero cost\n    dist[start] = 0;\n    heap.push(State { cost: 0, position: start });\n\n    // Examine the frontier with lower cost nodes first (min-heap)\n    while let Some(State { cost, position }) = heap.pop() {\n        // Alternatively we could have continued to find all shortest paths\n        if position == goal { return Some(cost); }\n\n        // Important as we may have already found a better way\n        if cost > dist[position] { continue; }\n\n        // For each node we can reach, see if we can find a way with\n        // a lower cost going through this node\n        for edge in &adj_list[position] {\n            let next = State { cost: cost + edge.cost, position: edge.node };\n\n            // If so, add it to the frontier and continue\n            if next.cost < dist[next.position] {\n                heap.push(next);\n                // Relaxation, we have now found a better way\n                dist[next.position] = next.cost;\n            }\n        }\n    }\n\n    // Goal not reachable\n    None\n}\n\nfn main() {\n    // This is the directed graph we're going to use.\n    // The node numbers correspond to the different states,\n    // and the edge weights symbolize the cost of moving\n    // from one node to another.\n    // Note that the edges are one-way.\n    //\n    //                  7\n    //          +-----------------+\n    //          |                 |\n    //          v   1        2    |  2\n    //          0 -----> 1 -----> 3 ---> 4\n    //          |        ^        ^      ^\n    //          |        | 1      |      |\n    //          |        |        | 3    | 1\n    //          +------> 2 -------+      |\n    //           10      |               |\n    //                   +---------------+\n    //\n    // The graph is represented as an adjacency list where each index,\n    // corresponding to a node value, has a list of outgoing edges.\n    // Chosen for its efficiency.\n    let graph = vec![\n        // Node 0\n        vec![Edge { node: 2, cost: 10 },\n             Edge { node: 1, cost: 1 }],\n        // Node 1\n        vec![Edge { node: 3, cost: 2 }],\n        // Node 2\n        vec![Edge { node: 1, cost: 1 },\n             Edge { node: 3, cost: 3 },\n             Edge { node: 4, cost: 1 }],\n        // Node 3\n        vec![Edge { node: 0, cost: 7 },\n             Edge { node: 4, cost: 2 }],\n        // Node 4\n        vec![]];\n\n    assert_eq!(shortest_path(&graph, 0, 1), Some(1));\n    assert_eq!(shortest_path(&graph, 0, 3), Some(3));\n    assert_eq!(shortest_path(&graph, 3, 0), Some(7));\n    assert_eq!(shortest_path(&graph, 0, 4), Some(5));\n    assert_eq!(shortest_path(&graph, 4, 0), None);\n}"]},"children":["std::collections::binary_heap::BinaryHeap","std::collections::binary_heap::Drain","std::collections::binary_heap::IntoIter","std::collections::binary_heap::Iter","std::collections::binary_heap::PeekMut"]}