{"stability":{"stable since":"1.0.0"},"apiName":"std::io","apiType":"module","apiDocumentation":{"apiDescription":["Traits, helpers, and type definitions for core I/O functionality.","The std::io module contains a number of common things you'll need when doing input and output. The most core part of this module is the Read and Write traits, which provide the most general interface for reading and writing input and output.","Read and Write","Because they are traits, Read and Write are implemented by a number of other types, and you can implement them for your types too. As such, you'll see a few different types of I/O throughout the documentation in this module: Files, TcpStreams, and sometimes even Vec<T>s. For example, Read adds a read method, which we can use on Files:","use std::io; use std::io::prelude::*; use std::fs::File; fn main() -> io::Result<()> { let mut f = File::open(\"foo.txt\")?; let mut buffer = [0; 10]; // read up to 10 bytes f.read(&mut buffer)?; println!(\"The bytes: {:?}\", buffer); Ok(()) }","Read and Write are so important, implementors of the two traits have a nickname: readers and writers. So you'll sometimes see 'a reader' instead of 'a type that implements the Read trait'. Much easier!","Seek and BufRead","Beyond that, there are two important traits that are provided: Seek and BufRead. Both of these build on top of a reader to control how the reading happens. Seek lets you control where the next byte is coming from:","use std::io; use std::io::prelude::*; use std::io::SeekFrom; use std::fs::File; fn main() -> io::Result<()> { let mut f = File::open(\"foo.txt\")?; let mut buffer = [0; 10]; // skip to the last 10 bytes of the file f.seek(SeekFrom::End(-10))?; // read up to 10 bytes f.read(&mut buffer)?; println!(\"The bytes: {:?}\", buffer); Ok(()) }","BufRead uses an internal buffer to provide a number of other ways to read, but to show it off, we'll need to talk about buffers in general. Keep reading!","BufReader and BufWriter","Byte-based interfaces are unwieldy and can be inefficient, as we'd need to be making near-constant calls to the operating system. To help with this, std::io comes with two structs, BufReader and BufWriter, which wrap readers and writers. The wrapper uses a buffer, reducing the number of calls and providing nicer methods for accessing exactly what you want.","For example, BufReader works with the BufRead trait to add extra methods to any reader:","use std::io; use std::io::prelude::*; use std::io::BufReader; use std::fs::File; fn main() -> io::Result<()> { let f = File::open(\"foo.txt\")?; let mut reader = BufReader::new(f); let mut buffer = String::new(); // read a line into buffer reader.read_line(&mut buffer)?; println!(\"{}\", buffer); Ok(()) }","BufWriter doesn't add any new ways of writing; it just buffers every call to write:","use std::io; use std::io::prelude::*; use std::io::BufWriter; use std::fs::File; fn main() -> io::Result<()> { let f = File::create(\"foo.txt\")?; { let mut writer = BufWriter::new(f); // write a byte to the buffer writer.write(&[42])?; } // the buffer is flushed once writer goes out of scope Ok(()) }","Standard input and output","A very common source of input is standard input:","use std::io; fn main() -> io::Result<()> { let mut input = String::new(); io::stdin().read_line(&mut input)?; println!(\"You typed: {}\", input.trim()); Ok(()) }","Note that you cannot use the ? operator in functions that do not return a Result<T, E>. Instead, you can call .unwrap() or match on the return value to catch any possible errors:","use std::io; let mut input = String::new(); io::stdin().read_line(&mut input).unwrap();","And a very common source of output is standard output:","use std::io; use std::io::prelude::*; fn main() -> io::Result<()> { io::stdout().write(&[42])?; Ok(()) }","Of course, using io::stdout directly is less common than something like println!.","Iterator types","A large number of the structures provided by std::io are for various ways of iterating over I/O. For example, Lines is used to split over lines:","use std::io; use std::io::prelude::*; use std::io::BufReader; use std::fs::File; fn main() -> io::Result<()> { let f = File::open(\"foo.txt\")?; let reader = BufReader::new(f); for line in reader.lines() { println!(\"{}\", line?); } Ok(()) }","Functions","There are a number of functions that offer access to various features. For example, we can use three of these functions to copy everything from standard input to standard output:","use std::io; fn main() -> io::Result<()> { io::copy(&mut io::stdin(), &mut io::stdout())?; Ok(()) }","io::Result","Last, but certainly not least, is io::Result. This type is used as the return type of many std::io functions that can cause an error, and can be returned from your own functions as well. Many of the examples in this module use the ? operator:","use std::io; fn read_input() -> io::Result<()> { let mut input = String::new(); io::stdin().read_line(&mut input)?; println!(\"You typed: {}\", input.trim()); Ok(()) }","The return type of read_input(), io::Result<()>, is a very common type for functions which don't have a 'real' return value, but do want to return errors if they happen. In this case, the only purpose of this function is to read the line and print it, so we use ().","Platform-specific behavior","Many I/O functions throughout the standard library are documented to indicate what various library or syscalls they are delegated to. This is done to help applications both understand what's happening under the hood as well as investigate any possibly unclear semantics. Note, however, that this is informative, not a binding contract. The implementation of many of these functions are subject to change over time and may call fewer or more syscalls/library functions."]},"children":["std::io::prelude","std::io::BufReader","std::io::BufWriter","std::io::Bytes","std::io::Chain","std::io::Cursor","std::io::Empty","std::io::Error","std::io::IntoInnerError","std::io::LineWriter","std::io::Lines","std::io::Repeat","std::io::Sink","std::io::Split","std::io::Stderr","std::io::StderrLock","std::io::Stdin","std::io::StdinLock","std::io::Stdout","std::io::StdoutLock","std::io::Take","std::io::Initializer","std::io::ErrorKind","std::io::SeekFrom","std::io::BufRead","std::io::Read","std::io::Seek","std::io::Write","std::io::copy","std::io::empty","std::io::repeat","std::io::sink","std::io::stderr","std::io::stdin","std::io::stdout","std::io::Result"]}