{"stability":{"stable since":"1.5.0"},"apiName":"std::sync::WaitTimeoutResult","apiType":"struct","apiDocumentation":{"apiDescription":["A type indicating whether a timed wait on a condition variable returned due to a time out or not.","It is returned by the wait_timeout method."]},"trait implementations":[{"name":"impl std::fmt::Debug for std::sync::WaitTimeoutResult","stable since":"1.0.0"},{"name":"impl std::cmp::PartialEq for std::sync::WaitTimeoutResult","stable since":"1.0.0"},{"name":"impl std::cmp::Eq for std::sync::WaitTimeoutResult","stable since":"1.0.0"},{"name":"impl std::marker::Copy for std::sync::WaitTimeoutResult","stable since":"1.0.0"},{"name":"impl std::clone::Clone for std::sync::WaitTimeoutResult","stable since":"1.0.0"},{"name":"impl std::marker::Send for std::sync::WaitTimeoutResult","stable since":"1.0.0"},{"name":"impl std::marker::Sync for std::sync::WaitTimeoutResult","stable since":"1.0.0"}],"methods":[{"name":"pub fn timed_out(&self) -> bool","details":{"description":["Returns whether the wait was known to have timed out."],"example":["This example spawns a thread which will update the boolean value and\nthen wait 100 milliseconds before notifying the condvar.","The main thread will wait with a timeout on the condvar and then leave\nonce the boolean has been updated and notified.","use std::sync::{Arc, Mutex, Condvar};\nuse std::thread;\nuse std::time::Duration;\n\nlet pair = Arc::new((Mutex::new(false), Condvar::new()));\nlet pair2 = pair.clone();\n\nthread::spawn(move|| {\n    let &(ref lock, ref cvar) = &*pair2;\n\n    // Let's wait 20 milliseconds before notifying the condvar.\n    thread::sleep(Duration::from_millis(20));\n\n    let mut started = lock.lock().unwrap();\n    // We update the boolean value.\n    *started = true;\n    cvar.notify_one();\n});\n\n// Wait for the thread to start up.\nlet &(ref lock, ref cvar) = &*pair;\nlet mut started = lock.lock().unwrap();\nloop {\n    // Let's put a timeout on the condvar's wait.\n    let result = cvar.wait_timeout(started, Duration::from_millis(10)).unwrap();\n    // 10 milliseconds have passed, or maybe the value changed!\n    started = result.0;\n    if *started == true {\n        // We received the notification and the value has been updated, we can leave.\n        break\n    }\n}"]}}]}