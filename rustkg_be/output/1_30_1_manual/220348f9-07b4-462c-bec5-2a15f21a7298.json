{"stability":{"stable since":"1.0.0"},"apiName":"std::cell::UnsafeCell","apiType":"struct","apiDocumentation":{"apiDescription":["The core primitive for interior mutability in Rust.","UnsafeCell<T> is a type that wraps some T and indicates unsafe interior operations on the wrapped type. Types with an UnsafeCell<T> field are considered to have an 'unsafe interior'. The UnsafeCell<T> type is the only legal way to obtain aliasable data that is considered mutable. In general, transmuting an &T type into an &mut T is considered undefined behavior.","If you have a reference &SomeStruct, then normally in Rust all fields of SomeStruct are immutable. The compiler makes optimizations based on the knowledge that &T is not mutably aliased or mutated, and that &mut T is unique. UnsafeCell<T> is the only core language feature to work around this restriction. All other types that allow internal mutability, such as Cell<T> and RefCell<T>, use UnsafeCell to wrap their internal data.","The UnsafeCell API itself is technically very simple: it gives you a raw pointer *mut T to its contents. It is up to you as the abstraction designer to use that raw pointer correctly.","The precise Rust aliasing rules are somewhat in flux, but the main points are not contentious:","If you create a safe reference with lifetime 'a (either a &T or &mut T reference) that is accessible by safe code (for example, because you returned it), then you must not access the data in any way that contradicts that reference for the remainder of 'a. For example, this means that if you take the *mut T from an UnsafeCell<T> and cast it to an &T, then the data in T must remain immutable (modulo any UnsafeCell data found within T, of course) until that reference's lifetime expires. Similarly, if you create a &mut T reference that is released to safe code, then you must not access the data within the UnsafeCell until that reference expires. At all times, you must avoid data races. If multiple threads have access to the same UnsafeCell, then any writes must have a proper happens-before relation to all other accesses (or use atomics).","To assist with proper design, the following scenarios are explicitly declared legal for single-threaded code:","A &T reference can be released to safe code and there it can co-exist with other &T references, but not with a &mut T A &mut T reference may be released to safe code provided neither other &mut T nor &T co-exist with it. A &mut T must always be unique.","Note that while mutating or mutably aliasing the contents of an &UnsafeCell<T> is okay (provided you enforce the invariants some other way), it is still undefined behavior to have multiple &mut UnsafeCell<T> aliases."],"examples":["use std::cell::UnsafeCell;\nuse std::marker::Sync;\n\nstruct NotThreadSafe<T> {\n    value: UnsafeCell<T>,\n}\n\nunsafe impl<T> Sync for NotThreadSafe<T> {}"]},"trait implementations":[{"name":"impl<T> std::fmt::Debug for std::cell::UnsafeCell<T> where T: std::fmt::Debug + ?std::marker::Sized","stable since":"1.9.0"},{"name":"impl<T, U> std::ops::CoerceUnsized<std::cell::UnsafeCell<U>> for std::cell::UnsafeCell<T> where T: std::ops::CoerceUnsized<U>","stable since":"1.0.0"},{"name":"impl<T> std::convert::From<T> for std::cell::UnsafeCell<T>","stable since":"1.12.0"},{"name":"impl<T> !std::marker::Sync for std::cell::UnsafeCell<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::default::Default for std::cell::UnsafeCell<T> where T: std::default::Default","stable since":"1.10.0"},{"name":"impl<T: ?std::marker::Sized> !std::panic::RefUnwindSafe for std::cell::UnsafeCell<T>","stable since":"1.9.0"},{"name":"impl<T: ?std::marker::Sized> std::marker::Send for std::cell::UnsafeCell<T> where T: std::marker::Send","stable since":"1.0.0"}],"methods":[{"name":"pub const fn new(value: T) -> UnsafeCell<T>","details":{"description":["Constructs a new instance of UnsafeCell which will wrap the specified value.","All access to the inner value through methods is unsafe."],"example":["use std::cell::UnsafeCell;\n\nlet uc = UnsafeCell::new(5);"]}},{"name":"pub fn into_inner(self) -> T","details":{"description":["Unwraps the value."],"example":["use std::cell::UnsafeCell;\n\nlet uc = UnsafeCell::new(5);\n\nlet five = uc.into_inner();"]}},{"name":"pub fn get(&self) -> *mut T","details":{"description":["Gets a mutable pointer to the wrapped value.","This can be cast to a pointer of any kind. Ensure that the access is unique (no active references, mutable or not) when casting to &mut T, and ensure that there are no mutations or mutable aliases going on when casting to &T"],"example":["use std::cell::UnsafeCell;\n\nlet uc = UnsafeCell::new(5);\n\nlet five = uc.get();"]}}]}