{"stability":{"stable since":"1.0.0"},"apiName":"std::str::Utf8Error","apiType":"struct","apiDocumentation":{"apiDescription":["Errors which can occur when attempting to interpret a sequence of u8 as a string.","As such, the from_utf8 family of functions and methods for both Strings and &strs make use of this error, for example."],"examples":["This error typeâ€™s methods can be used to create functionality\nsimilar to String::from_utf8_lossy without allocating heap memory:","fn from_utf8_lossy<F>(mut input: &[u8], mut push: F) where F: FnMut(&str) {\n    loop {\n        match ::std::str::from_utf8(input) {\n            Ok(valid) => {\n                push(valid);\n                break\n            }\n            Err(error) => {\n                let (valid, after_valid) = input.split_at(error.valid_up_to());\n                unsafe {\n                    push(::std::str::from_utf8_unchecked(valid))\n                }\n                push(\"\\u{FFFD}\");\n\n                if let Some(invalid_sequence_length) = error.error_len() {\n                    input = &after_valid[invalid_sequence_length..]\n                } else {\n                    break\n                }\n            }\n        }\n    }\n}"]},"trait implementations":[{"name":"impl std::clone::Clone for std::str::Utf8Error","stable since":"1.0.0"},{"name":"impl std::fmt::Debug for std::str::Utf8Error","stable since":"1.0.0"},{"name":"impl std::cmp::Eq for std::str::Utf8Error","stable since":"1.0.0"},{"name":"impl std::cmp::PartialEq<std::str::Utf8Error> for std::str::Utf8Error","stable since":"1.0.0"},{"name":"impl std::marker::Copy for std::str::Utf8Error","stable since":"1.0.0"},{"name":"impl std::fmt::Display for std::str::Utf8Error","stable since":"1.0.0"},{"name":"impl std::error::Error for std::str::Utf8Error","stable since":"1.0.0"},{"name":"impl std::marker::Send for std::str::Utf8Error","stable since":"1.0.0"},{"name":"impl std::marker::Sync for std::str::Utf8Error","stable since":"1.0.0"}],"methods":[{"name":"pub fn valid_up_to(&self) -> usize","details":{"description":["Returns the index in the given string up to which valid UTF-8 was verified.","It is the maximum index such that from_utf8(&input[..index]) would return Ok(_)."],"example":["Basic usage:","use std::str;\n\n// some invalid bytes, in a vector\nlet sparkle_heart = vec![0, 159, 146, 150];\n\n// std::str::from_utf8 returns a Utf8Error\nlet error = str::from_utf8(&sparkle_heart).unwrap_err();\n\n// the second byte is invalid here\nassert_eq!(1, error.valid_up_to());"]}},{"name":"pub fn error_len(&self) -> Option<usize>","details":{"description":["Provide more information about the failure:","None: the end of the input was reached unexpectedly. self.valid_up_to() is 1 to 3 bytes from the end of the input. If a byte stream (such as a file or a network socket) is being decoded incrementally, this could be a valid char whose UTF-8 byte sequence is spanning multiple chunks. Some(len): an unexpected byte was encountered. The length provided is that of the invalid byte sequence that starts at the index given by valid_up_to(). Decoding should resume after that sequence (after inserting a U+FFFD REPLACEMENT CHARACTER) in case of lossy decoding."]}}]}