{"stability":{"stable since":"1.0.0"},"apiName":"std::ops::Mul","apiType":"trait","apiDocumentation":{"apiDescription":["The multiplication operator *.","Note that RHS is Self by default, but this is not mandatory."],"examples":["Multipliable rational numbers","use std::ops::Mul;\n\n// By the fundamental theorem of arithmetic, rational numbers in lowest\n// terms are unique. So, by keeping `Rational`s in reduced form, we can\n// derive `Eq` and `PartialEq`.\n#[derive(Debug, Eq, PartialEq)]\nstruct Rational {\n    nominator: usize,\n    denominator: usize,\n}\n\nimpl Rational {\n    fn new(nominator: usize, denominator: usize) -> Self {\n        if denominator == 0 {\n            panic!(\"Zero is an invalid denominator!\");\n        }\n\n        // Reduce to lowest terms by dividing by the greatest common\n        // divisor.\n        let gcd = gcd(nominator, denominator);\n        Rational {\n            nominator: nominator / gcd,\n            denominator: denominator / gcd,\n        }\n    }\n}\n\nimpl Mul for Rational {\n    // The multiplication of rational numbers is a closed operation.\n    type Output = Self;\n\n    fn mul(self, rhs: Self) -> Self {\n        let nominator = self.nominator * rhs.nominator;\n        let denominator = self.denominator * rhs.denominator;\n        Rational::new(nominator, denominator)\n    }\n}\n\n// Euclid's two-thousand-year-old algorithm for finding the greatest common\n// divisor.\nfn gcd(x: usize, y: usize) -> usize {\n    let mut x = x;\n    let mut y = y;\n    while y != 0 {\n        let t = y;\n        y = x % y;\n        x = t;\n    }\n    x\n}\n\nassert_eq!(Rational::new(1, 2), Rational::new(2, 4));\nassert_eq!(Rational::new(2, 3) * Rational::new(3, 4),\n           Rational::new(1, 2));","Multiplying vectors by scalars as in linear algebra","use std::ops::Mul;\n\nstruct Scalar { value: usize }\n\n#[derive(Debug, PartialEq)]\nstruct Vector { value: Vec<usize> }\n\nimpl Mul<Scalar> for Vector {\n    type Output = Vector;\n\n    fn mul(self, rhs: Scalar) -> Vector {\n        Vector { value: self.value.iter().map(|v| v * rhs.value).collect() }\n    }\n}\n\nlet vector = Vector { value: vec![2, 4, 6] };\nlet scalar = Scalar { value: 3 };\nassert_eq!(vector * scalar, Vector { value: vec![6, 12, 18] });"]},"trait required methods":[{"name":"[+] Expand attributes#[must_use] fn mul(self, rhs: RHS) -> Self::Output","details":{"description":"Performs the * operation."}}]}