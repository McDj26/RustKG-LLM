{"stability":{"stable since":"1.0.0"},"apiName":"std::ops::Div","apiType":"trait","apiDocumentation":{"apiDescription":["The division operator /.","Note that RHS is Self by default, but this is not mandatory."],"examples":["Dividable rational numbers","use std::ops::Div;\n\n// By the fundamental theorem of arithmetic, rational numbers in lowest\n// terms are unique. So, by keeping `Rational`s in reduced form, we can\n// derive `Eq` and `PartialEq`.\n#[derive(Debug, Eq, PartialEq)]\nstruct Rational {\n    nominator: usize,\n    denominator: usize,\n}\n\nimpl Rational {\n    fn new(nominator: usize, denominator: usize) -> Self {\n        if denominator == 0 {\n            panic!(\"Zero is an invalid denominator!\");\n        }\n\n        // Reduce to lowest terms by dividing by the greatest common\n        // divisor.\n        let gcd = gcd(nominator, denominator);\n        Rational {\n            nominator: nominator / gcd,\n            denominator: denominator / gcd,\n        }\n    }\n}\n\nimpl Div for Rational {\n    // The division of rational numbers is a closed operation.\n    type Output = Self;\n\n    fn div(self, rhs: Self) -> Self {\n        if rhs.nominator == 0 {\n            panic!(\"Cannot divide by zero-valued `Rational`!\");\n        }\n\n        let nominator = self.nominator * rhs.denominator;\n        let denominator = self.denominator * rhs.nominator;\n        Rational::new(nominator, denominator)\n    }\n}\n\n// Euclid's two-thousand-year-old algorithm for finding the greatest common\n// divisor.\nfn gcd(x: usize, y: usize) -> usize {\n    let mut x = x;\n    let mut y = y;\n    while y != 0 {\n        let t = y;\n        y = x % y;\n        x = t;\n    }\n    x\n}\n\nassert_eq!(Rational::new(1, 2), Rational::new(2, 4));\nassert_eq!(Rational::new(1, 2) / Rational::new(3, 4),\n           Rational::new(2, 3));","Dividing vectors by scalars as in linear algebra","use std::ops::Div;\n\nstruct Scalar { value: f32 }\n\n#[derive(Debug, PartialEq)]\nstruct Vector { value: Vec<f32> }\n\nimpl Div<Scalar> for Vector {\n    type Output = Vector;\n\n    fn div(self, rhs: Scalar) -> Vector {\n        Vector { value: self.value.iter().map(|v| v / rhs.value).collect() }\n    }\n}\n\nlet scalar = Scalar { value: 2f32 };\nlet vector = Vector { value: vec![2f32, 4f32, 6f32] };\nassert_eq!(vector / scalar, Vector { value: vec![1f32, 2f32, 3f32] });"]},"trait required methods":[{"name":"[+] Expand attributes#[must_use] fn div(self, rhs: RHS) -> Self::Output","details":{"description":"Performs the / operation."}}]}