{"stability":{"stable since":"1.0.0"},"apiName":"std::process::Child","apiType":"struct","apiDocumentation":{"apiDescription":["Representation of a running or exited child process.","This structure is used to represent and manage child processes. A child process is created via the Command struct, which configures the spawning process and can itself be constructed using a builder-style interface.","There is no implementation of Drop for child processes, so if you do not ensure the Child has exited then it will continue to run, even after the Child handle to the child process has gone out of scope.","Calling wait (or other functions that wrap around it) will make the parent process wait until the child has actually exited before continuing."],"examples":["use std::process::Command;\n\nlet mut child = Command::new(\"/bin/cat\")\n                        .arg(\"file.txt\")\n                        .spawn()\n                        .expect(\"failed to execute child\");\n\nlet ecode = child.wait()\n                 .expect(\"failed to wait on child\");\n\nassert!(ecode.success());"]},"trait implementations":[{"name":"impl std::fmt::Debug for std::process::Child","stable since":"1.16.0"},{"name":"impl std::os::windows::io::AsRawHandle for std::process::Child","stable since":"1.2.0"},{"name":"impl std::os::windows::io::IntoRawHandle for std::process::Child","stable since":"1.4.0"},{"name":"impl std::marker::Send for std::process::Child","stable since":"1.0.0"},{"name":"impl std::marker::Sync for std::process::Child","stable since":"1.0.0"}],"methods":[{"name":"pub fn kill(&mut self) -> Result<()>","details":{"description":["Forces the child process to exit. If the child has already exited, an InvalidInput error is returned.","The mapping to ErrorKinds is not part of the compatibility contract of the function, especially the Other kind might change to more specific kinds in the future.","This is equivalent to sending a SIGKILL on Unix platforms."],"example":["Basic usage:","use std::process::Command;\n\nlet mut command = Command::new(\"yes\");\nif let Ok(mut child) = command.spawn() {\n    child.kill().expect(\"command wasn't running\");\n} else {\n    println!(\"yes command didn't start\");\n}"]}},{"name":"pub fn id(&self) -> u32","details":{"description":["Returns the OS-assigned process identifier associated with this child."],"example":["Basic usage:","use std::process::Command;\n\nlet mut command = Command::new(\"ls\");\nif let Ok(child) = command.spawn() {\n    println!(\"Child's id is {}\", child.id());\n} else {\n    println!(\"ls command didn't start\");\n}"]}},{"name":"pub fn wait(&mut self) -> Result<ExitStatus>","details":{"description":["Waits for the child to exit completely, returning the status that it exited with. This function will continue to have the same return value after it has been called at least once.","The stdin handle to the child process, if any, will be closed before waiting. This helps avoid deadlock: it ensures that the child does not block waiting for input from the parent, while the parent waits for the child to exit."],"example":["Basic usage:","use std::process::Command;\n\nlet mut command = Command::new(\"ls\");\nif let Ok(mut child) = command.spawn() {\n    child.wait().expect(\"command wasn't running\");\n    println!(\"Child has finished its execution!\");\n} else {\n    println!(\"ls command didn't start\");\n}"]}},{"name":"pub fn try_wait(&mut self) -> Result<Option<ExitStatus>>","details":{"description":["Attempts to collect the exit status of the child if it has already exited.","This function will not block the calling thread and will only advisorily check to see if the child process has exited or not. If the child has exited then on Unix the process id is reaped. This function is guaranteed to repeatedly return a successful exit status so long as the child has already exited.","If the child has exited, then Ok(Some(status)) is returned. If the exit status is not available at this time then Ok(None) is returned. If an error occurs, then that error is returned.","Note that unlike wait, this function will not attempt to drop stdin."],"example":["Basic usage:","use std::process::Command;\n\nlet mut child = Command::new(\"ls\").spawn().unwrap();\n\nmatch child.try_wait() {\n    Ok(Some(status)) => println!(\"exited with: {}\", status),\n    Ok(None) => {\n        println!(\"status not ready yet, let's really wait\");\n        let res = child.wait();\n        println!(\"result: {:?}\", res);\n    }\n    Err(e) => println!(\"error attempting to wait: {}\", e),\n}"]}},{"name":"pub fn wait_with_output(self) -> Result<Output>","details":{"description":["Simultaneously waits for the child to exit and collect all remaining output on the stdout/stderr handles, returning an Output instance.","The stdin handle to the child process, if any, will be closed before waiting. This helps avoid deadlock: it ensures that the child does not block waiting for input from the parent, while the parent waits for the child to exit.","By default, stdin, stdout and stderr are inherited from the parent. In order to capture the output into this Result<Output> it is necessary to create new pipes between parent and child. Use stdout(Stdio::piped()) or stderr(Stdio::piped()), respectively."],"example":["use std::process::{Command, Stdio};\n\nlet child = Command::new(\"/bin/cat\")\n    .arg(\"file.txt\")\n    .stdout(Stdio::piped())\n    .spawn()\n    .expect(\"failed to execute child\");\n\nlet output = child\n    .wait_with_output()\n    .expect(\"failed to wait on child\");\n\nassert!(output.status.success());"]}}]}