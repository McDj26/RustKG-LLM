{"stability":{"stable since":"1.0.0"},"apiName":"std::ops::Drop","apiType":"trait","apiDocumentation":{"apiDescription":["Used to run some code when a value goes out of scope. This is sometimes called a 'destructor'.","When a value goes out of scope, it will have its drop method called if its type implements Drop. Then, any fields the value contains will also be dropped recursively.","Because of this recursive dropping, you do not need to implement this trait unless your type needs its own destructor logic.","Refer to the chapter on Drop in The Rust Programming Language for some more elaboration."],"examples":["Implementing Drop","The drop method is called when _x goes out of scope, and therefore\nmain prints Dropping!.","struct HasDrop;\n\nimpl Drop for HasDrop {\n    fn drop(&mut self) {\n        println!(\"Dropping!\");\n    }\n}\n\nfn main() {\n    let _x = HasDrop;\n}","Dropping is done recursively","When outer goes out of scope, the drop method will be called first for\nOuter, then for Inner. Therefore, main prints Dropping Outer! and\nthen Dropping Inner!.","struct Inner;\nstruct Outer(Inner);\n\nimpl Drop for Inner {\n    fn drop(&mut self) {\n        println!(\"Dropping Inner!\");\n    }\n}\n\nimpl Drop for Outer {\n    fn drop(&mut self) {\n        println!(\"Dropping Outer!\");\n    }\n}\n\nfn main() {\n    let _x = Outer(Inner);\n}","Variables are dropped in reverse order of declaration","_first is declared first and _second is declared second, so main will\nprint Declared second! and then Declared first!.","struct PrintOnDrop(&'static str);\n\nimpl Drop for PrintOnDrop {\n    fn drop(&mut self) {\n        println!(\"{}\", self.0);\n    }\n}\n\nfn main() {\n    let _first = PrintOnDrop(\"Declared first!\");\n    let _second = PrintOnDrop(\"Declared second!\");\n}"]},"trait required methods":[{"name":"fn drop(&mut self)","details":{"description":"Executes the destructor for this type."}}]}