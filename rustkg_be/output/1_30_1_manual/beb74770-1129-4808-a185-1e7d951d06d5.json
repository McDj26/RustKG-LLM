{"stability":{"stable since":"1.0.0"},"apiName":"std::sync::atomic::fence","apiType":"function","apiDocumentation":{"apiDescription":["An atomic fence.","Depending on the specified order, a fence prevents the compiler and CPU from reordering certain types of memory operations around it. That creates synchronizes-with relationships between it and atomic operations or fences in other threads.","A fence 'A' which has (at least) Release ordering semantics, synchronizes with a fence 'B' with (at least) Acquire semantics, if and only if there exist operations X and Y, both operating on some atomic object 'M' such that A is sequenced before X, Y is synchronized before B and Y observes the change to M. This provides a happens-before dependence between A and B.","Thread 1 Thread 2 fence(Release); A -------------- x.store(3, Relaxed); X --------- | | | | | -------------> Y if x.load(Relaxed) == 3 { |-------> B fence(Acquire); ... }","Atomic operations with Release or Acquire semantics can also synchronize with a fence.","A fence which has SeqCst ordering, in addition to having both Acquire and Release semantics, participates in the global program order of the other SeqCst operations and/or fences.","Accepts Acquire, Release, AcqRel and SeqCst orderings.","Panics","Panics if order is Relaxed."],"examples":["use std::sync::atomic::AtomicBool;\nuse std::sync::atomic::fence;\nuse std::sync::atomic::Ordering;\n\n// A mutual exclusion primitive based on spinlock.\npub struct Mutex {\n    flag: AtomicBool,\n}\n\nimpl Mutex {\n    pub fn new() -> Mutex {\n        Mutex {\n            flag: AtomicBool::new(false),\n        }\n    }\n\n    pub fn lock(&self) {\n        while !self.flag.compare_and_swap(false, true, Ordering::Relaxed) {}\n        // This fence synchronizes-with store in `unlock`.\n        fence(Ordering::Acquire);\n    }\n\n    pub fn unlock(&self) {\n        self.flag.store(false, Ordering::Release);\n    }\n}"]}}