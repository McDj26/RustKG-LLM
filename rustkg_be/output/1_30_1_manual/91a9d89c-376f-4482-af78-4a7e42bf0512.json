{"stability":{"stable since":"1.0.0"},"apiName":"std::sync::mpsc::Receiver","apiType":"struct","apiDocumentation":{"apiDescription":["The receiving half of Rust's channel (or sync_channel) type. This half can only be owned by one thread.","Messages sent to the channel can be retrieved using recv."],"examples":["use std::sync::mpsc::channel;\nuse std::thread;\nuse std::time::Duration;\n\nlet (send, recv) = channel();\n\nthread::spawn(move || {\n    send.send(\"Hello world!\").unwrap();\n    thread::sleep(Duration::from_secs(2)); // block for two seconds\n    send.send(\"Delayed for 2 seconds\").unwrap();\n});\n\nprintln!(\"{}\", recv.recv().unwrap()); // Received immediately\nprintln!(\"Waiting...\");\nprintln!(\"{}\", recv.recv().unwrap()); // Received after 2 seconds"]},"trait implementations":[{"name":"impl<T: std::marker::Send> std::marker::Send for std::sync::mpsc::Receiver<T>","stable since":"1.0.0"},{"name":"impl<T> !std::marker::Sync for std::sync::mpsc::Receiver<T>","stable since":"1.0.0"},{"name":"impl<'a, T> std::iter::IntoIterator for &'a std::sync::mpsc::Receiver<T>","stable since":"1.1.0"},{"name":"impl<T> std::iter::IntoIterator for std::sync::mpsc::Receiver<T>","stable since":"1.1.0"},{"name":"impl<T> std::ops::Drop for std::sync::mpsc::Receiver<T>","stable since":"1.0.0"},{"name":"impl<T> std::fmt::Debug for std::sync::mpsc::Receiver<T>","stable since":"1.8.0"}],"methods":[{"name":"pub fn try_recv(&self) -> Result<T, TryRecvError>","details":{"description":["Attempts to return a pending value on this receiver without blocking.","This method will never block the caller in order to wait for data to become available. Instead, this will always return immediately with a possible option of pending data on the channel.","This is useful for a flavor of \"optimistic check\" before deciding to block on a receiver.","Compared with recv, this function has two failure cases instead of one (one for disconnection, one for an empty buffer)."],"example":["use std::sync::mpsc::{Receiver, channel};\n\nlet (_, receiver): (_, Receiver<i32>) = channel();\n\nassert!(receiver.try_recv().is_err());"]}},{"name":"pub fn recv(&self) -> Result<T, RecvError>","details":{"description":["Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up.","This function will always block the current thread if there is no data available and it's possible for more data to be sent. Once a message is sent to the corresponding Sender (or SyncSender), then this receiver will wake up and return that message.","If the corresponding Sender has disconnected, or it disconnects while this call is blocking, this call will wake up and return Err to indicate that no more messages can ever be received on this channel. However, since channels are buffered, messages sent before the disconnect will still be properly received."],"example":["use std::sync::mpsc;\nuse std::thread;\n\nlet (send, recv) = mpsc::channel();\nlet handle = thread::spawn(move || {\n    send.send(1u8).unwrap();\n});\n\nhandle.join().unwrap();\n\nassert_eq!(Ok(1), recv.recv());","Buffering behavior:","use std::sync::mpsc;\nuse std::thread;\nuse std::sync::mpsc::RecvError;\n\nlet (send, recv) = mpsc::channel();\nlet handle = thread::spawn(move || {\n    send.send(1u8).unwrap();\n    send.send(2).unwrap();\n    send.send(3).unwrap();\n    drop(send);\n});\n\n// wait for the thread to join so we ensure the sender is dropped\nhandle.join().unwrap();\n\nassert_eq!(Ok(1), recv.recv());\nassert_eq!(Ok(2), recv.recv());\nassert_eq!(Ok(3), recv.recv());\nassert_eq!(Err(RecvError), recv.recv());"]}},{"name":"pub fn recv_timeout(&self, timeout: Duration) -> Result<T, RecvTimeoutError>","details":{"description":["Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up, or if it waits more than timeout.","This function will always block the current thread if there is no data available and it's possible for more data to be sent. Once a message is sent to the corresponding Sender (or SyncSender), then this receiver will wake up and return that message.","If the corresponding Sender has disconnected, or it disconnects while this call is blocking, this call will wake up and return Err to indicate that no more messages can ever be received on this channel. However, since channels are buffered, messages sent before the disconnect will still be properly received.","Known Issues","There is currently a known issue (see #39364) that causes recv_timeout to panic unexpectedly with the following example:","use std::sync::mpsc::channel; use std::thread; use std::time::Duration; let (tx, rx) = channel::<String>(); thread::spawn(move || { let d = Duration::from_millis(10); loop { println!(\"recv\"); let _r = rx.recv_timeout(d); } }); thread::sleep(Duration::from_millis(100)); let _c1 = tx.clone(); thread::sleep(Duration::from_secs(1));"],"example":["Successfully receiving value before encountering timeout:","use std::thread;\nuse std::time::Duration;\nuse std::sync::mpsc;\n\nlet (send, recv) = mpsc::channel();\n\nthread::spawn(move || {\n    send.send('a').unwrap();\n});\n\nassert_eq!(\n    recv.recv_timeout(Duration::from_millis(400)),\n    Ok('a')\n);","Receiving an error upon reaching timeout:","use std::thread;\nuse std::time::Duration;\nuse std::sync::mpsc;\n\nlet (send, recv) = mpsc::channel();\n\nthread::spawn(move || {\n    thread::sleep(Duration::from_millis(800));\n    send.send('a').unwrap();\n});\n\nassert_eq!(\n    recv.recv_timeout(Duration::from_millis(400)),\n    Err(mpsc::RecvTimeoutError::Timeout)\n);"]}},{"name":"pub fn recv_deadline(&self, deadline: Instant) -> Result<T, RecvTimeoutError>","stability":["ðŸ”¬ This is a nightly-only experimental API.  (deadline_api #46316)"]},{"name":"pub fn iter(&self) -> Iter<T>","details":{"description":["Returns an iterator that will block waiting for messages, but never panic!. It will return None when the channel has hung up."],"example":["use std::sync::mpsc::channel;\nuse std::thread;\n\nlet (send, recv) = channel();\n\nthread::spawn(move || {\n    send.send(1).unwrap();\n    send.send(2).unwrap();\n    send.send(3).unwrap();\n});\n\nlet mut iter = recv.iter();\nassert_eq!(iter.next(), Some(1));\nassert_eq!(iter.next(), Some(2));\nassert_eq!(iter.next(), Some(3));\nassert_eq!(iter.next(), None);"]}},{"name":"pub fn try_iter(&self) -> TryIter<T>","details":{"description":["Returns an iterator that will attempt to yield all pending values. It will return None if there are no more pending values or if the channel has hung up. The iterator will never panic! or block the user by waiting for values."],"example":["use std::sync::mpsc::channel;\nuse std::thread;\nuse std::time::Duration;\n\nlet (sender, receiver) = channel();\n\n// nothing is in the buffer yet\nassert!(receiver.try_iter().next().is_none());\n\nthread::spawn(move || {\n    thread::sleep(Duration::from_secs(1));\n    sender.send(1).unwrap();\n    sender.send(2).unwrap();\n    sender.send(3).unwrap();\n});\n\n// nothing is in the buffer yet\nassert!(receiver.try_iter().next().is_none());\n\n// block for two seconds\nthread::sleep(Duration::from_secs(2));\n\nlet mut iter = receiver.try_iter();\nassert_eq!(iter.next(), Some(1));\nassert_eq!(iter.next(), Some(2));\nassert_eq!(iter.next(), Some(3));\nassert_eq!(iter.next(), None);"]}}]}