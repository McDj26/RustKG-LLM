{"stability":{"stable since":"1.0.0"},"apiName":"std::iter::Peekable","apiType":"struct","apiDocumentation":{"apiDescription":["An iterator with a peek() that returns an optional reference to the next element.","This struct is created by the peekable method on Iterator. See its documentation for more."]},"trait implementations":[{"name":"impl<I> std::iter::Iterator for std::iter::Peekable<I> where I: std::iter::Iterator","stable since":"1.0.0"},{"name":"impl<I> std::clone::Clone for std::iter::Peekable<I> where I: std::clone::Clone + std::iter::Iterator, <I as std::iter::Iterator>::std::iter::Iterator::Item: std::clone::Clone","stable since":"1.0.0"},{"name":"impl<I> std::fmt::Debug for std::iter::Peekable<I> where I: std::iter::Iterator + std::fmt::Debug, <I as std::iter::Iterator>::std::iter::Iterator::Item: std::fmt::Debug","stable since":"1.0.0"},{"name":"impl<I> std::iter::ExactSizeIterator for std::iter::Peekable<I> where I: std::iter::ExactSizeIterator","stable since":"1.0.0"},{"name":"impl<I> std::iter::FusedIterator for std::iter::Peekable<I> where I: std::iter::FusedIterator","stable since":"1.26.0"},{"name":"impl<I> std::marker::Send for std::iter::Peekable<I> where I: std::marker::Send, <I as std::iter::Iterator>::std::iter::Iterator::Item: std::marker::Send","stable since":"1.0.0"},{"name":"impl<I> std::marker::Sync for std::iter::Peekable<I> where I: std::marker::Sync, <I as std::iter::Iterator>::std::iter::Iterator::Item: std::marker::Sync","stable since":"1.0.0"}],"methods":[{"name":"pub fn peek(&mut self) -> Option<&<I as Iterator>::Item>","details":{"description":["Returns a reference to the next() value without advancing the iterator.","Like next, if there is a value, it is wrapped in a Some(T). But if the iteration is over, None is returned.","Because peek() returns a reference, and many iterators iterate over references, there can be a possibly confusing situation where the return value is a double reference. You can see this effect in the examples below."],"example":["Basic usage:","let xs = [1, 2, 3];\n\nlet mut iter = xs.iter().peekable();\n\n// peek() lets us see into the future\nassert_eq!(iter.peek(), Some(&&1));\nassert_eq!(iter.next(), Some(&1));\n\nassert_eq!(iter.next(), Some(&2));\n\n// The iterator does not advance even if we `peek` multiple times\nassert_eq!(iter.peek(), Some(&&3));\nassert_eq!(iter.peek(), Some(&&3));\n\nassert_eq!(iter.next(), Some(&3));\n\n// After the iterator is finished, so is `peek()`\nassert_eq!(iter.peek(), None);\nassert_eq!(iter.next(), None);"]}}]}