{"stability":{"stable since":"1.0.0"},"apiName":"std::unimplemented","apiType":"macro","apiDocumentation":{"apiDescription":["A standardized placeholder for marking unfinished code.","This can be useful if you are prototyping and are just looking to have your code typecheck, or if you're implementing a trait that requires multiple methods, and you're only planning on using one of them.","Panics","This will always panic!"],"examples":["Here's an example of some in-progress code. We have a trait Foo:","trait Foo {\n    fn bar(&self);\n    fn baz(&self);\n}","We want to implement Foo on one of our types, but we also want to work on\njust bar() first. In order for our code to compile, we need to implement\nbaz(), so we can use unimplemented!:","struct MyStruct;\n\nimpl Foo for MyStruct {\n    fn bar(&self) {\n        // implementation goes here\n    }\n\n    fn baz(&self) {\n        // let's not worry about implementing baz() for now\n        unimplemented!();\n    }\n}\n\nfn main() {\n    let s = MyStruct;\n    s.bar();\n\n    // we aren't even using baz() yet, so this is fine.\n}"]}}