{"stability":{"stable since":"1.0.0"},"apiName":"std::process::Command","apiType":"struct","apiDocumentation":{"apiDescription":["A process builder, providing fine-grained control over how a new process should be spawned.","A default configuration can be generated using Command::new(program), where program gives a path to the program to be executed. Additional builder methods allow the configuration to be changed (for example, by adding arguments) prior to spawning:","use std::process::Command; let output = if cfg!(target_os = \"windows\") { Command::new(\"cmd\") .args(&[\"/C\", \"echo hello\"]) .output() .expect(\"failed to execute process\") } else { Command::new(\"sh\") .arg(\"-c\") .arg(\"echo hello\") .output() .expect(\"failed to execute process\") }; let hello = output.stdout;","Command can be reused to spawn multiple processes. The builder methods change the command without needing to immediately spawn the process.","use std::process::Command; let mut echo_hello = Command::new(\"sh\"); echo_hello.arg(\"-c\") .arg(\"echo hello\"); let hello_1 = echo_hello.output().expect(\"failed to execute process\"); let hello_2 = echo_hello.output().expect(\"failed to execute process\");","Similarly, you can call builder methods after spawning a process and then spawn a new process with the modified settings.","use std::process::Command; let mut list_dir = Command::new(\"ls\"); // Execute `ls` in the current directory of the program. list_dir.status().expect(\"process failed to execute\"); println!(\"\"); // Change `ls` to execute in the root directory. list_dir.current_dir(\"/\"); // And then execute `ls` again but in the root directory. list_dir.status().expect(\"process failed to execute\");"]},"trait implementations":[{"name":"impl std::fmt::Debug for std::process::Command","stable since":"1.0.0"},{"name":"impl std::os::windows::process::CommandExt for std::process::Command","stable since":"1.16.0"},{"name":"impl std::os::unix::process::CommandExt for std::process::Command","stable since":"1.0.0"},{"name":"impl std::marker::Send for std::process::Command","stable since":"1.0.0"},{"name":"impl std::marker::Sync for std::process::Command","stable since":"1.0.0"}],"methods":[{"name":"pub fn new<S: AsRef<OsStr>>(program: S) -> Command","details":{"description":["Constructs a new Command for launching the program at path program, with the following default configuration:","No arguments to the program Inherit the current process's environment Inherit the current process's working directory Inherit stdin/stdout/stderr for spawn or status, but create pipes for output","Builder methods are provided to change these defaults and otherwise configure the process.","If program is not an absolute path, the PATH will be searched in an OS-defined way.","The search path to be used may be controlled by setting the PATH environment variable on the Command, but this has some implementation limitations on Windows (see https://github.com/rust-lang/rust/issues/37519)."],"example":["Basic usage:","use std::process::Command;\n\nCommand::new(\"sh\")\n        .spawn()\n        .expect(\"sh command failed to start\");"]}},{"name":"pub fn arg<S: AsRef<OsStr>>(&mut self, arg: S) -> &mut Command","details":{"description":["Add an argument to pass to the program.","Only one argument can be passed per use. So instead of:",".arg(\"-C /path/to/repo\")","usage would be:",".arg(\"-C\") .arg(\"/path/to/repo\")","To pass multiple arguments see args."],"example":["Basic usage:","use std::process::Command;\n\nCommand::new(\"ls\")\n        .arg(\"-l\")\n        .arg(\"-a\")\n        .spawn()\n        .expect(\"ls command failed to start\");"]}},{"name":"pub fn args<I, S>(&mut self, args: I) -> &mut Command where I: IntoIterator<Item = S>, S: AsRef<OsStr>","details":{"description":["Add multiple arguments to pass to the program.","To pass a single argument see arg."],"example":["Basic usage:","use std::process::Command;\n\nCommand::new(\"ls\")\n        .args(&[\"-l\", \"-a\"])\n        .spawn()\n        .expect(\"ls command failed to start\");"]}},{"name":"pub fn env<K, V>(&mut self, key: K, val: V) -> &mut Command where K: AsRef<OsStr>, V: AsRef<OsStr>","details":{"description":["Inserts or updates an environment variable mapping.","Note that environment variable names are case-insensitive (but case-preserving) on Windows, and case-sensitive on all other platforms."],"example":["Basic usage:","use std::process::Command;\n\nCommand::new(\"ls\")\n        .env(\"PATH\", \"/bin\")\n        .spawn()\n        .expect(\"ls command failed to start\");"]}},{"name":"pub fn envs<I, K, V>(&mut self, vars: I) -> &mut Command where I: IntoIterator<Item = (K, V)>, K: AsRef<OsStr>, V: AsRef<OsStr>","details":{"description":["Add or update multiple environment variable mappings."],"example":["Basic usage:","use std::process::{Command, Stdio};\nuse std::env;\nuse std::collections::HashMap;\n\nlet filtered_env : HashMap<String, String> =\n    env::vars().filter(|&(ref k, _)|\n        k == \"TERM\" || k == \"TZ\" || k == \"LANG\" || k == \"PATH\"\n    ).collect();\n\nCommand::new(\"printenv\")\n        .stdin(Stdio::null())\n        .stdout(Stdio::inherit())\n        .env_clear()\n        .envs(&filtered_env)\n        .spawn()\n        .expect(\"printenv failed to start\");"]}},{"name":"pub fn env_remove<K: AsRef<OsStr>>(&mut self, key: K) -> &mut Command","details":{"description":["Removes an environment variable mapping."],"example":["Basic usage:","use std::process::Command;\n\nCommand::new(\"ls\")\n        .env_remove(\"PATH\")\n        .spawn()\n        .expect(\"ls command failed to start\");"]}},{"name":"pub fn env_clear(&mut self) -> &mut Command","details":{"description":["Clears the entire environment map for the child process."],"example":["Basic usage:","use std::process::Command;\n\nCommand::new(\"ls\")\n        .env_clear()\n        .spawn()\n        .expect(\"ls command failed to start\");"]}},{"name":"pub fn current_dir<P: AsRef<Path>>(&mut self, dir: P) -> &mut Command","details":{"description":["Sets the working directory for the child process.","Platform-specific behavior","If the program path is relative (e.g. \"./script.sh\"), it's ambiguous whether it should be interpreted relative to the parent's working directory or relative to current_dir. The behavior in this case is platform specific and unstable, and it's recommended to use canonicalize to get an absolute program path instead."],"example":["Basic usage:","use std::process::Command;\n\nCommand::new(\"ls\")\n        .current_dir(\"/bin\")\n        .spawn()\n        .expect(\"ls command failed to start\");"]}},{"name":"pub fn stdin<T: Into<Stdio>>(&mut self, cfg: T) -> &mut Command","details":{"description":["Configuration for the child process's standard input (stdin) handle.","Defaults to inherit when used with spawn or status, and defaults to piped when used with output."],"example":["Basic usage:","use std::process::{Command, Stdio};\n\nCommand::new(\"ls\")\n        .stdin(Stdio::null())\n        .spawn()\n        .expect(\"ls command failed to start\");"]}},{"name":"pub fn stdout<T: Into<Stdio>>(&mut self, cfg: T) -> &mut Command","details":{"description":["Configuration for the child process's standard output (stdout) handle.","Defaults to inherit when used with spawn or status, and defaults to piped when used with output."],"example":["Basic usage:","use std::process::{Command, Stdio};\n\nCommand::new(\"ls\")\n        .stdout(Stdio::null())\n        .spawn()\n        .expect(\"ls command failed to start\");"]}},{"name":"pub fn stderr<T: Into<Stdio>>(&mut self, cfg: T) -> &mut Command","details":{"description":["Configuration for the child process's standard error (stderr) handle.","Defaults to inherit when used with spawn or status, and defaults to piped when used with output."],"example":["Basic usage:","use std::process::{Command, Stdio};\n\nCommand::new(\"ls\")\n        .stderr(Stdio::null())\n        .spawn()\n        .expect(\"ls command failed to start\");"]}},{"name":"pub fn spawn(&mut self) -> Result<Child>","details":{"description":["Executes the command as a child process, returning a handle to it.","By default, stdin, stdout and stderr are inherited from the parent."],"example":["Basic usage:","use std::process::Command;\n\nCommand::new(\"ls\")\n        .spawn()\n        .expect(\"ls command failed to start\");"]}},{"name":"pub fn output(&mut self) -> Result<Output>","details":{"description":["Executes the command as a child process, waiting for it to finish and collecting all of its output.","By default, stdout and stderr are captured (and used to provide the resulting output). Stdin is not inherited from the parent and any attempt by the child process to read from the stdin stream will result in the stream immediately closing."],"example":["use std::process::Command;\nlet output = Command::new(\"/bin/cat\")\n                     .arg(\"file.txt\")\n                     .output()\n                     .expect(\"failed to execute process\");\n\nprintln!(\"status: {}\", output.status);\nprintln!(\"stdout: {}\", String::from_utf8_lossy(&output.stdout));\nprintln!(\"stderr: {}\", String::from_utf8_lossy(&output.stderr));\n\nassert!(output.status.success());"]}},{"name":"pub fn status(&mut self) -> Result<ExitStatus>","details":{"description":["Executes a command as a child process, waiting for it to finish and collecting its exit status.","By default, stdin, stdout and stderr are inherited from the parent."],"example":["use std::process::Command;\n\nlet status = Command::new(\"/bin/cat\")\n                     .arg(\"file.txt\")\n                     .status()\n                     .expect(\"failed to execute process\");\n\nprintln!(\"process exited with: {}\", status);\n\nassert!(status.success());"]}}]}