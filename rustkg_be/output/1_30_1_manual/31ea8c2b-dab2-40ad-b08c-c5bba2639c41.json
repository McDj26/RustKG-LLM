{"stability":{"stable since":"1.0.0"},"apiName":"u16","apiType":"primitive","apiDocumentation":{"apiDescription":["The 16-bit unsigned integer type.","See also the std::u16 module."]},"trait implementations":[{"name":"impl std::convert::TryFrom<u128> for u16","stable since":"1.0.0"},{"name":"impl std::convert::TryFrom<isize> for u16","stable since":"1.0.0"},{"name":"impl std::convert::TryFrom<i8> for u16","stable since":"1.0.0"},{"name":"impl std::convert::TryFrom<i16> for u16","stable since":"1.0.0"},{"name":"impl std::convert::TryFrom<u64> for u16","stable since":"1.0.0"},{"name":"impl std::convert::TryFrom<i128> for u16","stable since":"1.0.0"},{"name":"impl std::convert::TryFrom<i64> for u16","stable since":"1.0.0"},{"name":"impl std::convert::TryFrom<i32> for u16","stable since":"1.0.0"},{"name":"impl std::convert::TryFrom<usize> for u16","stable since":"1.0.0"},{"name":"impl std::convert::TryFrom<u32> for u16","stable since":"1.0.0"},{"name":"impl std::ops::RemAssign<u16> for u16","stable since":"1.8.0"},{"name":"impl<'a> std::ops::RemAssign<&'a u16> for u16","stable since":"1.22.0"},{"name":"impl std::str::FromStr for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::DivAssign<&'a u16> for u16","stable since":"1.22.0"},{"name":"impl std::ops::DivAssign<u16> for u16","stable since":"1.8.0"},{"name":"impl std::ops::MulAssign<u16> for u16","stable since":"1.8.0"},{"name":"impl<'a> std::ops::MulAssign<&'a u16> for u16","stable since":"1.22.0"},{"name":"impl<'a> std::ops::SubAssign<&'a u16> for u16","stable since":"1.22.0"},{"name":"impl std::ops::SubAssign<u16> for u16","stable since":"1.8.0"},{"name":"impl std::hash::Hash for u16","stable since":"1.0.0"},{"name":"impl std::ops::AddAssign<u16> for u16","stable since":"1.8.0"},{"name":"impl<'a> std::ops::AddAssign<&'a u16> for u16","stable since":"1.22.0"},{"name":"impl<'a> std::ops::ShrAssign<&'a u64> for u16","stable since":"1.22.0"},{"name":"impl std::ops::ShrAssign<i64> for u16","stable since":"1.8.0"},{"name":"impl std::ops::ShrAssign<u128> for u16","stable since":"1.8.0"},{"name":"impl std::ops::ShrAssign<i32> for u16","stable since":"1.8.0"},{"name":"impl std::ops::ShrAssign<isize> for u16","stable since":"1.8.0"},{"name":"impl<'a> std::ops::ShrAssign<&'a u8> for u16","stable since":"1.22.0"},{"name":"impl<'a> std::ops::ShrAssign<&'a isize> for u16","stable since":"1.22.0"},{"name":"impl std::ops::ShrAssign<i128> for u16","stable since":"1.8.0"},{"name":"impl<'a> std::ops::ShrAssign<&'a i128> for u16","stable since":"1.22.0"},{"name":"impl<'a> std::ops::ShrAssign<&'a i32> for u16","stable since":"1.22.0"},{"name":"impl std::ops::ShrAssign<u16> for u16","stable since":"1.8.0"},{"name":"impl std::ops::ShrAssign<i8> for u16","stable since":"1.8.0"},{"name":"impl<'a> std::ops::ShrAssign<&'a u32> for u16","stable since":"1.22.0"},{"name":"impl<'a> std::ops::ShrAssign<&'a usize> for u16","stable since":"1.22.0"},{"name":"impl<'a> std::ops::ShrAssign<&'a u128> for u16","stable since":"1.22.0"},{"name":"impl<'a> std::ops::ShrAssign<&'a i64> for u16","stable since":"1.22.0"},{"name":"impl std::ops::ShrAssign<u32> for u16","stable since":"1.8.0"},{"name":"impl<'a> std::ops::ShrAssign<&'a u16> for u16","stable since":"1.22.0"},{"name":"impl<'a> std::ops::ShrAssign<&'a i16> for u16","stable since":"1.22.0"},{"name":"impl std::ops::ShrAssign<u64> for u16","stable since":"1.8.0"},{"name":"impl<'a> std::ops::ShrAssign<&'a i8> for u16","stable since":"1.22.0"},{"name":"impl std::ops::ShrAssign<usize> for u16","stable since":"1.8.0"},{"name":"impl std::ops::ShrAssign<u8> for u16","stable since":"1.8.0"},{"name":"impl std::ops::ShrAssign<i16> for u16","stable since":"1.8.0"},{"name":"impl std::clone::Clone for u16","stable since":"1.0.0"},{"name":"impl std::cmp::PartialOrd<u16> for u16","stable since":"1.0.0"},{"name":"impl std::cmp::Ord for u16","stable since":"1.0.0"},{"name":"impl std::ops::Sub<u16> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Sub<u16> for &'a u16","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Sub<&'a u16> for &'b u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Sub<&'a u16> for u16","stable since":"1.0.0"},{"name":"impl std::ops::Shr<u64> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<u128> for &'a u16","stable since":"1.0.0"},{"name":"impl std::ops::Shr<isize> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<&'a isize> for u16","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shr<&'a u64> for &'b u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<i32> for &'a u16","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shr<&'a u128> for &'b u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<&'a u8> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<usize> for &'a u16","stable since":"1.0.0"},{"name":"impl std::ops::Shr<i64> for u16","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shr<&'a i64> for &'b u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<i16> for &'a u16","stable since":"1.0.0"},{"name":"impl std::ops::Shr<u32> for u16","stable since":"1.0.0"},{"name":"impl std::ops::Shr<usize> for u16","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shr<&'a i16> for &'b u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<u32> for &'a u16","stable since":"1.0.0"},{"name":"impl std::ops::Shr<i32> for u16","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shr<&'a isize> for &'b u16","stable since":"1.0.0"},{"name":"impl std::ops::Shr<i8> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<u16> for &'a u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<&'a i32> for u16","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shr<&'a i32> for &'b u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<&'a u128> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<u64> for &'a u16","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shr<&'a i8> for &'b u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<&'a u16> for u16","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shr<&'a usize> for &'b u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<&'a i8> for u16","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shr<&'a u16> for &'b u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<&'a u64> for u16","stable since":"1.0.0"},{"name":"impl std::ops::Shr<u8> for u16","stable since":"1.0.0"},{"name":"impl std::ops::Shr<u128> for u16","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shr<&'a u8> for &'b u16","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shr<&'a i128> for &'b u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<&'a u32> for u16","stable since":"1.0.0"},{"name":"impl std::ops::Shr<i16> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<&'a usize> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<&'a i128> for u16","stable since":"1.0.0"},{"name":"impl std::ops::Shr<u16> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<i8> for &'a u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<isize> for &'a u16","stable since":"1.0.0"},{"name":"impl std::ops::Shr<i128> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<&'a i16> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<u8> for &'a u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<&'a i64> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<i64> for &'a u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shr<i128> for &'a u16","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shr<&'a u32> for &'b u16","stable since":"1.0.0"},{"name":"impl std::fmt::Binary for u16","stable since":"1.0.0"},{"name":"impl<'a> std::iter::Sum<&'a u16> for u16","stable since":"1.12.0"},{"name":"impl std::iter::Sum<u16> for u16","stable since":"1.12.0"},{"name":"impl std::iter::Step for u16","stable since":"1.0.0"},{"name":"impl std::ops::BitXor<u16> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::BitXor<&'a u16> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::BitXor<u16> for &'a u16","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::BitXor<&'a u16> for &'b u16","stable since":"1.0.0"},{"name":"impl std::fmt::Debug for u16","stable since":"1.0.0"},{"name":"impl std::cmp::Eq for u16","stable since":"1.0.0"},{"name":"impl std::cmp::PartialEq<u16> for u16","stable since":"1.0.0"},{"name":"impl std::convert::From<bool> for u16","stable since":"1.28.0"},{"name":"impl std::convert::From<u8> for u16","stable since":"1.5.0"},{"name":"impl std::ops::Not for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Not for &'a u16","stable since":"1.0.0"},{"name":"impl std::marker::Copy for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Rem<&'a u16> for u16","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Rem<&'a u16> for &'b u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Rem<u16> for &'a u16","stable since":"1.0.0"},{"name":"impl std::ops::Rem<u16> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Mul<u16> for &'a u16","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Mul<&'a u16> for &'b u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Mul<&'a u16> for u16","stable since":"1.0.0"},{"name":"impl std::ops::Mul<u16> for u16","stable since":"1.0.0"},{"name":"impl std::fmt::UpperHex for u16","stable since":"1.0.0"},{"name":"impl std::ops::Shl<i128> for u16","stable since":"1.0.0"},{"name":"impl std::ops::Shl<isize> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<&'a u8> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<&'a i128> for u16","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shl<&'a i64> for &'b u16","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shl<&'a u64> for &'b u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<u32> for &'a u16","stable since":"1.0.0"},{"name":"impl std::ops::Shl<usize> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<u128> for &'a u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<i128> for &'a u16","stable since":"1.0.0"},{"name":"impl std::ops::Shl<u32> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<u64> for &'a u16","stable since":"1.0.0"},{"name":"impl std::ops::Shl<u8> for u16","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shl<&'a u128> for &'b u16","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shl<&'a usize> for &'b u16","stable since":"1.0.0"},{"name":"impl std::ops::Shl<u128> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<&'a u16> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<&'a u32> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<&'a u128> for u16","stable since":"1.0.0"},{"name":"impl std::ops::Shl<i8> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<&'a usize> for u16","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shl<&'a i8> for &'b u16","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shl<&'a u8> for &'b u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<&'a i32> for u16","stable since":"1.0.0"},{"name":"impl std::ops::Shl<u16> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<&'a isize> for u16","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shl<&'a u16> for &'b u16","stable since":"1.0.0"},{"name":"impl std::ops::Shl<i64> for u16","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shl<&'a i16> for &'b u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<&'a i64> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<&'a u64> for u16","stable since":"1.0.0"},{"name":"impl std::ops::Shl<i16> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<i16> for &'a u16","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shl<&'a i128> for &'b u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<i32> for &'a u16","stable since":"1.0.0"},{"name":"impl std::ops::Shl<u64> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<u8> for &'a u16","stable since":"1.0.0"},{"name":"impl std::ops::Shl<i32> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<u16> for &'a u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<i64> for &'a u16","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shl<&'a u32> for &'b u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<&'a i16> for u16","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shl<&'a isize> for &'b u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<usize> for &'a u16","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::Shl<&'a i32> for &'b u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<&'a i8> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<i8> for &'a u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Shl<isize> for &'a u16","stable since":"1.0.0"},{"name":"impl std::fmt::Octal for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::BitAnd<&'a u16> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::BitAnd<u16> for &'a u16","stable since":"1.0.0"},{"name":"impl std::ops::BitAnd<u16> for u16","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::BitAnd<&'a u16> for &'b u16","stable since":"1.0.0"},{"name":"impl std::default::Default for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::ShlAssign<&'a u64> for u16","stable since":"1.22.0"},{"name":"impl std::ops::ShlAssign<i8> for u16","stable since":"1.8.0"},{"name":"impl std::ops::ShlAssign<u32> for u16","stable since":"1.8.0"},{"name":"impl std::ops::ShlAssign<i16> for u16","stable since":"1.8.0"},{"name":"impl std::ops::ShlAssign<u128> for u16","stable since":"1.8.0"},{"name":"impl std::ops::ShlAssign<u16> for u16","stable since":"1.8.0"},{"name":"impl std::ops::ShlAssign<u8> for u16","stable since":"1.8.0"},{"name":"impl<'a> std::ops::ShlAssign<&'a usize> for u16","stable since":"1.22.0"},{"name":"impl<'a> std::ops::ShlAssign<&'a i64> for u16","stable since":"1.22.0"},{"name":"impl std::ops::ShlAssign<i64> for u16","stable since":"1.8.0"},{"name":"impl<'a> std::ops::ShlAssign<&'a u8> for u16","stable since":"1.22.0"},{"name":"impl std::ops::ShlAssign<u64> for u16","stable since":"1.8.0"},{"name":"impl<'a> std::ops::ShlAssign<&'a u16> for u16","stable since":"1.22.0"},{"name":"impl std::ops::ShlAssign<i128> for u16","stable since":"1.8.0"},{"name":"impl<'a> std::ops::ShlAssign<&'a i8> for u16","stable since":"1.22.0"},{"name":"impl<'a> std::ops::ShlAssign<&'a u128> for u16","stable since":"1.22.0"},{"name":"impl<'a> std::ops::ShlAssign<&'a i128> for u16","stable since":"1.22.0"},{"name":"impl std::ops::ShlAssign<i32> for u16","stable since":"1.8.0"},{"name":"impl<'a> std::ops::ShlAssign<&'a isize> for u16","stable since":"1.22.0"},{"name":"impl<'a> std::ops::ShlAssign<&'a u32> for u16","stable since":"1.22.0"},{"name":"impl std::ops::ShlAssign<usize> for u16","stable since":"1.8.0"},{"name":"impl<'a> std::ops::ShlAssign<&'a i16> for u16","stable since":"1.22.0"},{"name":"impl<'a> std::ops::ShlAssign<&'a i32> for u16","stable since":"1.22.0"},{"name":"impl std::ops::ShlAssign<isize> for u16","stable since":"1.8.0"},{"name":"impl std::ops::BitXorAssign<u16> for u16","stable since":"1.8.0"},{"name":"impl<'a> std::ops::BitXorAssign<&'a u16> for u16","stable since":"1.22.0"},{"name":"impl<'a, 'b> std::ops::Div<&'a u16> for &'b u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Div<&'a u16> for u16","stable since":"1.0.0"},{"name":"impl std::ops::Div<u16> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Div<u16> for &'a u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::BitOrAssign<&'a u16> for u16","stable since":"1.22.0"},{"name":"impl std::ops::BitOrAssign<u16> for u16","stable since":"1.8.0"},{"name":"impl<'a> std::ops::BitAndAssign<&'a u16> for u16","stable since":"1.22.0"},{"name":"impl std::ops::BitAndAssign<u16> for u16","stable since":"1.8.0"},{"name":"impl<'a, 'b> std::ops::Add<&'a u16> for &'b u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Add<u16> for &'a u16","stable since":"1.0.0"},{"name":"impl std::ops::Add<u16> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::Add<&'a u16> for u16","stable since":"1.0.0"},{"name":"impl std::fmt::LowerHex for u16","stable since":"1.0.0"},{"name":"impl<'a> std::iter::Product<&'a u16> for u16","stable since":"1.12.0"},{"name":"impl std::iter::Product<u16> for u16","stable since":"1.12.0"},{"name":"impl std::fmt::Display for u16","stable since":"1.0.0"},{"name":"impl std::ops::BitOr<u16> for u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::BitOr<u16> for &'a u16","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::ops::BitOr<&'a u16> for &'b u16","stable since":"1.0.0"},{"name":"impl<'a> std::ops::BitOr<&'a u16> for u16","stable since":"1.0.0"},{"name":"impl std::marker::Send for u16","stable since":"1.0.0"},{"name":"impl std::marker::Sync for u16","stable since":"1.0.0"}],"methods":[{"name":"pub const fn min_value() -> u16","details":{"description":["Returns the smallest value that can be represented by this integer type."],"example":["Basic usage:","assert_eq!(u16::min_value(), 0);"]}},{"name":"pub const fn max_value() -> u16","details":{"description":["Returns the largest value that can be represented by this integer type."],"example":["Basic usage:","assert_eq!(u16::max_value(), 65535);"]}},{"name":"pub fn from_str_radix(src: &str, radix: u32) -> Result<u16, ParseIntError>","details":{"description":["Converts a string slice in a given base to an integer.","The string is expected to be an optional + sign followed by digits. Leading and trailing whitespace represent an error. Digits are a subset of these characters, depending on radix:","0-9 a-z A-Z","Panics","This function panics if radix is not in the range from 2 to 36."],"example":["Basic usage:","assert_eq!(u16::from_str_radix(\"A\", 16), Ok(10));"]}},{"name":"pub const fn count_ones(self) -> u32","details":{"description":["Returns the number of ones in the binary representation of self."],"example":["Basic usage:","let n = 0b01001100u16;\n\nassert_eq!(n.count_ones(), 3);"]}},{"name":"pub const fn count_zeros(self) -> u32","details":{"description":["Returns the number of zeros in the binary representation of self."],"example":["Basic usage:","assert_eq!(u16::max_value().count_zeros(), 0);"]}},{"name":"pub const fn leading_zeros(self) -> u32","details":{"description":["Returns the number of leading zeros in the binary representation of self."],"example":["Basic usage:","let n = u16::max_value() >> 2;\n\nassert_eq!(n.leading_zeros(), 2);"]}},{"name":"pub const fn trailing_zeros(self) -> u32","details":{"description":["Returns the number of trailing zeros in the binary representation of self."],"example":["Basic usage:","let n = 0b0101000u16;\n\nassert_eq!(n.trailing_zeros(), 3);"]}},{"name":"pub const fn rotate_left(self, n: u32) -> u16","details":{"description":["Shifts the bits to the left by a specified amount, n, wrapping the truncated bits to the end of the resulting integer.","Please note this isn't the same operation as <<!"],"example":["Basic usage:","let n = 0xa003u16;\nlet m = 0x3a;\n\nassert_eq!(n.rotate_left(4), m);"]}},{"name":"pub const fn rotate_right(self, n: u32) -> u16","details":{"description":["Shifts the bits to the right by a specified amount, n, wrapping the truncated bits to the beginning of the resulting integer.","Please note this isn't the same operation as >>!"],"example":["Basic usage:","let n = 0x3au16;\nlet m = 0xa003;\n\nassert_eq!(n.rotate_right(4), m);"]}},{"name":"pub const fn swap_bytes(self) -> u16","details":{"description":["Reverses the byte order of the integer."],"example":["Basic usage:","let n = 0x1234u16;\nlet m = n.swap_bytes();\n\nassert_eq!(m, 0x3412);"]}},{"name":"pub const fn reverse_bits(self) -> u16","stability":["🔬 This is a nightly-only experimental API.  (reverse_bits #48763)"]},{"name":"pub const fn from_be(x: u16) -> u16","details":{"description":["Converts an integer from big endian to the target's endianness.","On big endian this is a no-op. On little endian the bytes are swapped."],"example":["Basic usage:","let n = 0x1Au16;\n\nif cfg!(target_endian = \"big\") {\n    assert_eq!(u16::from_be(n), n)\n} else {\n    assert_eq!(u16::from_be(n), n.swap_bytes())\n}"]}},{"name":"pub const fn from_le(x: u16) -> u16","details":{"description":["Converts an integer from little endian to the target's endianness.","On little endian this is a no-op. On big endian the bytes are swapped."],"example":["Basic usage:","let n = 0x1Au16;\n\nif cfg!(target_endian = \"little\") {\n    assert_eq!(u16::from_le(n), n)\n} else {\n    assert_eq!(u16::from_le(n), n.swap_bytes())\n}"]}},{"name":"pub const fn to_be(self) -> u16","details":{"description":["Converts self to big endian from the target's endianness.","On big endian this is a no-op. On little endian the bytes are swapped."],"example":["Basic usage:","let n = 0x1Au16;\n\nif cfg!(target_endian = \"big\") {\n    assert_eq!(n.to_be(), n)\n} else {\n    assert_eq!(n.to_be(), n.swap_bytes())\n}"]}},{"name":"pub const fn to_le(self) -> u16","details":{"description":["Converts self to little endian from the target's endianness.","On little endian this is a no-op. On big endian the bytes are swapped."],"example":["Basic usage:","let n = 0x1Au16;\n\nif cfg!(target_endian = \"little\") {\n    assert_eq!(n.to_le(), n)\n} else {\n    assert_eq!(n.to_le(), n.swap_bytes())\n}"]}},{"name":"pub fn checked_add(self, rhs: u16) -> Option<u16>","details":{"description":["Checked integer addition. Computes self + rhs, returning None if overflow occurred."],"example":["Basic usage:","assert_eq!((u16::max_value() - 2).checked_add(1), Some(u16::max_value() - 1));\nassert_eq!((u16::max_value() - 2).checked_add(3), None);"]}},{"name":"pub fn checked_sub(self, rhs: u16) -> Option<u16>","details":{"description":["Checked integer subtraction. Computes self - rhs, returning None if overflow occurred."],"example":["Basic usage:","assert_eq!(1u16.checked_sub(1), Some(0));\nassert_eq!(0u16.checked_sub(1), None);"]}},{"name":"pub fn checked_mul(self, rhs: u16) -> Option<u16>","details":{"description":["Checked integer multiplication. Computes self * rhs, returning None if overflow occurred."],"example":["Basic usage:","assert_eq!(5u16.checked_mul(1), Some(5));\nassert_eq!(u16::max_value().checked_mul(2), None);"]}},{"name":"pub fn checked_div(self, rhs: u16) -> Option<u16>","details":{"description":["Checked integer division. Computes self / rhs, returning None if rhs == 0."],"example":["Basic usage:","assert_eq!(128u16.checked_div(2), Some(64));\nassert_eq!(1u16.checked_div(0), None);"]}},{"name":"pub fn checked_div_euc(self, rhs: u16) -> Option<u16>","stability":["🔬 This is a nightly-only experimental API.  (euclidean_division #49048)"]},{"name":"pub fn checked_rem(self, rhs: u16) -> Option<u16>","details":{"description":["Checked integer remainder. Computes self % rhs, returning None if rhs == 0."],"example":["Basic usage:","assert_eq!(5u16.checked_rem(2), Some(1));\nassert_eq!(5u16.checked_rem(0), None);"]}},{"name":"pub fn checked_mod_euc(self, rhs: u16) -> Option<u16>","stability":["🔬 This is a nightly-only experimental API.  (euclidean_division #49048)"]},{"name":"pub fn checked_neg(self) -> Option<u16>","details":{"description":["Checked negation. Computes -self, returning None unless self == 0.","Note that negating any positive integer will overflow."],"example":["Basic usage:","assert_eq!(0u16.checked_neg(), Some(0));\nassert_eq!(1u16.checked_neg(), None);"]}},{"name":"pub fn checked_shl(self, rhs: u32) -> Option<u16>","details":{"description":["Checked shift left. Computes self << rhs, returning None if rhs is larger than or equal to the number of bits in self."],"example":["Basic usage:","assert_eq!(0x1u16.checked_shl(4), Some(0x10));\nassert_eq!(0x10u16.checked_shl(129), None);"]}},{"name":"pub fn checked_shr(self, rhs: u32) -> Option<u16>","details":{"description":["Checked shift right. Computes self >> rhs, returning None if rhs is larger than or equal to the number of bits in self."],"example":["Basic usage:","assert_eq!(0x10u16.checked_shr(4), Some(0x1));\nassert_eq!(0x10u16.checked_shr(129), None);"]}},{"name":"pub fn checked_pow(self, exp: u32) -> Option<u16>","stability":["🔬 This is a nightly-only experimental API.  (no_panic_pow #48320)"]},{"name":"pub fn saturating_add(self, rhs: u16) -> u16","details":{"description":["Saturating integer addition. Computes self + rhs, saturating at the numeric bounds instead of overflowing."],"example":["Basic usage:","assert_eq!(100u16.saturating_add(1), 101);\nassert_eq!(200u8.saturating_add(127), 255);"]}},{"name":"pub fn saturating_sub(self, rhs: u16) -> u16","details":{"description":["Saturating integer subtraction. Computes self - rhs, saturating at the numeric bounds instead of overflowing."],"example":["Basic usage:","assert_eq!(100u16.saturating_sub(27), 73);\nassert_eq!(13u16.saturating_sub(127), 0);"]}},{"name":"pub fn saturating_mul(self, rhs: u16) -> u16","details":{"description":["Saturating integer multiplication. Computes self * rhs, saturating at the numeric bounds instead of overflowing."],"example":["Basic usage:","use std::u16;\n\nassert_eq!(2u16.saturating_mul(10), 20);\nassert_eq!((u16::MAX).saturating_mul(10), u16::MAX);"]}},{"name":"pub fn saturating_pow(self, exp: u32) -> u16","stability":["🔬 This is a nightly-only experimental API.  (no_panic_pow #48320)"]},{"name":"pub const fn wrapping_add(self, rhs: u16) -> u16","details":{"description":["Wrapping (modular) addition. Computes self + rhs, wrapping around at the boundary of the type."],"example":["Basic usage:","assert_eq!(200u16.wrapping_add(55), 255);\nassert_eq!(200u16.wrapping_add(u16::max_value()), 199);"]}},{"name":"pub const fn wrapping_sub(self, rhs: u16) -> u16","details":{"description":["Wrapping (modular) subtraction. Computes self - rhs, wrapping around at the boundary of the type."],"example":["Basic usage:","assert_eq!(100u16.wrapping_sub(100), 0);\nassert_eq!(100u16.wrapping_sub(u16::max_value()), 101);"]}},{"name":"pub const fn wrapping_mul(self, rhs: u16) -> u16","details":{"description":["Wrapping (modular) multiplication. Computes self * rhs, wrapping around at the boundary of the type."],"example":["Basic usage:","Please note that this example is shared between integer types.\nWhich explains why u8 is used here.","assert_eq!(10u8.wrapping_mul(12), 120);\nassert_eq!(25u8.wrapping_mul(12), 44);"]}},{"name":"pub fn wrapping_div(self, rhs: u16) -> u16","details":{"description":["Wrapping (modular) division. Computes self / rhs. Wrapped division on unsigned types is just normal division. There's no way wrapping could ever happen. This function exists, so that all operations are accounted for in the wrapping operations."],"example":["Basic usage:","assert_eq!(100u16.wrapping_div(10), 10);"]}},{"name":"pub fn wrapping_div_euc(self, rhs: u16) -> u16","stability":["🔬 This is a nightly-only experimental API.  (euclidean_division #49048)"]},{"name":"pub fn wrapping_rem(self, rhs: u16) -> u16","details":{"description":["Wrapping (modular) remainder. Computes self % rhs. Wrapped remainder calculation on unsigned types is just the regular remainder calculation. There's no way wrapping could ever happen. This function exists, so that all operations are accounted for in the wrapping operations."],"example":["Basic usage:","assert_eq!(100u16.wrapping_rem(10), 0);"]}},{"name":"pub fn wrapping_mod_euc(self, rhs: u16) -> u16","stability":["🔬 This is a nightly-only experimental API.  (euclidean_division #49048)"]},{"name":"pub fn wrapping_neg(self) -> u16","details":{"description":["Wrapping (modular) negation. Computes -self, wrapping around at the boundary of the type.","Since unsigned types do not have negative equivalents all applications of this function will wrap (except for -0). For values smaller than the corresponding signed type's maximum the result is the same as casting the corresponding signed value. Any larger values are equivalent to MAX + 1 - (val - MAX - 1) where MAX is the corresponding signed type's maximum."],"example":["Basic usage:","Please note that this example is shared between integer types.\nWhich explains why i8 is used here.","assert_eq!(100i8.wrapping_neg(), -100);\nassert_eq!((-128i8).wrapping_neg(), -128);"]}},{"name":"pub const fn wrapping_shl(self, rhs: u32) -> u16","details":{"description":["Panic-free bitwise shift-left; yields self << mask(rhs), where mask removes any high-order bits of rhs that would cause the shift to exceed the bitwidth of the type.","Note that this is not the same as a rotate-left; the RHS of a wrapping shift-left is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a rotate_left function, which may be what you want instead."],"example":["Basic usage:","assert_eq!(1u16.wrapping_shl(7), 128);\nassert_eq!(1u16.wrapping_shl(128), 1);"]}},{"name":"pub const fn wrapping_shr(self, rhs: u32) -> u16","details":{"description":["Panic-free bitwise shift-right; yields self >> mask(rhs), where mask removes any high-order bits of rhs that would cause the shift to exceed the bitwidth of the type.","Note that this is not the same as a rotate-right; the RHS of a wrapping shift-right is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a rotate_right function, which may be what you want instead."],"example":["Basic usage:","assert_eq!(128u16.wrapping_shr(7), 1);\nassert_eq!(128u16.wrapping_shr(128), 128);"]}},{"name":"pub fn wrapping_pow(self, exp: u32) -> u16","stability":["🔬 This is a nightly-only experimental API.  (no_panic_pow #48320)"]},{"name":"pub const fn overflowing_add(self, rhs: u16) -> (u16, bool)","details":{"description":["Calculates self + rhs","Returns a tuple of the addition along with a boolean indicating whether an arithmetic overflow would occur. If an overflow would have occurred then the wrapped value is returned."],"example":["Basic usage","use std::u16;\n\nassert_eq!(5u16.overflowing_add(2), (7, false));\nassert_eq!(u16::MAX.overflowing_add(1), (0, true));"]}},{"name":"pub const fn overflowing_sub(self, rhs: u16) -> (u16, bool)","details":{"description":["Calculates self - rhs","Returns a tuple of the subtraction along with a boolean indicating whether an arithmetic overflow would occur. If an overflow would have occurred then the wrapped value is returned."],"example":["Basic usage","use std::u16;\n\nassert_eq!(5u16.overflowing_sub(2), (3, false));\nassert_eq!(0u16.overflowing_sub(1), (u16::MAX, true));"]}},{"name":"pub const fn overflowing_mul(self, rhs: u16) -> (u16, bool)","details":{"description":["Calculates the multiplication of self and rhs.","Returns a tuple of the multiplication along with a boolean indicating whether an arithmetic overflow would occur. If an overflow would have occurred then the wrapped value is returned."],"example":["Basic usage:","Please note that this example is shared between integer types.\nWhich explains why u32 is used here.","assert_eq!(5u32.overflowing_mul(2), (10, false));\nassert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));"]}},{"name":"pub fn overflowing_div(self, rhs: u16) -> (u16, bool)","details":{"description":["Calculates the divisor when self is divided by rhs.","Returns a tuple of the divisor along with a boolean indicating whether an arithmetic overflow would occur. Note that for unsigned integers overflow never occurs, so the second value is always false.","Panics","This function will panic if rhs is 0."],"example":["Basic usage","assert_eq!(5u16.overflowing_div(2), (2, false));"]}},{"name":"pub fn overflowing_div_euc(self, rhs: u16) -> (u16, bool)","stability":["🔬 This is a nightly-only experimental API.  (euclidean_division #49048)"]},{"name":"pub fn overflowing_rem(self, rhs: u16) -> (u16, bool)","details":{"description":["Calculates the remainder when self is divided by rhs.","Returns a tuple of the remainder after dividing along with a boolean indicating whether an arithmetic overflow would occur. Note that for unsigned integers overflow never occurs, so the second value is always false.","Panics","This function will panic if rhs is 0."],"example":["Basic usage","assert_eq!(5u16.overflowing_rem(2), (1, false));"]}},{"name":"pub fn overflowing_mod_euc(self, rhs: u16) -> (u16, bool)","stability":["🔬 This is a nightly-only experimental API.  (euclidean_division #49048)"]},{"name":"pub fn overflowing_neg(self) -> (u16, bool)","details":{"description":["Negates self in an overflowing fashion.","Returns !self + 1 using wrapping operations to return the value that represents the negation of this unsigned value. Note that for positive unsigned values overflow always occurs, but negating 0 does not overflow."],"example":["Basic usage","assert_eq!(0u16.overflowing_neg(), (0, false));\nassert_eq!(2u16.overflowing_neg(), (-2i32 as u16, true));"]}},{"name":"pub const fn overflowing_shl(self, rhs: u32) -> (u16, bool)","details":{"description":["Shifts self left by rhs bits.","Returns a tuple of the shifted version of self along with a boolean indicating whether the shift value was larger than or equal to the number of bits. If the shift value is too large, then value is masked (N-1) where N is the number of bits, and this value is then used to perform the shift."],"example":["Basic usage","assert_eq!(0x1u16.overflowing_shl(4), (0x10, false));\nassert_eq!(0x1u16.overflowing_shl(132), (0x10, true));"]}},{"name":"pub const fn overflowing_shr(self, rhs: u32) -> (u16, bool)","details":{"description":["Shifts self right by rhs bits.","Returns a tuple of the shifted version of self along with a boolean indicating whether the shift value was larger than or equal to the number of bits. If the shift value is too large, then value is masked (N-1) where N is the number of bits, and this value is then used to perform the shift."],"example":["Basic usage","assert_eq!(0x10u16.overflowing_shr(4), (0x1, false));\nassert_eq!(0x10u16.overflowing_shr(132), (0x1, true));"]}},{"name":"pub fn overflowing_pow(self, exp: u32) -> (u16, bool)","stability":["🔬 This is a nightly-only experimental API.  (no_panic_pow #48320)"]},{"name":"pub fn pow(self, exp: u32) -> u16","details":{"description":["Raises self to the power of exp, using exponentiation by squaring."],"example":["Basic usage:","assert_eq!(2u16.pow(5), 32);"]}},{"name":"pub fn div_euc(self, rhs: u16) -> u16","stability":["🔬 This is a nightly-only experimental API.  (euclidean_division #49048)"]},{"name":"pub fn mod_euc(self, rhs: u16) -> u16","stability":["🔬 This is a nightly-only experimental API.  (euclidean_division #49048)"]},{"name":"pub fn is_power_of_two(self) -> bool","details":{"description":["Returns true if and only if self == 2^k for some k."],"example":["Basic usage:","assert!(16u16.is_power_of_two());\nassert!(!10u16.is_power_of_two());"]}},{"name":"pub fn next_power_of_two(self) -> u16","details":{"description":["Returns the smallest power of two greater than or equal to self.","When return value overflows (i.e. self > (1 << (N-1)) for type uN), it panics in debug mode and return value is wrapped to 0 in release mode (the only situation in which method can return 0)."],"example":["Basic usage:","assert_eq!(2u16.next_power_of_two(), 2);\nassert_eq!(3u16.next_power_of_two(), 4);"]}},{"name":"pub fn checked_next_power_of_two(self) -> Option<u16>","details":{"description":["Returns the smallest power of two greater than or equal to n. If the next power of two is greater than the type's maximum value, None is returned, otherwise the power of two is wrapped in Some."],"example":["Basic usage:","assert_eq!(2u16.checked_next_power_of_two(), Some(2));\nassert_eq!(3u16.checked_next_power_of_two(), Some(4));\nassert_eq!(u16::max_value().checked_next_power_of_two(), None);"]}},{"name":"pub fn wrapping_next_power_of_two(self) -> u16","stability":["🔬 This is a nightly-only experimental API.  (wrapping_next_power_of_two #32463)needs decision on wrapping behaviour\n"]},{"name":"pub const fn to_be_bytes(self) -> [u8; 2]","stability":["🔬 This is a nightly-only experimental API.  (int_to_from_bytes #52963)"]},{"name":"pub const fn to_le_bytes(self) -> [u8; 2]","stability":["🔬 This is a nightly-only experimental API.  (int_to_from_bytes #52963)"]},{"name":"pub const fn to_ne_bytes(self) -> [u8; 2]","stability":["🔬 This is a nightly-only experimental API.  (int_to_from_bytes #52963)"]},{"name":"pub const fn from_be_bytes(bytes: [u8; 2]) -> u16","stability":["🔬 This is a nightly-only experimental API.  (int_to_from_bytes #52963)"]},{"name":"pub const fn from_le_bytes(bytes: [u8; 2]) -> u16","stability":["🔬 This is a nightly-only experimental API.  (int_to_from_bytes #52963)"]},{"name":"pub const fn from_ne_bytes(bytes: [u8; 2]) -> u16","stability":["🔬 This is a nightly-only experimental API.  (int_to_from_bytes #52963)"]}]}