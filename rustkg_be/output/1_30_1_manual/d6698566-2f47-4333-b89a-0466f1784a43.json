{"stability":{"stable since":"1.0.0"},"apiName":"std::sync::Arc","apiType":"struct","apiDocumentation":{"apiDescription":["A thread-safe reference-counting pointer. 'Arc' stands for 'Atomically Reference Counted'.","The type Arc<T> provides shared ownership of a value of type T, allocated in the heap. Invoking clone on Arc produces a new Arc instance, which points to the same value on the heap as the source Arc, while increasing a reference count. When the last Arc pointer to a given value is destroyed, the pointed-to value is also destroyed.","Shared references in Rust disallow mutation by default, and Arc is no exception: you cannot generally obtain a mutable reference to something inside an Arc. If you need to mutate through an Arc, use Mutex, RwLock, or one of the Atomic types.","Thread Safety","Unlike Rc<T>, Arc<T> uses atomic operations for its reference counting. This means that it is thread-safe. The disadvantage is that atomic operations are more expensive than ordinary memory accesses. If you are not sharing reference-counted values between threads, consider using Rc<T> for lower overhead. Rc<T> is a safe default, because the compiler will catch any attempt to send an Rc<T> between threads. However, a library might choose Arc<T> in order to give library consumers more flexibility.","Arc<T> will implement Send and Sync as long as the T implements Send and Sync. Why can't you put a non-thread-safe type T in an Arc<T> to make it thread-safe? This may be a bit counter-intuitive at first: after all, isn't the point of Arc<T> thread safety? The key is this: Arc<T> makes it thread safe to have multiple ownership of the same data, but it doesn't add thread safety to its data. Consider Arc<RefCell<T>>. RefCell<T> isn't Sync, and if Arc<T> was always Send, Arc<RefCell<T>> would be as well. But then we'd have a problem: RefCell<T> is not thread safe; it keeps track of the borrowing count using non-atomic operations.","In the end, this means that you may need to pair Arc<T> with some sort of std::sync type, usually Mutex<T>.","Breaking cycles with Weak","The downgrade method can be used to create a non-owning Weak pointer. A Weak pointer can be upgraded to an Arc, but this will return None if the value has already been dropped.","A cycle between Arc pointers will never be deallocated. For this reason, Weak is used to break cycles. For example, a tree could have strong Arc pointers from parent nodes to children, and Weak pointers from children back to their parents.","Cloning references","Creating a new reference from an existing reference counted pointer is done using the Clone trait implemented for Arc<T> and Weak<T>.","use std::sync::Arc; let foo = Arc::new(vec![1.0, 2.0, 3.0]); // The two syntaxes below are equivalent. let a = foo.clone(); let b = Arc::clone(&foo); // a, b, and foo are all Arcs that point to the same memory location","The Arc::clone(&from) syntax is the most idiomatic because it conveys more explicitly the meaning of the code. In the example above, this syntax makes it easier to see that this code is creating a new reference rather than copying the whole content of foo.","Deref behavior","Arc<T> automatically dereferences to T (via the Deref trait), so you can call T's methods on a value of type Arc<T>. To avoid name clashes with T's methods, the methods of Arc<T> itself are associated functions, called using function-like syntax:","use std::sync::Arc; let my_arc = Arc::new(()); Arc::downgrade(&my_arc);","Weak<T> does not auto-dereference to T, because the value may have already been destroyed."],"examples":["Sharing some immutable data between threads:","use std::sync::Arc;\nuse std::thread;\n\nlet five = Arc::new(5);\n\nfor _ in 0..10 {\n    let five = Arc::clone(&five);\n\n    thread::spawn(move || {\n        println!(\"{:?}\", five);\n    });\n}","Sharing a mutable AtomicUsize:","use std::sync::Arc;\nuse std::sync::atomic::{AtomicUsize, Ordering};\nuse std::thread;\n\nlet val = Arc::new(AtomicUsize::new(5));\n\nfor _ in 0..10 {\n    let val = Arc::clone(&val);\n\n    thread::spawn(move || {\n        let v = val.fetch_add(1, Ordering::SeqCst);\n        println!(\"{:?}\", v);\n    });\n}","See the rc documentation for more examples of reference\ncounting in general."]},"trait implementations":[{"name":"impl<T> std::cmp::PartialOrd<std::sync::Arc<T>> for std::sync::Arc<T> where T: std::cmp::PartialOrd<T> + ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::convert::AsRef<T> for std::sync::Arc<T> where T: ?std::marker::Sized","stable since":"1.5.0"},{"name":"impl<T> std::ops::Drop for std::sync::Arc<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::cmp::Eq for std::sync::Arc<T> where T: std::cmp::Eq + ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::ops::Deref for std::sync::Arc<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::borrow::Borrow<T> for std::sync::Arc<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::marker::Sync for std::sync::Arc<T> where T: std::marker::Send + std::marker::Sync + ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::marker::Send for std::sync::Arc<T> where T: std::marker::Send + std::marker::Sync + ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::default::Default for std::sync::Arc<T> where T: std::default::Default","stable since":"1.0.0"},{"name":"impl<T> std::pin::Unpin for std::sync::Arc<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::fmt::Display for std::sync::Arc<T> where T: std::fmt::Display + ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl std::convert::From<std::string::String> for std::sync::Arc<str>","stable since":"1.21.0"},{"name":"impl<'a> std::convert::From<&'a str> for std::sync::Arc<str>","stable since":"1.21.0"},{"name":"impl<T> std::convert::From<std::vec::Vec<T>> for std::sync::Arc<[T]>","stable since":"1.21.0"},{"name":"impl<T> std::convert::From<std::sync::Arc<T>> for std::task::Waker where T: std::task::Wake + 'static","stable since":"1.0.0"},{"name":"impl<T> std::convert::From<T> for std::sync::Arc<T>","stable since":"1.6.0"},{"name":"impl<T> std::convert::From<std::boxed::Box<T>> for std::sync::Arc<T> where T: ?std::marker::Sized","stable since":"1.21.0"},{"name":"impl<'a, T> std::convert::From<&'a [T]> for std::sync::Arc<[T]> where T: std::clone::Clone","stable since":"1.21.0"},{"name":"impl<T> std::clone::Clone for std::sync::Arc<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::hash::Hash for std::sync::Arc<T> where T: std::hash::Hash + ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::fmt::Debug for std::sync::Arc<T> where T: std::fmt::Debug + ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T, U> std::ops::CoerceUnsized<std::sync::Arc<U>> for std::sync::Arc<T> where T: std::marker::Unsize<U> + ?std::marker::Sized, U: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::cmp::PartialEq<std::sync::Arc<T>> for std::sync::Arc<T> where T: std::cmp::PartialEq<T> + ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::fmt::Pointer for std::sync::Arc<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::cmp::Ord for std::sync::Arc<T> where T: std::cmp::Ord + ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl std::convert::From<std::ffi::CString> for std::sync::Arc<std::ffi::CStr>","stable since":"1.24.0"},{"name":"impl<'a> std::convert::From<&'a std::ffi::CStr> for std::sync::Arc<std::ffi::CStr>","stable since":"1.24.0"},{"name":"impl std::convert::From<std::ffi::OsString> for std::sync::Arc<std::ffi::OsStr>","stable since":"1.24.0"},{"name":"impl<'a> std::convert::From<&'a std::ffi::OsStr> for std::sync::Arc<std::ffi::OsStr>","stable since":"1.24.0"},{"name":"impl<T: std::panic::RefUnwindSafe + ?std::marker::Sized> std::panic::UnwindSafe for std::sync::Arc<T>","stable since":"1.9.0"},{"name":"impl std::convert::From<std::path::PathBuf> for std::sync::Arc<std::path::Path>","stable since":"1.24.0"},{"name":"impl<'a> std::convert::From<&'a std::path::Path> for std::sync::Arc<std::path::Path>","stable since":"1.24.0"}],"methods":[{"name":"pub fn new(data: T) -> Arc<T>","details":{"description":["Constructs a new Arc<T>."],"example":["use std::sync::Arc;\n\nlet five = Arc::new(5);"]}},{"name":"pub fn try_unwrap(this: Arc<T>) -> Result<T, Arc<T>>","details":{"description":["Returns the contained value, if the Arc has exactly one strong reference.","Otherwise, an Err is returned with the same Arc that was passed in.","This will succeed even if there are outstanding weak references."],"example":["use std::sync::Arc;\n\nlet x = Arc::new(3);\nassert_eq!(Arc::try_unwrap(x), Ok(3));\n\nlet x = Arc::new(4);\nlet _y = Arc::clone(&x);\nassert_eq!(*Arc::try_unwrap(x).unwrap_err(), 4);"]}},{"name":"pub fn into_raw(this: Arc<T>) -> *const T","details":{"description":["Consumes the Arc, returning the wrapped pointer.","To avoid a memory leak the pointer must be converted back to an Arc using Arc::from_raw."],"example":["use std::sync::Arc;\n\nlet x = Arc::new(10);\nlet x_ptr = Arc::into_raw(x);\nassert_eq!(unsafe { *x_ptr }, 10);"]}},{"name":"pub unsafe fn from_raw(ptr: *const T) -> Arc<T>","details":{"description":["Constructs an Arc from a raw pointer.","The raw pointer must have been previously returned by a call to a Arc::into_raw.","This function is unsafe because improper use may lead to memory problems. For example, a double-free may occur if the function is called twice on the same raw pointer."],"example":["use std::sync::Arc;\n\nlet x = Arc::new(10);\nlet x_ptr = Arc::into_raw(x);\n\nunsafe {\n    // Convert back to an `Arc` to prevent leak.\n    let x = Arc::from_raw(x_ptr);\n    assert_eq!(*x, 10);\n\n    // Further calls to `Arc::from_raw(x_ptr)` would be memory unsafe.\n}\n\n// The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!"]}},{"name":"pub fn downgrade(this: &Arc<T>) -> Weak<T>","details":{"description":["Creates a new Weak pointer to this value."],"example":["use std::sync::Arc;\n\nlet five = Arc::new(5);\n\nlet weak_five = Arc::downgrade(&five);"]}},{"name":"pub fn weak_count(this: &Arc<T>) -> usize","details":{"description":["Gets the number of Weak pointers to this value.","Safety","This method by itself is safe, but using it correctly requires extra care. Another thread can change the weak count at any time, including potentially between calling this method and acting on the result."],"example":["use std::sync::Arc;\n\nlet five = Arc::new(5);\nlet _weak_five = Arc::downgrade(&five);\n\n// This assertion is deterministic because we haven't shared\n// the `Arc` or `Weak` between threads.\nassert_eq!(1, Arc::weak_count(&five));"]}},{"name":"pub fn strong_count(this: &Arc<T>) -> usize","details":{"description":["Gets the number of strong (Arc) pointers to this value.","Safety","This method by itself is safe, but using it correctly requires extra care. Another thread can change the strong count at any time, including potentially between calling this method and acting on the result."],"example":["use std::sync::Arc;\n\nlet five = Arc::new(5);\nlet _also_five = Arc::clone(&five);\n\n// This assertion is deterministic because we haven't shared\n// the `Arc` between threads.\nassert_eq!(2, Arc::strong_count(&five));"]}},{"name":"pub fn ptr_eq(this: &Arc<T>, other: &Arc<T>) -> bool","details":{"description":["Returns true if the two Arcs point to the same value (not just values that compare as equal)."],"example":["use std::sync::Arc;\n\nlet five = Arc::new(5);\nlet same_five = Arc::clone(&five);\nlet other_five = Arc::new(5);\n\nassert!(Arc::ptr_eq(&five, &same_five));\nassert!(!Arc::ptr_eq(&five, &other_five));"]}},{"name":"pub fn make_mut(this: &mut Arc<T>) -> &mut T","details":{"description":["Makes a mutable reference into the given Arc.","If there are other Arc or Weak pointers to the same value, then make_mut will invoke clone on the inner value to ensure unique ownership. This is also referred to as clone-on-write.","See also get_mut, which will fail rather than cloning."],"example":["use std::sync::Arc;\n\nlet mut data = Arc::new(5);\n\n*Arc::make_mut(&mut data) += 1;         // Won't clone anything\nlet mut other_data = Arc::clone(&data); // Won't clone inner data\n*Arc::make_mut(&mut data) += 1;         // Clones inner data\n*Arc::make_mut(&mut data) += 1;         // Won't clone anything\n*Arc::make_mut(&mut other_data) *= 2;   // Won't clone anything\n\n// Now `data` and `other_data` point to different values.\nassert_eq!(*data, 8);\nassert_eq!(*other_data, 12);"]}},{"name":"pub fn get_mut(this: &mut Arc<T>) -> Option<&mut T>","details":{"description":["Returns a mutable reference to the inner value, if there are no other Arc or Weak pointers to the same value.","Returns None otherwise, because it is not safe to mutate a shared value.","See also make_mut, which will clone the inner value when it's shared."],"example":["use std::sync::Arc;\n\nlet mut x = Arc::new(3);\n*Arc::get_mut(&mut x).unwrap() = 4;\nassert_eq!(*x, 4);\n\nlet _y = Arc::clone(&x);\nassert!(Arc::get_mut(&mut x).is_none());"]}},{"name":"pub fn downcast<T>(self) -> Result<Arc<T>, Arc<Any + 'static + Sync + Send>> where T: Any + Send + Sync + 'static","details":{"description":["Attempt to downcast the Arc<dyn Any + Send + Sync> to a concrete type."],"example":["use std::any::Any;\nuse std::sync::Arc;\n\nfn print_if_string(value: Arc<dyn Any + Send + Sync>) {\n    if let Ok(string) = value.downcast::<String>() {\n        println!(\"String ({}): {}\", string.len(), string);\n    }\n}\n\nfn main() {\n    let my_string = \"Hello World\".to_string();\n    print_if_string(Arc::new(my_string));\n    print_if_string(Arc::new(0i8));\n}"]}}]}