{"stability":{"stable since":"1.0.0"},"apiName":"std::sync::atomic","apiType":"module","apiDocumentation":{"apiDescription":["Atomic types","Atomic types provide primitive shared-memory communication between threads, and are the building blocks of other concurrent types.","This module defines atomic versions of a select number of primitive types, including AtomicBool, AtomicIsize, and AtomicUsize. Atomic types present operations that, when used correctly, synchronize updates between threads.","Each method takes an Ordering which represents the strength of the memory barrier for that operation. These orderings are the same as LLVM atomic orderings. For more information see the nomicon.","Atomic variables are safe to share between threads (they implement Sync) but they do not themselves provide the mechanism for sharing and follow the threading model of rust. The most common way to share an atomic variable is to put it into an Arc (an atomically-reference-counted shared pointer).","Most atomic types may be stored in static variables, initialized using the provided static initializers like ATOMIC_BOOL_INIT. Atomic statics are often used for lazy global initialization."],"examples":["A simple spinlock:","use std::sync::Arc;\nuse std::sync::atomic::{AtomicUsize, Ordering};\nuse std::thread;\n\nfn main() {\n    let spinlock = Arc::new(AtomicUsize::new(1));\n\n    let spinlock_clone = spinlock.clone();\n    let thread = thread::spawn(move|| {\n        spinlock_clone.store(0, Ordering::SeqCst);\n    });\n\n    // Wait for the other thread to release the lock\n    while spinlock.load(Ordering::SeqCst) != 0 {}\n\n    if let Err(panic) = thread.join() {\n        println!(\"Thread had an error: {:?}\", panic);\n    }\n}","Keep a global count of live threads:","use std::sync::atomic::{AtomicUsize, Ordering, ATOMIC_USIZE_INIT};\n\nstatic GLOBAL_THREAD_COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n\nlet old_thread_count = GLOBAL_THREAD_COUNT.fetch_add(1, Ordering::SeqCst);\nprintln!(\"live threads: {}\", old_thread_count + 1);"]},"children":["std::sync::atomic::AtomicBool","std::sync::atomic::AtomicIsize","std::sync::atomic::AtomicPtr","std::sync::atomic::AtomicUsize","std::sync::atomic::AtomicI8","std::sync::atomic::AtomicI16","std::sync::atomic::AtomicI32","std::sync::atomic::AtomicI64","std::sync::atomic::AtomicU8","std::sync::atomic::AtomicU16","std::sync::atomic::AtomicU32","std::sync::atomic::AtomicU64","std::sync::atomic::Ordering","std::sync::atomic::ATOMIC_BOOL_INIT","std::sync::atomic::ATOMIC_ISIZE_INIT","std::sync::atomic::ATOMIC_USIZE_INIT","std::sync::atomic::ATOMIC_I8_INIT","std::sync::atomic::ATOMIC_I16_INIT","std::sync::atomic::ATOMIC_I32_INIT","std::sync::atomic::ATOMIC_I64_INIT","std::sync::atomic::ATOMIC_U8_INIT","std::sync::atomic::ATOMIC_U16_INIT","std::sync::atomic::ATOMIC_U32_INIT","std::sync::atomic::ATOMIC_U64_INIT","std::sync::atomic::compiler_fence","std::sync::atomic::fence","std::sync::atomic::spin_loop_hint"]}