{"stability":{"unstable":"ðŸ”¬ This is a nightly-only experimental API.  (allocator_api #32838)"},"apiName":"std::alloc::Alloc","apiType":"trait","apiDocumentation":{"apiDescription":["An implementation of Alloc can allocate, reallocate, and deallocate arbitrary blocks of data described via Layout.","Some of the methods require that a memory block be currently allocated via an allocator. This means that:","the starting address for that memory block was previously returned by a previous call to an allocation method (alloc, alloc_zeroed, alloc_excess, alloc_one, alloc_array) or reallocation method (realloc, realloc_excess, or realloc_array), and the memory block has not been subsequently deallocated, where blocks are deallocated either by being passed to a deallocation method (dealloc, dealloc_one, dealloc_array) or by being passed to a reallocation method (see above) that returns Ok.","A note regarding zero-sized types and zero-sized layouts: many methods in the Alloc trait state that allocation requests must be non-zero size, or else undefined behavior can result.","However, some higher-level allocation methods (alloc_one, alloc_array) are well-defined on zero-sized types and can optionally support them: it is left up to the implementor whether to return Err, or to return Ok with some pointer. If an Alloc implementation chooses to return Ok in this case (i.e. the pointer denotes a zero-sized inaccessible block) then that returned pointer must be considered \"currently allocated\". On such an allocator, all methods that take currently-allocated pointers as inputs must accept these zero-sized pointers, without causing undefined behavior. In other words, if a zero-sized pointer can flow out of an allocator, then that allocator must likewise accept that pointer flowing back into its deallocation and reallocation methods.","Some of the methods require that a layout fit a memory block. What it means for a layout to \"fit\" a memory block means (or equivalently, for a memory block to \"fit\" a layout) is that the following two conditions must hold:","The block's starting address must be aligned to layout.align(). The block's size must fall in the range [use_min, use_max], where: use_min is self.usable_size(layout).0, and use_max is the capacity that was (or would have been) returned when (if) the block was allocated via a call to alloc_excess or realloc_excess.","Note that:","the size of the layout most recently used to allocate the block is guaranteed to be in the range [use_min, use_max], and a lower-bound on use_max can be safely approximated by a call to usable_size. if a layout k fits a memory block (denoted by ptr) currently allocated via an allocator a, then it is legal to use that layout to deallocate it, i.e. a.dealloc(ptr, k);.","Unsafety","The Alloc trait is an unsafe trait for a number of reasons, and implementors must ensure that they adhere to these contracts:","Pointers returned from allocation functions must point to valid memory and retain their validity until at least the instance of Alloc is dropped itself. Layout queries and calculations in general must be correct. Callers of this trait are allowed to rely on the contracts defined on each method, and implementors must ensure such contracts remain true.","Note that this list may get tweaked over time as clarifications are made in the future."]},"trait required methods":[{"name":"unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr>","stability":["ðŸ”¬ This is a nightly-only experimental API.  (allocator_api #32838)"]},{"name":"unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout)","stability":["ðŸ”¬ This is a nightly-only experimental API.  (allocator_api #32838)"]}],"trait provided methods":[{"name":"fn usable_size(&self, layout: &Layout) -> (usize, usize)","stability":["ðŸ”¬ This is a nightly-only experimental API.  (allocator_api #32838)"]},{"name":"unsafe fn realloc( &mut self, ptr: NonNull<u8>, layout: Layout, new_size: usize) -> Result<NonNull<u8>, AllocErr>","stability":["ðŸ”¬ This is a nightly-only experimental API.  (allocator_api #32838)"]},{"name":"unsafe fn alloc_zeroed( &mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr>","stability":["ðŸ”¬ This is a nightly-only experimental API.  (allocator_api #32838)"]},{"name":"unsafe fn alloc_excess(&mut self, layout: Layout) -> Result<Excess, AllocErr>","stability":["ðŸ”¬ This is a nightly-only experimental API.  (allocator_api #32838)"]},{"name":"unsafe fn realloc_excess( &mut self, ptr: NonNull<u8>, layout: Layout, new_size: usize) -> Result<Excess, AllocErr>","stability":["ðŸ”¬ This is a nightly-only experimental API.  (allocator_api #32838)"]},{"name":"unsafe fn grow_in_place( &mut self, ptr: NonNull<u8>, layout: Layout, new_size: usize) -> Result<(), CannotReallocInPlace>","stability":["ðŸ”¬ This is a nightly-only experimental API.  (allocator_api #32838)"]},{"name":"unsafe fn shrink_in_place( &mut self, ptr: NonNull<u8>, layout: Layout, new_size: usize) -> Result<(), CannotReallocInPlace>","stability":["ðŸ”¬ This is a nightly-only experimental API.  (allocator_api #32838)"]},{"name":"fn alloc_one<T>(&mut self) -> Result<NonNull<T>, AllocErr>","stability":["ðŸ”¬ This is a nightly-only experimental API.  (allocator_api #32838)"]},{"name":"unsafe fn dealloc_one<T>(&mut self, ptr: NonNull<T>)","stability":["ðŸ”¬ This is a nightly-only experimental API.  (allocator_api #32838)"]},{"name":"fn alloc_array<T>(&mut self, n: usize) -> Result<NonNull<T>, AllocErr>","stability":["ðŸ”¬ This is a nightly-only experimental API.  (allocator_api #32838)"]},{"name":"unsafe fn realloc_array<T>( &mut self, ptr: NonNull<T>, n_old: usize, n_new: usize) -> Result<NonNull<T>, AllocErr>","stability":["ðŸ”¬ This is a nightly-only experimental API.  (allocator_api #32838)"]},{"name":"unsafe fn dealloc_array<T>( &mut self, ptr: NonNull<T>, n: usize) -> Result<(), AllocErr>","stability":["ðŸ”¬ This is a nightly-only experimental API.  (allocator_api #32838)"]}]}