{"stability":{"stable since":"1.0.0"},"apiName":"std::ops::Shr","apiType":"trait","apiDocumentation":{"apiDescription":["The right shift operator >>. Note that because this trait is implemented for all integer types with multiple right-hand-side types, Rust's type checker has special handling for _ >> _, setting the result type for integer operations to the type of the left-hand-side operand. This means that though a >> b and a.shr(b) are one and the same from an evaluation standpoint, they are different when it comes to type inference."],"examples":["An implementation of Shr that lifts the >> operation on integers to a\nwrapper around usize.","use std::ops::Shr;\n\n#[derive(PartialEq, Debug)]\nstruct Scalar(usize);\n\nimpl Shr<Scalar> for Scalar {\n    type Output = Self;\n\n    fn shr(self, Scalar(rhs): Self) -> Scalar {\n        let Scalar(lhs) = self;\n        Scalar(lhs >> rhs)\n    }\n}\n\nassert_eq!(Scalar(16) >> Scalar(2), Scalar(4));","An implementation of Shr that spins a vector rightward by a given amount.","use std::ops::Shr;\n\n#[derive(PartialEq, Debug)]\nstruct SpinVector<T: Clone> {\n    vec: Vec<T>,\n}\n\nimpl<T: Clone> Shr<usize> for SpinVector<T> {\n    type Output = Self;\n\n    fn shr(self, rhs: usize) -> SpinVector<T> {\n        // Rotate the vector by `rhs` places.\n        let (a, b) = self.vec.split_at(self.vec.len() - rhs);\n        let mut spun_vector: Vec<T> = vec![];\n        spun_vector.extend_from_slice(b);\n        spun_vector.extend_from_slice(a);\n        SpinVector { vec: spun_vector }\n    }\n}\n\nassert_eq!(SpinVector { vec: vec![0, 1, 2, 3, 4] } >> 2,\n           SpinVector { vec: vec![3, 4, 0, 1, 2] });"]},"trait required methods":[{"name":"[+] Expand attributes#[must_use] fn shr(self, rhs: RHS) -> Self::Output","details":{"description":"Performs the >> operation."}}]}