{"stability":{"unstable":"ðŸ”¬ This is a nightly-only experimental API.  (pin #49150)"},"apiName":"std::pin","apiType":"module","apiDocumentation":{"apiDescription":["Types which pin data to its location in memory","It is sometimes useful to have objects that are guaranteed to not move, in the sense that their placement in memory does not change, and can thus be relied upon.","A prime example of such a scenario would be building self-referencial structs, since moving an object with pointers to itself will invalidate them, which could cause undefined behavior.","In order to prevent objects from moving, they must be pinned, by wrapping the data in pinning pointer types, such as PinMut and PinBox, which are otherwise equivalent to & mut and Box, respectively.","First of all, these are pointer types because pinned data mustn't be passed around by value (that would change its location in memory). Secondly, since data can be moved out of &mut and Box with functions such as swap, which causes their contents to swap places in memory, we need dedicated types that prohibit such operations.","However, these restrictions are usually not necessary, so most types implement the Unpin auto-trait, which indicates that the type can be moved out safely. Doing so removes the limitations of pinning types, making them the same as their non-pinning counterparts."],"examples":["#![feature(pin)]\n\nuse std::pin::PinBox;\nuse std::marker::Pinned;\nuse std::ptr::NonNull;\n\n// This is a self referencial struct since the slice field points to the data field.\n// We cannot inform the compiler about that with a normal reference,\n// since this pattern cannot be described with the usual borrowing rules.\n// Instead we use a raw pointer, though one which is known to not be null,\n// since we know it's pointing at the string.\nstruct Unmovable {\n    data: String,\n    slice: NonNull<String>,\n    _pin: Pinned,\n}\n\nimpl Unmovable {\n    // To ensure the data doesn't move when the function returns,\n    // we place it in the heap where it will stay for the lifetime of the object,\n    // and the only way to access it would be through a pointer to it.\n    fn new(data: String) -> PinBox<Self> {\n        let res = Unmovable {\n            data,\n            // we only create the pointer once the data is in place\n            // otherwise it will have already moved before we even started\n            slice: NonNull::dangling(),\n            _pin: Pinned,\n        };\n        let mut boxed = PinBox::new(res);\n\n        let slice = NonNull::from(&boxed.data);\n        // we know this is safe because modifying a field doesn't move the whole struct\n        unsafe { PinBox::get_mut(&mut boxed).slice = slice };\n        boxed\n    }\n}\n\nlet unmoved = Unmovable::new(\"hello\".to_string());\n// The pointer should point to the correct location,\n// so long as the struct hasn't moved.\n// Meanwhile, we are free to move the pointer around.\nlet mut still_unmoved = unmoved;\nassert_eq!(still_unmoved.slice, NonNull::from(&still_unmoved.data));\n\n// Since our type doesn't implement Unpin, this will fail to compile:\n// let new_unmoved = Unmovable::new(\"world\".to_string());\n// std::mem::swap(&mut *still_unmoved, &mut *new_unmoved);"]},"children":["std::pin::PinBox","std::pin::PinMut","std::pin::Unpin"]}