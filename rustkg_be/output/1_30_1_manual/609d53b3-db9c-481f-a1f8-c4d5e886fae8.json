{"stability":{"stable since":"1.0.0"},"apiName":"std::thread::Thread","apiType":"struct","apiDocumentation":{"apiDescription":["A handle to a thread.","Threads are represented via the Thread type, which you can get in one of two ways:","By spawning a new thread, e.g. using the thread::spawn function, and calling thread on the JoinHandle. By requesting the current thread, using the thread::current function.","The thread::current function is available even for threads not spawned by the APIs of this module.","There is usually no need to create a Thread struct yourself, one should instead use a function like spawn to create new threads, see the docs of Builder and spawn for more details."]},"trait implementations":[{"name":"impl std::clone::Clone for std::thread::Thread","stable since":"1.0.0"},{"name":"impl std::fmt::Debug for std::thread::Thread","stable since":"1.0.0"},{"name":"impl std::marker::Send for std::thread::Thread","stable since":"1.0.0"},{"name":"impl std::marker::Sync for std::thread::Thread","stable since":"1.0.0"}],"methods":[{"name":"pub fn unpark(&self)","details":{"description":["Atomically makes the handle's token available if it is not already.","Every thread is equipped with some basic low-level blocking support, via the park function and the unpark() method. These can be used as a more CPU-efficient implementation of a spinlock.","See the park documentation for more details."],"example":["use std::thread;\nuse std::time::Duration;\n\nlet parked_thread = thread::Builder::new()\n    .spawn(|| {\n        println!(\"Parking thread\");\n        thread::park();\n        println!(\"Thread unparked\");\n    })\n    .unwrap();\n\n// Let some time pass for the thread to be spawned.\nthread::sleep(Duration::from_millis(10));\n\nprintln!(\"Unpark the thread\");\nparked_thread.thread().unpark();\n\nparked_thread.join().unwrap();"]}},{"name":"pub fn id(&self) -> ThreadId","details":{"description":["Gets the thread's unique identifier."],"example":["use std::thread;\n\nlet other_thread = thread::spawn(|| {\n    thread::current().id()\n});\n\nlet other_thread_id = other_thread.join().unwrap();\nassert!(thread::current().id() != other_thread_id);"]}},{"name":"pub fn name(&self) -> Option<&str>","details":{"description":["Gets the thread's name.","For more information about named threads, see this module-level documentation."],"example":["Threads by default have no name specified:","use std::thread;\n\nlet builder = thread::Builder::new();\n\nlet handler = builder.spawn(|| {\n    assert!(thread::current().name().is_none());\n}).unwrap();\n\nhandler.join().unwrap();","Thread with a specified name:","use std::thread;\n\nlet builder = thread::Builder::new()\n    .name(\"foo\".into());\n\nlet handler = builder.spawn(|| {\n    assert_eq!(thread::current().name(), Some(\"foo\"))\n}).unwrap();\n\nhandler.join().unwrap();"]}}]}