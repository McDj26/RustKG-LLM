{"stability":{"stable since":"1.0.0"},"apiName":"std::marker::PhantomData","apiType":"struct","apiDocumentation":{"apiDescription":["Zero-sized type used to mark things that \"act like\" they own a T.","Adding a PhantomData<T> field to your type tells the compiler that your type acts as though it stores a value of type T, even though it doesn't really. This information is used when computing certain safety properties.","For a more in-depth explanation of how to use PhantomData<T>, please see the Nomicon.","A ghastly note ðŸ‘»ðŸ‘»ðŸ‘»","Though they both have scary names, PhantomData and 'phantom types' are related, but not identical. A phantom type parameter is simply a type parameter which is never used. In Rust, this often causes the compiler to complain, and the solution is to add a \"dummy\" use by way of PhantomData."],"examples":["Unused lifetime parameters","Perhaps the most common use case for PhantomData is a struct that has an\nunused lifetime parameter, typically as part of some unsafe code. For\nexample, here is a struct Slice that has two pointers of type *const T,\npresumably pointing into an array somewhere:","â“˜This example deliberately fails to compile","struct Slice<'a, T> {\n    start: *const T,\n    end: *const T,\n}","The intention is that the underlying data is only valid for the\nlifetime 'a, so Slice should not outlive 'a. However, this\nintent is not expressed in the code, since there are no uses of\nthe lifetime 'a and hence it is not clear what data it applies\nto. We can correct this by telling the compiler to act as if the\nSlice struct contained a reference &'a T:","use std::marker::PhantomData;\n\nstruct Slice<'a, T: 'a> {\n    start: *const T,\n    end: *const T,\n    phantom: PhantomData<&'a T>,\n}","This also in turn requires the annotation T: 'a, indicating\nthat any references in T are valid over the lifetime 'a.","When initializing a Slice you simply provide the value\nPhantomData for the field phantom:","fn borrow_vec<'a, T>(vec: &'a Vec<T>) -> Slice<'a, T> {\n    let ptr = vec.as_ptr();\n    Slice {\n        start: ptr,\n        end: unsafe { ptr.add(vec.len()) },\n        phantom: PhantomData,\n    }\n}","Unused type parameters","It sometimes happens that you have unused type parameters which\nindicate what type of data a struct is \"tied\" to, even though that\ndata is not actually found in the struct itself. Here is an\nexample where this arises with FFI. The foreign interface uses\nhandles of type *mut () to refer to Rust values of different\ntypes. We track the Rust type using a phantom type parameter on\nthe struct ExternalResource which wraps a handle.","use std::marker::PhantomData;\nuse std::mem;\n\nstruct ExternalResource<R> {\n   resource_handle: *mut (),\n   resource_type: PhantomData<R>,\n}\n\nimpl<R: ResType> ExternalResource<R> {\n    fn new() -> ExternalResource<R> {\n        let size_of_res = mem::size_of::<R>();\n        ExternalResource {\n            resource_handle: foreign_lib::new(size_of_res),\n            resource_type: PhantomData,\n        }\n    }\n\n    fn do_stuff(&self, param: ParamType) {\n        let foreign_params = convert_params(param);\n        foreign_lib::do_stuff(self.resource_handle, foreign_params);\n    }\n}","Ownership and the drop check","Adding a field of type PhantomData<T> indicates that your\ntype owns data of type T. This in turn implies that when your\ntype is dropped, it may drop one or more instances of the type\nT. This has bearing on the Rust compiler's drop check\nanalysis.","If your struct does not in fact own the data of type T, it is\nbetter to use a reference type, like PhantomData<&'a T>\n(ideally) or PhantomData<*const T> (if no lifetime applies), so\nas not to indicate ownership."]},"trait implementations":[{"name":"impl<T> std::hash::Hash for std::marker::PhantomData<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::clone::Clone for std::marker::PhantomData<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::cmp::PartialOrd<std::marker::PhantomData<T>> for std::marker::PhantomData<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::cmp::Ord for std::marker::PhantomData<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::fmt::Debug for std::marker::PhantomData<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::cmp::Eq for std::marker::PhantomData<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::cmp::PartialEq<std::marker::PhantomData<T>> for std::marker::PhantomData<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::marker::Copy for std::marker::PhantomData<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T> std::default::Default for std::marker::PhantomData<T> where T: ?std::marker::Sized","stable since":"1.0.0"},{"name":"impl<T: ?std::marker::Sized> std::marker::Send for std::marker::PhantomData<T> where T: std::marker::Send","stable since":"1.0.0"},{"name":"impl<T: ?std::marker::Sized> std::marker::Sync for std::marker::PhantomData<T> where T: std::marker::Sync","stable since":"1.0.0"}]}