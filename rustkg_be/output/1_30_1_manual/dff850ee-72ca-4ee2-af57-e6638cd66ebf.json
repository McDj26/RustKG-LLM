{"stability":{"stable since":"1.0.0"},"apiName":"std::ops::BitAnd","apiType":"trait","apiDocumentation":{"apiDescription":["The bitwise AND operator &.","Note that RHS is Self by default, but this is not mandatory."],"examples":["An implementation of BitAnd for a wrapper around bool.","use std::ops::BitAnd;\n\n#[derive(Debug, PartialEq)]\nstruct Scalar(bool);\n\nimpl BitAnd for Scalar {\n    type Output = Self;\n\n    // rhs is the \"right-hand side\" of the expression `a & b`\n    fn bitand(self, rhs: Self) -> Self {\n        Scalar(self.0 & rhs.0)\n    }\n}\n\nassert_eq!(Scalar(true) & Scalar(true), Scalar(true));\nassert_eq!(Scalar(true) & Scalar(false), Scalar(false));\nassert_eq!(Scalar(false) & Scalar(true), Scalar(false));\nassert_eq!(Scalar(false) & Scalar(false), Scalar(false));","An implementation of BitAnd for a wrapper around Vec<bool>.","use std::ops::BitAnd;\n\n#[derive(Debug, PartialEq)]\nstruct BooleanVector(Vec<bool>);\n\nimpl BitAnd for BooleanVector {\n    type Output = Self;\n\n    fn bitand(self, BooleanVector(rhs): Self) -> Self {\n        let BooleanVector(lhs) = self;\n        assert_eq!(lhs.len(), rhs.len());\n        BooleanVector(lhs.iter().zip(rhs.iter()).map(|(x, y)| *x && *y).collect())\n    }\n}\n\nlet bv1 = BooleanVector(vec![true, true, false, false]);\nlet bv2 = BooleanVector(vec![true, false, true, false]);\nlet expected = BooleanVector(vec![true, false, false, false]);\nassert_eq!(bv1 & bv2, expected);"]},"trait required methods":[{"name":"[+] Expand attributes#[must_use] fn bitand(self, rhs: RHS) -> Self::Output","details":{"description":"Performs the & operation."}}]}