{"stability":{"stable since":"1.0.0"},"apiName":"std::net::Ipv4Addr","apiType":"struct","apiDocumentation":{"apiDescription":["An IPv4 address.","IPv4 addresses are defined as 32-bit integers in IETF RFC 791. They are usually represented as four octets.","See IpAddr for a type encompassing both IPv4 and IPv6 addresses.","The size of an Ipv4Addr struct may vary depending on the target operating system.","Textual representation","Ipv4Addr provides a FromStr implementation. The four octets are in decimal notation, divided by . (this is called \"dot-decimal notation\")."],"examples":["use std::net::Ipv4Addr;\n\nlet localhost = Ipv4Addr::new(127, 0, 0, 1);\nassert_eq!(\"127.0.0.1\".parse(), Ok(localhost));\nassert_eq!(localhost.is_loopback(), true);"]},"trait implementations":[{"name":"impl std::marker::Copy for std::net::Ipv4Addr","stable since":"1.0.0"},{"name":"impl std::convert::From<std::net::Ipv4Addr> for std::net::IpAddr","stable since":"1.16.0"},{"name":"impl std::fmt::Display for std::net::Ipv4Addr","stable since":"1.0.0"},{"name":"impl std::fmt::Debug for std::net::Ipv4Addr","stable since":"1.0.0"},{"name":"impl std::clone::Clone for std::net::Ipv4Addr","stable since":"1.0.0"},{"name":"impl std::cmp::PartialEq for std::net::Ipv4Addr","stable since":"1.0.0"},{"name":"impl std::cmp::PartialEq<std::net::Ipv4Addr> for std::net::IpAddr","stable since":"1.16.0"},{"name":"impl std::cmp::PartialEq<std::net::IpAddr> for std::net::Ipv4Addr","stable since":"1.16.0"},{"name":"impl std::cmp::Eq for std::net::Ipv4Addr","stable since":"1.0.0"},{"name":"impl std::hash::Hash for std::net::Ipv4Addr","stable since":"1.0.0"},{"name":"impl std::cmp::PartialOrd for std::net::Ipv4Addr","stable since":"1.0.0"},{"name":"impl std::cmp::PartialOrd<std::net::Ipv4Addr> for std::net::IpAddr","stable since":"1.16.0"},{"name":"impl std::cmp::PartialOrd<std::net::IpAddr> for std::net::Ipv4Addr","stable since":"1.16.0"},{"name":"impl std::cmp::Ord for std::net::Ipv4Addr","stable since":"1.0.0"},{"name":"impl std::convert::From<std::net::Ipv4Addr> for u32","stable since":"1.1.0"},{"name":"impl std::convert::From<u32> for std::net::Ipv4Addr","stable since":"1.1.0"},{"name":"impl std::convert::From<[u8; 4]> for std::net::Ipv4Addr","stable since":"1.9.0"},{"name":"impl std::str::FromStr for std::net::Ipv4Addr","stable since":"1.0.0"},{"name":"impl std::marker::Send for std::net::Ipv4Addr","stable since":"1.0.0"},{"name":"impl std::marker::Sync for std::net::Ipv4Addr","stable since":"1.0.0"}],"methods":[{"name":"pub const fn new(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr","details":{"description":["Creates a new IPv4 address from four eight-bit octets.","The result will represent the IP address a.b.c.d."],"example":["use std::net::Ipv4Addr;\n\nlet addr = Ipv4Addr::new(127, 0, 0, 1);"]}},{"name":"pub fn octets(&self) -> [u8; 4]","details":{"description":["Returns the four eight-bit integers that make up this address."],"example":["use std::net::Ipv4Addr;\n\nlet addr = Ipv4Addr::new(127, 0, 0, 1);\nassert_eq!(addr.octets(), [127, 0, 0, 1]);"]}},{"name":"pub fn is_unspecified(&self) -> bool","details":{"description":["Returns true for the special 'unspecified' address (0.0.0.0).","This property is defined in UNIX Network Programming, Second Edition, W. Richard Stevens, p. 891; see also ip7."],"example":["use std::net::Ipv4Addr;\n\nassert_eq!(Ipv4Addr::new(0, 0, 0, 0).is_unspecified(), true);\nassert_eq!(Ipv4Addr::new(45, 22, 13, 197).is_unspecified(), false);"]}},{"name":"pub fn is_loopback(&self) -> bool","details":{"description":["Returns true if this is a loopback address (127.0.0.0/8).","This property is defined by IETF RFC 1122."],"example":["use std::net::Ipv4Addr;\n\nassert_eq!(Ipv4Addr::new(127, 0, 0, 1).is_loopback(), true);\nassert_eq!(Ipv4Addr::new(45, 22, 13, 197).is_loopback(), false);"]}},{"name":"pub fn is_private(&self) -> bool","details":{"description":["Returns true if this is a private address.","The private address ranges are defined in IETF RFC 1918 and include:","10.0.0.0/8 172.16.0.0/12 192.168.0.0/16"],"example":["use std::net::Ipv4Addr;\n\nassert_eq!(Ipv4Addr::new(10, 0, 0, 1).is_private(), true);\nassert_eq!(Ipv4Addr::new(10, 10, 10, 10).is_private(), true);\nassert_eq!(Ipv4Addr::new(172, 16, 10, 10).is_private(), true);\nassert_eq!(Ipv4Addr::new(172, 29, 45, 14).is_private(), true);\nassert_eq!(Ipv4Addr::new(172, 32, 0, 2).is_private(), false);\nassert_eq!(Ipv4Addr::new(192, 168, 0, 2).is_private(), true);\nassert_eq!(Ipv4Addr::new(192, 169, 0, 2).is_private(), false);"]}},{"name":"pub fn is_link_local(&self) -> bool","details":{"description":["Returns true if the address is link-local (169.254.0.0/16).","This property is defined by IETF RFC 3927."],"example":["use std::net::Ipv4Addr;\n\nassert_eq!(Ipv4Addr::new(169, 254, 0, 0).is_link_local(), true);\nassert_eq!(Ipv4Addr::new(169, 254, 10, 65).is_link_local(), true);\nassert_eq!(Ipv4Addr::new(16, 89, 10, 65).is_link_local(), false);"]}},{"name":"pub fn is_global(&self) -> bool","stability":["ðŸ”¬ This is a nightly-only experimental API.  (ip #27709)extra functionality has not been scrutinized to the level that it should be to be stable\n"]},{"name":"pub fn is_multicast(&self) -> bool","details":{"description":["Returns true if this is a multicast address (224.0.0.0/4).","Multicast addresses have a most significant octet between 224 and 239, and is defined by IETF RFC 5771."],"example":["use std::net::Ipv4Addr;\n\nassert_eq!(Ipv4Addr::new(224, 254, 0, 0).is_multicast(), true);\nassert_eq!(Ipv4Addr::new(236, 168, 10, 65).is_multicast(), true);\nassert_eq!(Ipv4Addr::new(172, 16, 10, 65).is_multicast(), false);"]}},{"name":"pub fn is_broadcast(&self) -> bool","details":{"description":["Returns true if this is a broadcast address (255.255.255.255).","A broadcast address has all octets set to 255 as defined in IETF RFC 919."],"example":["use std::net::Ipv4Addr;\n\nassert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_broadcast(), true);\nassert_eq!(Ipv4Addr::new(236, 168, 10, 65).is_broadcast(), false);"]}},{"name":"pub fn is_documentation(&self) -> bool","details":{"description":["Returns true if this address is in a range designated for documentation.","This is defined in IETF RFC 5737:","192.0.2.0/24 (TEST-NET-1) 198.51.100.0/24 (TEST-NET-2) 203.0.113.0/24 (TEST-NET-3)"],"example":["use std::net::Ipv4Addr;\n\nassert_eq!(Ipv4Addr::new(192, 0, 2, 255).is_documentation(), true);\nassert_eq!(Ipv4Addr::new(198, 51, 100, 65).is_documentation(), true);\nassert_eq!(Ipv4Addr::new(203, 0, 113, 6).is_documentation(), true);\nassert_eq!(Ipv4Addr::new(193, 34, 17, 19).is_documentation(), false);"]}},{"name":"pub fn to_ipv6_compatible(&self) -> Ipv6Addr","details":{"description":["Converts this address to an IPv4-compatible IPv6 address.","a.b.c.d becomes ::a.b.c.d"],"example":["use std::net::{Ipv4Addr, Ipv6Addr};\n\nassert_eq!(Ipv4Addr::new(192, 0, 2, 255).to_ipv6_compatible(),\n           Ipv6Addr::new(0, 0, 0, 0, 0, 0, 49152, 767));"]}},{"name":"pub fn to_ipv6_mapped(&self) -> Ipv6Addr","details":{"description":["Converts this address to an IPv4-mapped IPv6 address.","a.b.c.d becomes ::ffff:a.b.c.d"],"example":["use std::net::{Ipv4Addr, Ipv6Addr};\n\nassert_eq!(Ipv4Addr::new(192, 0, 2, 255).to_ipv6_mapped(),\n           Ipv6Addr::new(0, 0, 0, 0, 0, 65535, 49152, 767));"]}}]}