{"stability":{"stable since":"1.0.0"},"apiName":"std::collections::binary_heap::BinaryHeap","apiType":"struct","apiDocumentation":{"apiDescription":["A priority queue implemented with a binary heap.","This will be a max-heap.","It is a logic error for an item to be modified in such a way that the item's ordering relative to any other item, as determined by the Ord trait, changes while it is in the heap. This is normally only possible through Cell, RefCell, global state, I/O, or unsafe code."],"examples":["use std::collections::BinaryHeap;\n\n// Type inference lets us omit an explicit type signature (which\n// would be `BinaryHeap<i32>` in this example).\nlet mut heap = BinaryHeap::new();\n\n// We can use peek to look at the next item in the heap. In this case,\n// there's no items in there yet so we get None.\nassert_eq!(heap.peek(), None);\n\n// Let's add some scores...\nheap.push(1);\nheap.push(5);\nheap.push(2);\n\n// Now peek shows the most important item in the heap.\nassert_eq!(heap.peek(), Some(&5));\n\n// We can check the length of a heap.\nassert_eq!(heap.len(), 3);\n\n// We can iterate over the items in the heap, although they are returned in\n// a random order.\nfor x in &heap {\n    println!(\"{}\", x);\n}\n\n// If we instead pop these scores, they should come back in order.\nassert_eq!(heap.pop(), Some(5));\nassert_eq!(heap.pop(), Some(2));\nassert_eq!(heap.pop(), Some(1));\nassert_eq!(heap.pop(), None);\n\n// We can clear the heap of any remaining items.\nheap.clear();\n\n// The heap should now be empty.\nassert!(heap.is_empty())"]},"trait implementations":[{"name":"impl<'a, T> std::iter::IntoIterator for &'a std::collections::binary_heap::BinaryHeap<T> where T: std::cmp::Ord","stable since":"1.0.0"},{"name":"impl<T> std::iter::IntoIterator for std::collections::binary_heap::BinaryHeap<T> where T: std::cmp::Ord","stable since":"1.0.0"},{"name":"impl<T> std::default::Default for std::collections::binary_heap::BinaryHeap<T> where T: std::cmp::Ord","stable since":"1.0.0"},{"name":"impl<T> std::iter::FromIterator<T> for std::collections::binary_heap::BinaryHeap<T> where T: std::cmp::Ord","stable since":"1.0.0"},{"name":"impl<T> std::convert::From<std::vec::Vec<T>> for std::collections::binary_heap::BinaryHeap<T> where T: std::cmp::Ord","stable since":"1.5.0"},{"name":"impl<T> std::convert::From<std::collections::binary_heap::BinaryHeap<T>> for std::vec::Vec<T>","stable since":"1.5.0"},{"name":"impl<T> std::clone::Clone for std::collections::binary_heap::BinaryHeap<T> where T: std::clone::Clone","stable since":"1.0.0"},{"name":"impl<T> std::iter::Extend<T> for std::collections::binary_heap::BinaryHeap<T> where T: std::cmp::Ord","stable since":"1.0.0"},{"name":"impl<'a, T> std::iter::Extend<&'a T> for std::collections::binary_heap::BinaryHeap<T> where T: 'a + std::marker::Copy + std::cmp::Ord","stable since":"1.2.0"},{"name":"impl<T> std::fmt::Debug for std::collections::binary_heap::BinaryHeap<T> where T: std::cmp::Ord + std::fmt::Debug","stable since":"1.4.0"},{"name":"impl<T> std::marker::Send for std::collections::binary_heap::BinaryHeap<T> where T: std::marker::Send","stable since":"1.0.0"},{"name":"impl<T> std::marker::Sync for std::collections::binary_heap::BinaryHeap<T> where T: std::marker::Sync","stable since":"1.0.0"}],"methods":[{"name":"pub fn new() -> BinaryHeap<T>","details":{"description":["Creates an empty BinaryHeap as a max-heap."],"example":["Basic usage:","use std::collections::BinaryHeap;\nlet mut heap = BinaryHeap::new();\nheap.push(4);"]}},{"name":"pub fn with_capacity(capacity: usize) -> BinaryHeap<T>","details":{"description":["Creates an empty BinaryHeap with a specific capacity. This preallocates enough memory for capacity elements, so that the BinaryHeap does not have to be reallocated until it contains at least that many values."],"example":["Basic usage:","use std::collections::BinaryHeap;\nlet mut heap = BinaryHeap::with_capacity(10);\nheap.push(4);"]}},{"name":"pub fn iter(&self) -> Iter<T>","details":{"description":["Returns an iterator visiting all values in the underlying vector, in arbitrary order."],"example":["Basic usage:","use std::collections::BinaryHeap;\nlet heap = BinaryHeap::from(vec![1, 2, 3, 4]);\n\n// Print 1, 2, 3, 4 in arbitrary order\nfor x in heap.iter() {\n    println!(\"{}\", x);\n}"]}},{"name":"pub fn peek(&self) -> Option<&T>","details":{"description":["Returns the greatest item in the binary heap, or None if it is empty."],"example":["Basic usage:","use std::collections::BinaryHeap;\nlet mut heap = BinaryHeap::new();\nassert_eq!(heap.peek(), None);\n\nheap.push(1);\nheap.push(5);\nheap.push(2);\nassert_eq!(heap.peek(), Some(&5));\n"]}},{"name":"pub fn peek_mut(&mut self) -> Option<PeekMut<T>>","details":{"description":["Returns a mutable reference to the greatest item in the binary heap, or None if it is empty.","Note: If the PeekMut value is leaked, the heap may be in an inconsistent state."],"example":["Basic usage:","use std::collections::BinaryHeap;\nlet mut heap = BinaryHeap::new();\nassert!(heap.peek_mut().is_none());\n\nheap.push(1);\nheap.push(5);\nheap.push(2);\n{\n    let mut val = heap.peek_mut().unwrap();\n    *val = 0;\n}\nassert_eq!(heap.peek(), Some(&2));"]}},{"name":"pub fn capacity(&self) -> usize","details":{"description":["Returns the number of elements the binary heap can hold without reallocating."],"example":["Basic usage:","use std::collections::BinaryHeap;\nlet mut heap = BinaryHeap::with_capacity(100);\nassert!(heap.capacity() >= 100);\nheap.push(4);"]}},{"name":"pub fn reserve_exact(&mut self, additional: usize)","details":{"description":["Reserves the minimum capacity for exactly additional more elements to be inserted in the given BinaryHeap. Does nothing if the capacity is already sufficient.","Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer reserve if future insertions are expected.","Panics","Panics if the new capacity overflows usize."],"example":["Basic usage:","use std::collections::BinaryHeap;\nlet mut heap = BinaryHeap::new();\nheap.reserve_exact(100);\nassert!(heap.capacity() >= 100);\nheap.push(4);"]}},{"name":"pub fn reserve(&mut self, additional: usize)","details":{"description":["Reserves capacity for at least additional more elements to be inserted in the BinaryHeap. The collection may reserve more space to avoid frequent reallocations.","Panics","Panics if the new capacity overflows usize."],"example":["Basic usage:","use std::collections::BinaryHeap;\nlet mut heap = BinaryHeap::new();\nheap.reserve(100);\nassert!(heap.capacity() >= 100);\nheap.push(4);"]}},{"name":"pub fn shrink_to_fit(&mut self)","details":{"description":["Discards as much additional capacity as possible."],"example":["Basic usage:","use std::collections::BinaryHeap;\nlet mut heap: BinaryHeap<i32> = BinaryHeap::with_capacity(100);\n\nassert!(heap.capacity() >= 100);\nheap.shrink_to_fit();\nassert!(heap.capacity() == 0);"]}},{"name":"pub fn shrink_to(&mut self, min_capacity: usize)","stability":["ðŸ”¬ This is a nightly-only experimental API.  (shrink_to)new API\n"]},{"name":"pub fn pop(&mut self) -> Option<T>","details":{"description":["Removes the greatest item from the binary heap and returns it, or None if it is empty."],"example":["Basic usage:","use std::collections::BinaryHeap;\nlet mut heap = BinaryHeap::from(vec![1, 3]);\n\nassert_eq!(heap.pop(), Some(3));\nassert_eq!(heap.pop(), Some(1));\nassert_eq!(heap.pop(), None);"]}},{"name":"pub fn push(&mut self, item: T)","details":{"description":["Pushes an item onto the binary heap."],"example":["Basic usage:","use std::collections::BinaryHeap;\nlet mut heap = BinaryHeap::new();\nheap.push(3);\nheap.push(5);\nheap.push(1);\n\nassert_eq!(heap.len(), 3);\nassert_eq!(heap.peek(), Some(&5));"]}},{"name":"pub fn into_vec(self) -> Vec<T>","details":{"description":["Consumes the BinaryHeap and returns the underlying vector in arbitrary order."],"example":["Basic usage:","use std::collections::BinaryHeap;\nlet heap = BinaryHeap::from(vec![1, 2, 3, 4, 5, 6, 7]);\nlet vec = heap.into_vec();\n\n// Will print in some order\nfor x in vec {\n    println!(\"{}\", x);\n}"]}},{"name":"pub fn into_sorted_vec(self) -> Vec<T>","details":{"description":["Consumes the BinaryHeap and returns a vector in sorted (ascending) order."],"example":["Basic usage:","use std::collections::BinaryHeap;\n\nlet mut heap = BinaryHeap::from(vec![1, 2, 4, 5, 7]);\nheap.push(6);\nheap.push(3);\n\nlet vec = heap.into_sorted_vec();\nassert_eq!(vec, [1, 2, 3, 4, 5, 6, 7]);"]}},{"name":"pub fn len(&self) -> usize","details":{"description":["Returns the length of the binary heap."],"example":["Basic usage:","use std::collections::BinaryHeap;\nlet heap = BinaryHeap::from(vec![1, 3]);\n\nassert_eq!(heap.len(), 2);"]}},{"name":"pub fn is_empty(&self) -> bool","details":{"description":["Checks if the binary heap is empty."],"example":["Basic usage:","use std::collections::BinaryHeap;\nlet mut heap = BinaryHeap::new();\n\nassert!(heap.is_empty());\n\nheap.push(3);\nheap.push(5);\nheap.push(1);\n\nassert!(!heap.is_empty());"]}},{"name":"pub fn drain(&mut self) -> Drain<T>","details":{"description":["Clears the binary heap, returning an iterator over the removed elements.","The elements are removed in arbitrary order."],"example":["Basic usage:","use std::collections::BinaryHeap;\nlet mut heap = BinaryHeap::from(vec![1, 3]);\n\nassert!(!heap.is_empty());\n\nfor x in heap.drain() {\n    println!(\"{}\", x);\n}\n\nassert!(heap.is_empty());"]}},{"name":"pub fn clear(&mut self)","details":{"description":["Drops all items from the binary heap."],"example":["Basic usage:","use std::collections::BinaryHeap;\nlet mut heap = BinaryHeap::from(vec![1, 3]);\n\nassert!(!heap.is_empty());\n\nheap.clear();\n\nassert!(heap.is_empty());"]}},{"name":"pub fn append(&mut self, other: &mut BinaryHeap<T>)","details":{"description":["Moves all the elements of other into self, leaving other empty."],"example":["Basic usage:","use std::collections::BinaryHeap;\n\nlet v = vec![-10, 1, 2, 3, 3];\nlet mut a = BinaryHeap::from(v);\n\nlet v = vec![-20, 5, 43];\nlet mut b = BinaryHeap::from(v);\n\na.append(&mut b);\n\nassert_eq!(a.into_sorted_vec(), [-20, -10, 1, 2, 3, 3, 5, 43]);\nassert!(b.is_empty());"]}}]}