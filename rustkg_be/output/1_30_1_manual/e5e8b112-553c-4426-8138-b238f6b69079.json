{"stability":{"stable since":"1.0.0"},"apiName":"std::sync::Mutex","apiType":"struct","apiDocumentation":{"apiDescription":["A mutual exclusion primitive useful for protecting shared data","This mutex will block threads waiting for the lock to become available. The mutex can also be statically initialized or created via a new constructor. Each mutex has a type parameter which represents the data that it is protecting. The data can only be accessed through the RAII guards returned from lock and try_lock, which guarantees that the data is only ever accessed when the mutex is locked.","Poisoning","The mutexes in this module implement a strategy called \"poisoning\" where a mutex is considered poisoned whenever a thread panics while holding the mutex. Once a mutex is poisoned, all other threads are unable to access the data by default as it is likely tainted (some invariant is not being upheld).","For a mutex, this means that the lock and try_lock methods return a Result which indicates whether a mutex has been poisoned or not. Most usage of a mutex will simply unwrap() these results, propagating panics among threads to ensure that a possibly invalid invariant is not witnessed.","A poisoned mutex, however, does not prevent all access to the underlying data. The PoisonError type has an into_inner method which will return the guard that would have otherwise been returned on a successful lock. This allows access to the data, despite the lock being poisoned."],"examples":["use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::sync::mpsc::channel;\n\nconst N: usize = 10;\n\n// Spawn a few threads to increment a shared variable (non-atomically), and\n// let the main thread know once all increments are done.\n//\n// Here we're using an Arc to share memory among threads, and the data inside\n// the Arc is protected with a mutex.\nlet data = Arc::new(Mutex::new(0));\n\nlet (tx, rx) = channel();\nfor _ in 0..N {\n    let (data, tx) = (data.clone(), tx.clone());\n    thread::spawn(move || {\n        // The shared state can only be accessed once the lock is held.\n        // Our non-atomic increment is safe because we're the only thread\n        // which can access the shared state when the lock is held.\n        //\n        // We unwrap() the return value to assert that we are not expecting\n        // threads to ever fail while holding the lock.\n        let mut data = data.lock().unwrap();\n        *data += 1;\n        if *data == N {\n            tx.send(()).unwrap();\n        }\n        // the lock is unlocked here when `data` goes out of scope.\n    });\n}\n\nrx.recv().unwrap();","To recover from a poisoned mutex:","use std::sync::{Arc, Mutex};\nuse std::thread;\n\nlet lock = Arc::new(Mutex::new(0_u32));\nlet lock2 = lock.clone();\n\nlet _ = thread::spawn(move || -> () {\n    // This thread will acquire the mutex first, unwrapping the result of\n    // `lock` because the lock has not been poisoned.\n    let _guard = lock2.lock().unwrap();\n\n    // This panic while holding the lock (`_guard` is in scope) will poison\n    // the mutex.\n    panic!();\n}).join();\n\n// The lock is poisoned by this point, but the returned result can be\n// pattern matched on to return the underlying guard on both branches.\nlet mut guard = match lock.lock() {\n    Ok(guard) => guard,\n    Err(poisoned) => poisoned.into_inner(),\n};\n\n*guard += 1;"]},"trait implementations":[{"name":"impl<T: ?std::marker::Sized> std::panic::UnwindSafe for std::sync::Mutex<T>","stable since":"1.9.0"},{"name":"impl<T: ?std::marker::Sized> std::panic::RefUnwindSafe for std::sync::Mutex<T>","stable since":"1.12.0"},{"name":"impl<T: ?std::marker::Sized + std::marker::Send> std::marker::Send for std::sync::Mutex<T>","stable since":"1.0.0"},{"name":"impl<T: ?std::marker::Sized + std::marker::Send> std::marker::Sync for std::sync::Mutex<T>","stable since":"1.0.0"},{"name":"impl<T: ?std::marker::Sized> std::ops::Drop for std::sync::Mutex<T>","stable since":"1.0.0"},{"name":"impl<T> std::convert::From<T> for std::sync::Mutex<T>","stable since":"1.24.0"},{"name":"impl<T: ?std::marker::Sized + std::default::Default> std::default::Default for std::sync::Mutex<T>","stable since":"1.10.0"},{"name":"impl<T: ?std::marker::Sized + std::fmt::Debug> std::fmt::Debug for std::sync::Mutex<T>","stable since":"1.0.0"}],"methods":[{"name":"pub fn new(t: T) -> Mutex<T>","details":{"description":["Creates a new mutex in an unlocked state ready for use."],"example":["use std::sync::Mutex;\n\nlet mutex = Mutex::new(0);"]}},{"name":"pub fn lock(&self) -> LockResult<MutexGuard<T>>","details":{"description":["Acquires a mutex, blocking the current thread until it is able to do so.","This function will block the local thread until it is available to acquire the mutex. Upon returning, the thread is the only thread with the lock held. An RAII guard is returned to allow scoped unlock of the lock. When the guard goes out of scope, the mutex will be unlocked.","The exact behavior on locking a mutex in the thread which already holds the lock is left unspecified. However, this function will not return on the second call (it might panic or deadlock, for example).","Errors","If another user of this mutex panicked while holding the mutex, then this call will return an error once the mutex is acquired.","Panics","This function might panic when called if the lock is already held by the current thread."],"example":["use std::sync::{Arc, Mutex};\nuse std::thread;\n\nlet mutex = Arc::new(Mutex::new(0));\nlet c_mutex = mutex.clone();\n\nthread::spawn(move || {\n    *c_mutex.lock().unwrap() = 10;\n}).join().expect(\"thread::spawn failed\");\nassert_eq!(*mutex.lock().unwrap(), 10);"]}},{"name":"pub fn try_lock(&self) -> TryLockResult<MutexGuard<T>>","details":{"description":["Attempts to acquire this lock.","If the lock could not be acquired at this time, then Err is returned. Otherwise, an RAII guard is returned. The lock will be unlocked when the guard is dropped.","This function does not block.","Errors","If another user of this mutex panicked while holding the mutex, then this call will return failure if the mutex would otherwise be acquired."],"example":["use std::sync::{Arc, Mutex};\nuse std::thread;\n\nlet mutex = Arc::new(Mutex::new(0));\nlet c_mutex = mutex.clone();\n\nthread::spawn(move || {\n    let mut lock = c_mutex.try_lock();\n    if let Ok(ref mut mutex) = lock {\n        **mutex = 10;\n    } else {\n        println!(\"try_lock failed\");\n    }\n}).join().expect(\"thread::spawn failed\");\nassert_eq!(*mutex.lock().unwrap(), 10);"]}},{"name":"pub fn is_poisoned(&self) -> bool","details":{"description":["Determines whether the mutex is poisoned.","If another thread is active, the mutex can still become poisoned at any time. You should not trust a false value for program correctness without additional synchronization."],"example":["use std::sync::{Arc, Mutex};\nuse std::thread;\n\nlet mutex = Arc::new(Mutex::new(0));\nlet c_mutex = mutex.clone();\n\nlet _ = thread::spawn(move || {\n    let _lock = c_mutex.lock().unwrap();\n    panic!(); // the mutex gets poisoned\n}).join();\nassert_eq!(mutex.is_poisoned(), true);"]}},{"name":"pub fn into_inner(self) -> LockResult<T> where T: Sized","details":{"description":["Consumes this mutex, returning the underlying data.","Errors","If another user of this mutex panicked while holding the mutex, then this call will return an error instead."],"example":["use std::sync::Mutex;\n\nlet mutex = Mutex::new(0);\nassert_eq!(mutex.into_inner().unwrap(), 0);"]}},{"name":"pub fn get_mut(&mut self) -> LockResult<&mut T>","details":{"description":["Returns a mutable reference to the underlying data.","Since this call borrows the Mutex mutably, no actual locking needs to take place---the mutable borrow statically guarantees no locks exist.","Errors","If another user of this mutex panicked while holding the mutex, then this call will return an error instead."],"example":["use std::sync::Mutex;\n\nlet mut mutex = Mutex::new(0);\n*mutex.get_mut().unwrap() = 10;\nassert_eq!(*mutex.lock().unwrap(), 10);"]}}]}