{"stability":{"stable since":"1.0.0"},"apiName":"std::sync::atomic::Ordering","apiType":"enum","apiDocumentation":{"apiDescription":["Atomic memory orderings","Memory orderings limit the ways that both the compiler and CPU may reorder instructions around atomic operations. At its most restrictive, \"sequentially consistent\" atomics allow neither reads nor writes to be moved either before or after the atomic operation; on the other end \"relaxed\" atomics allow all reorderings.","Rust's memory orderings are the same as LLVM's.","For more information see the nomicon."]},"enum variants":["Non-exhaustive enums could have additional variants added in future. Therefore, when matching against variants of non-exhaustive enums, an extra wildcard arm must be added to account for any future variants.","Relaxed","No ordering constraints, only atomic operations.\nCorresponds to LLVM's Monotonic ordering.\n","Release","When coupled with a store, all previous operations become ordered\nbefore any load of this value with Acquire (or stronger) ordering.\nIn particular, all previous writes become visible to all threads\nthat perform an Acquire (or stronger) load of this value.\nNotice that using this ordering for an operation that combines loads\nand stores leads to a Relaxed load operation!\nThis ordering is only applicable for operations that can perform a store.\nCorresponds to LLVM's Release ordering.\n","Acquire","When coupled with a load, if the loaded value was written by a store operation with\nRelease (or stronger) ordering, then all subsequent operations\nbecome ordered after that store. In particular, all subsequent loads will see data\nwritten before the store.\nNotice that using this ordering for an operation that combines loads\nand stores leads to a Relaxed store operation!\nThis ordering is only applicable for operations that can perform a load.\nCorresponds to LLVM's Acquire ordering.\n","AcqRel","Has the effects of both Acquire and Release together:\nFor loads it uses Acquire ordering. For stores it uses the Release ordering.\nNotice that in the case of compare_and_swap, it is possible that the operation ends up\nnot performing any store and hence it has just Acquire ordering. However,\nAcqRel will never perform Relaxed accesses.\nThis ordering is only applicable for operations that combine both loads and stores.\nCorresponds to LLVM's AcquireRelease ordering.\n","SeqCst","Like Acquire/Release/AcqRel (for load, store, and load-with-store\noperations, respectively) with the additional guarantee that all threads see all\nsequentially consistent operations in the same order.\nCorresponds to LLVM's SequentiallyConsistent ordering.\n"],"trait implementations":[{"name":"impl std::clone::Clone for std::sync::atomic::Ordering","stable since":"1.0.0"},{"name":"impl std::fmt::Debug for std::sync::atomic::Ordering","stable since":"1.0.0"},{"name":"impl std::marker::Copy for std::sync::atomic::Ordering","stable since":"1.0.0"},{"name":"impl std::marker::Send for std::sync::atomic::Ordering","stable since":"1.0.0"},{"name":"impl std::marker::Sync for std::sync::atomic::Ordering","stable since":"1.0.0"}]}