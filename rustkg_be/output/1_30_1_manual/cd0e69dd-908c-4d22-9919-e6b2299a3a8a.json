{"stability":{"stable since":"1.0.0"},"apiName":"std::string::String","apiType":"struct","apiDocumentation":{"apiDescription":["A UTF-8 encoded, growable string.","The String type is the most common string type that has ownership over the contents of the string. It has a close relationship with its borrowed counterpart, the primitive str.","Strings are always valid UTF-8. This has a few implications, the first of which is that if you need a non-UTF-8 string, consider OsString. It is similar, but without the UTF-8 constraint. The second implication is that you cannot index into a String:","ⓘThis example deliberately fails to compile","let s = \"hello\"; println!(\"The first letter of s is {}\", s[0]); // ERROR!!!","Indexing is intended to be a constant-time operation, but UTF-8 encoding does not allow us to do this. Furthermore, it's not clear what sort of thing the index should return: a byte, a codepoint, or a grapheme cluster. The bytes and chars methods return iterators over the first two, respectively.","Deref","Strings implement Deref<Target=str>, and so inherit all of str's methods. In addition, this means that you can pass a String to a function which takes a &str by using an ampersand (&):","fn takes_str(s: &str) { } let s = String::from(\"Hello\"); takes_str(&s);","This will create a &str from the String and pass it in. This conversion is very inexpensive, and so generally, functions will accept &strs as arguments unless they need a String for some specific reason.","In certain cases Rust doesn't have enough information to make this conversion, known as Deref coercion. In the following example a string slice &'a str implements the trait TraitExample, and the function example_func takes anything that implements the trait. In this case Rust would need to make two implicit conversions, which Rust doesn't have the means to do. For that reason, the following example will not compile.","ⓘThis example deliberately fails to compile","trait TraitExample {} impl<'a> TraitExample for &'a str {} fn example_func<A: TraitExample>(example_arg: A) {} fn main() { let example_string = String::from(\"example_string\"); example_func(&example_string); }","There are two options that would work instead. The first would be to change the line example_func(&example_string); to example_func(example_string.as_str());, using the method as_str() to explicitly extract the string slice containing the string. The second way changes example_func(&example_string); to example_func(&*example_string);. In this case we are dereferencing a String to a str, then referencing the str back to &str. The second way is more idiomatic, however both work to do the conversion explicitly rather than relying on the implicit conversion.","Representation","A String is made up of three components: a pointer to some bytes, a length, and a capacity. The pointer points to an internal buffer String uses to store its data. The length is the number of bytes currently stored in the buffer, and the capacity is the size of the buffer in bytes. As such, the length will always be less than or equal to the capacity.","This buffer is always stored on the heap.","You can look at these with the as_ptr, len, and capacity methods:","use std::mem; let story = String::from(\"Once upon a time...\"); let ptr = story.as_ptr(); let len = story.len(); let capacity = story.capacity(); // story has nineteen bytes assert_eq!(19, len); // Now that we have our parts, we throw the story away. mem::forget(story); // We can re-build a String out of ptr, len, and capacity. This is all // unsafe because we are responsible for making sure the components are // valid: let s = unsafe { String::from_raw_parts(ptr as *mut _, len, capacity) } ; assert_eq!(String::from(\"Once upon a time...\"), s);","If a String has enough capacity, adding elements to it will not re-allocate. For example, consider this program:","let mut s = String::new(); println!(\"{}\", s.capacity()); for _ in 0..5 { s.push_str(\"hello\"); println!(\"{}\", s.capacity()); }","This will output the following:","0 5 10 20 20 40","At first, we have no memory allocated at all, but as we append to the string, it increases its capacity appropriately. If we instead use the with_capacity method to allocate the correct capacity initially:","let mut s = String::with_capacity(25); println!(\"{}\", s.capacity()); for _ in 0..5 { s.push_str(\"hello\"); println!(\"{}\", s.capacity()); }","We end up with a different output:","25 25 25 25 25 25","Here, there's no need to allocate more memory inside the loop."],"examples":["You can create a String from a literal string with String::from:","let hello = String::from(\"Hello, world!\");","You can append a char to a String with the push method, and\nappend a &str with the push_str method:","let mut hello = String::from(\"Hello, \");\n\nhello.push('w');\nhello.push_str(\"orld!\");","If you have a vector of UTF-8 bytes, you can create a String from it with\nthe from_utf8 method:","// some bytes, in a vector\nlet sparkle_heart = vec![240, 159, 146, 150];\n\n// We know these bytes are valid, so we'll use `unwrap()`.\nlet sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\n\nassert_eq!(\"💖\", sparkle_heart);"]},"trait implementations":[{"name":"impl<'a> std::ops::Add<&'a str> for std::string::String","stable since":"1.0.0"},{"name":"impl std::fmt::Write for std::string::String","stable since":"1.0.0"},{"name":"impl std::cmp::PartialOrd<std::string::String> for std::string::String","stable since":"1.0.0"},{"name":"impl std::convert::AsRef<str> for std::string::String","stable since":"1.0.0"},{"name":"impl std::convert::AsRef<[u8]> for std::string::String","stable since":"1.0.0"},{"name":"impl std::str::FromStr for std::string::String","stable since":"1.0.0"},{"name":"impl std::cmp::Eq for std::string::String","stable since":"1.0.0"},{"name":"impl std::ops::IndexMut<std::ops::Range<usize>> for std::string::String","stable since":"1.3.0"},{"name":"impl std::ops::IndexMut<std::ops::RangeFull> for std::string::String","stable since":"1.3.0"},{"name":"impl std::ops::IndexMut<std::ops::RangeTo<usize>> for std::string::String","stable since":"1.3.0"},{"name":"impl std::ops::IndexMut<std::ops::RangeInclusive<usize>> for std::string::String","stable since":"1.26.0"},{"name":"impl std::ops::IndexMut<std::ops::RangeFrom<usize>> for std::string::String","stable since":"1.3.0"},{"name":"impl std::ops::IndexMut<std::ops::RangeToInclusive<usize>> for std::string::String","stable since":"1.26.0"},{"name":"impl std::ops::Deref for std::string::String","stable since":"1.0.0"},{"name":"impl std::borrow::Borrow<str> for std::string::String","stable since":"1.0.0"},{"name":"impl std::ops::DerefMut for std::string::String","stable since":"1.3.0"},{"name":"impl std::default::Default for std::string::String","stable since":"1.0.0"},{"name":"impl<'a> std::iter::FromIterator<&'a char> for std::string::String","stable since":"1.17.0"},{"name":"impl<'a> std::iter::FromIterator<std::string::String> for std::borrow::Cow<'a, str>","stable since":"1.12.0"},{"name":"impl std::iter::FromIterator<std::string::String> for std::string::String","stable since":"1.4.0"},{"name":"impl<'a> std::iter::FromIterator<std::borrow::Cow<'a, str>> for std::string::String","stable since":"1.19.0"},{"name":"impl std::iter::FromIterator<char> for std::string::String","stable since":"1.0.0"},{"name":"impl<'a> std::iter::FromIterator<&'a str> for std::string::String","stable since":"1.0.0"},{"name":"impl std::fmt::Display for std::string::String","stable since":"1.0.0"},{"name":"impl std::convert::From<std::string::String> for std::boxed::Box<str>","stable since":"1.20.0"},{"name":"impl std::convert::From<std::string::String> for std::sync::Arc<str>","stable since":"1.21.0"},{"name":"impl std::convert::From<std::boxed::Box<str>> for std::string::String","stable since":"1.18.0"},{"name":"impl<'a> std::convert::From<&'a std::string::String> for std::borrow::Cow<'a, str>","stable since":"1.28.0"},{"name":"impl std::convert::From<std::string::String> for std::rc::Rc<str>","stable since":"1.21.0"},{"name":"impl<'a> std::convert::From<std::borrow::Cow<'a, str>> for std::string::String","stable since":"1.14.0"},{"name":"impl std::convert::From<std::string::String> for std::vec::Vec<u8>","stable since":"1.14.0"},{"name":"impl<'a> std::convert::From<&'a str> for std::string::String","stable since":"1.0.0"},{"name":"impl<'a> std::convert::From<std::string::String> for std::borrow::Cow<'a, str>","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::str::pattern::Pattern<'a> for &'b std::string::String","stable since":"1.0.0"},{"name":"impl std::string::ToString for std::string::String","stable since":"1.17.0"},{"name":"impl std::clone::Clone for std::string::String","stable since":"1.0.0"},{"name":"impl<'a> std::iter::Extend<&'a char> for std::string::String","stable since":"1.2.0"},{"name":"impl std::iter::Extend<std::string::String> for std::string::String","stable since":"1.4.0"},{"name":"impl<'a> std::iter::Extend<std::borrow::Cow<'a, str>> for std::string::String","stable since":"1.19.0"},{"name":"impl std::iter::Extend<char> for std::string::String","stable since":"1.0.0"},{"name":"impl<'a> std::iter::Extend<&'a str> for std::string::String","stable since":"1.0.0"},{"name":"impl<'a> std::ops::AddAssign<&'a str> for std::string::String","stable since":"1.12.0"},{"name":"impl std::hash::Hash for std::string::String","stable since":"1.0.0"},{"name":"impl std::fmt::Debug for std::string::String","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<&'a str> for std::string::String","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<std::string::String> for std::borrow::Cow<'a, str>","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<std::string::String> for str","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<std::string::String> for &'a str","stable since":"1.0.0"},{"name":"impl std::cmp::PartialEq<std::string::String> for std::string::String","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<std::borrow::Cow<'a, str>> for std::string::String","stable since":"1.0.0"},{"name":"impl<'a, 'b> std::cmp::PartialEq<str> for std::string::String","stable since":"1.0.0"},{"name":"impl std::cmp::Ord for std::string::String","stable since":"1.0.0"},{"name":"impl std::ops::Index<std::ops::Range<usize>> for std::string::String","stable since":"1.0.0"},{"name":"impl std::ops::Index<std::ops::RangeInclusive<usize>> for std::string::String","stable since":"1.26.0"},{"name":"impl std::ops::Index<std::ops::RangeToInclusive<usize>> for std::string::String","stable since":"1.26.0"},{"name":"impl std::ops::Index<std::ops::RangeFrom<usize>> for std::string::String","stable since":"1.0.0"},{"name":"impl std::ops::Index<std::ops::RangeTo<usize>> for std::string::String","stable since":"1.0.0"},{"name":"impl std::ops::Index<std::ops::RangeFull> for std::string::String","stable since":"1.0.0"},{"name":"impl std::convert::From<std::string::String> for std::boxed::Box<std::error::Error + std::marker::Send + std::marker::Sync>","stable since":"1.0.0"},{"name":"impl std::convert::From<std::string::String> for std::boxed::Box<std::error::Error>","stable since":"1.6.0"},{"name":"impl std::convert::From<std::string::String> for std::ffi::OsString","stable since":"1.0.0"},{"name":"impl std::convert::AsRef<std::ffi::OsStr> for std::string::String","stable since":"1.0.0"},{"name":"impl std::net::ToSocketAddrs for std::string::String","stable since":"1.16.0"},{"name":"impl std::convert::From<std::string::String> for std::path::PathBuf","stable since":"1.0.0"},{"name":"impl std::convert::AsRef<std::path::Path> for std::string::String","stable since":"1.0.0"},{"name":"impl std::marker::Send for std::string::String","stable since":"1.0.0"},{"name":"impl std::marker::Sync for std::string::String","stable since":"1.0.0"}],"methods":[{"name":"pub const fn new() -> String","details":{"description":["Creates a new empty String.","Given that the String is empty, this will not allocate any initial buffer. While that means that this initial operation is very inexpensive, it may cause excessive allocation later when you add data. If you have an idea of how much data the String will hold, consider the with_capacity method to prevent excessive re-allocation."],"example":["Basic usage:","let s = String::new();"]}},{"name":"pub fn with_capacity(capacity: usize) -> String","details":{"description":["Creates a new empty String with a particular capacity.","Strings have an internal buffer to hold their data. The capacity is the length of that buffer, and can be queried with the capacity method. This method creates an empty String, but one with an initial buffer that can hold capacity bytes. This is useful when you may be appending a bunch of data to the String, reducing the number of reallocations it needs to do.","If the given capacity is 0, no allocation will occur, and this method is identical to the new method."],"example":["Basic usage:","let mut s = String::with_capacity(10);\n\n// The String contains no chars, even though it has capacity for more\nassert_eq!(s.len(), 0);\n\n// These are all done without reallocating...\nlet cap = s.capacity();\nfor i in 0..10 {\n    s.push('a');\n}\n\nassert_eq!(s.capacity(), cap);\n\n// ...but this may make the vector reallocate\ns.push('a');"]}},{"name":"pub fn from_utf8(vec: Vec<u8>) -> Result<String, FromUtf8Error>","details":{"description":["Converts a vector of bytes to a String.","A string slice (&str) is made of bytes (u8), and a vector of bytes (Vec<u8>) is made of bytes, so this function converts between the two. Not all byte slices are valid Strings, however: String requires that it is valid UTF-8. from_utf8() checks to ensure that the bytes are valid UTF-8, and then does the conversion.","If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the validity check, there is an unsafe version of this function, from_utf8_unchecked, which has the same behavior but skips the check.","This method will take care to not copy the vector, for efficiency's sake.","If you need a &str instead of a String, consider str::from_utf8.","The inverse of this method is as_bytes.","Errors","Returns Err if the slice is not UTF-8 with a description as to why the provided bytes are not UTF-8. The vector you moved in is also included."],"example":["Basic usage:","// some bytes, in a vector\nlet sparkle_heart = vec![240, 159, 146, 150];\n\n// We know these bytes are valid, so we'll use `unwrap()`.\nlet sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\n\nassert_eq!(\"💖\", sparkle_heart);","Incorrect bytes:","// some invalid bytes, in a vector\nlet sparkle_heart = vec![0, 159, 146, 150];\n\nassert!(String::from_utf8(sparkle_heart).is_err());","See the docs for FromUtf8Error for more details on what you can do\nwith this error."]}},{"name":"pub fn from_utf8_lossy(v: &'a [u8]) -> Cow<'a, str>","details":{"description":["Converts a slice of bytes to a string, including invalid characters.","Strings are made of bytes (u8), and a slice of bytes (&[u8]) is made of bytes, so this function converts between the two. Not all byte slices are valid strings, however: strings are required to be valid UTF-8. During this conversion, from_utf8_lossy() will replace any invalid UTF-8 sequences with U+FFFD REPLACEMENT CHARACTER, which looks like this: �","If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the conversion, there is an unsafe version of this function, from_utf8_unchecked, which has the same behavior but skips the checks.","This function returns a Cow<'a, str>. If our byte slice is invalid UTF-8, then we need to insert the replacement characters, which will change the size of the string, and hence, require a String. But if it's already valid UTF-8, we don't need a new allocation. This return type allows us to handle both cases."],"example":["Basic usage:","// some bytes, in a vector\nlet sparkle_heart = vec![240, 159, 146, 150];\n\nlet sparkle_heart = String::from_utf8_lossy(&sparkle_heart);\n\nassert_eq!(\"💖\", sparkle_heart);","Incorrect bytes:","// some invalid bytes\nlet input = b\"Hello \\xF0\\x90\\x80World\";\nlet output = String::from_utf8_lossy(input);\n\nassert_eq!(\"Hello �World\", output);"]}},{"name":"pub fn from_utf16(v: &[u16]) -> Result<String, FromUtf16Error>","details":{"description":["Decode a UTF-16 encoded vector v into a String, returning Err if v contains any invalid data."],"example":["Basic usage:","// 𝄞music\nlet v = &[0xD834, 0xDD1E, 0x006d, 0x0075,\n          0x0073, 0x0069, 0x0063];\nassert_eq!(String::from(\"𝄞music\"),\n           String::from_utf16(v).unwrap());\n\n// 𝄞mu<invalid>ic\nlet v = &[0xD834, 0xDD1E, 0x006d, 0x0075,\n          0xD800, 0x0069, 0x0063];\nassert!(String::from_utf16(v).is_err());"]}},{"name":"pub fn from_utf16_lossy(v: &[u16]) -> String","details":{"description":["Decode a UTF-16 encoded slice v into a String, replacing invalid data with the replacement character (U+FFFD).","Unlike from_utf8_lossy which returns a Cow<'a, str>, from_utf16_lossy returns a String since the UTF-16 to UTF-8 conversion requires a memory allocation."],"example":["Basic usage:","// 𝄞mus<invalid>ic<invalid>\nlet v = &[0xD834, 0xDD1E, 0x006d, 0x0075,\n          0x0073, 0xDD1E, 0x0069, 0x0063,\n          0xD834];\n\nassert_eq!(String::from(\"𝄞mus\\u{FFFD}ic\\u{FFFD}\"),\n           String::from_utf16_lossy(v));"]}},{"name":"pub unsafe fn from_raw_parts( buf: *mut u8, length: usize, capacity: usize) -> String","details":{"description":["Creates a new String from a length, capacity, and pointer.","Safety","This is highly unsafe, due to the number of invariants that aren't checked:","The memory at ptr needs to have been previously allocated by the same allocator the standard library uses. length needs to be less than or equal to capacity. capacity needs to be the correct value.","Violating these may cause problems like corrupting the allocator's internal data structures.","The ownership of ptr is effectively transferred to the String which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function."],"example":["Basic usage:","use std::mem;\n\nunsafe {\n    let s = String::from(\"hello\");\n    let ptr = s.as_ptr();\n    let len = s.len();\n    let capacity = s.capacity();\n\n    mem::forget(s);\n\n    let s = String::from_raw_parts(ptr as *mut _, len, capacity);\n\n    assert_eq!(String::from(\"hello\"), s);\n}"]}},{"name":"pub unsafe fn from_utf8_unchecked(bytes: Vec<u8>) -> String","details":{"description":["Converts a vector of bytes to a String without checking that the string contains valid UTF-8.","See the safe version, from_utf8, for more details.","Safety","This function is unsafe because it does not check that the bytes passed to it are valid UTF-8. If this constraint is violated, it may cause memory unsafety issues with future users of the String, as the rest of the standard library assumes that Strings are valid UTF-8."],"example":["Basic usage:","// some bytes, in a vector\nlet sparkle_heart = vec![240, 159, 146, 150];\n\nlet sparkle_heart = unsafe {\n    String::from_utf8_unchecked(sparkle_heart)\n};\n\nassert_eq!(\"💖\", sparkle_heart);"]}},{"name":"pub fn into_bytes(self) -> Vec<u8>","details":{"description":["Converts a String into a byte vector.","This consumes the String, so we do not need to copy its contents."],"example":["Basic usage:","let s = String::from(\"hello\");\nlet bytes = s.into_bytes();\n\nassert_eq!(&[104, 101, 108, 108, 111][..], &bytes[..]);"]}},{"name":"pub fn as_str(&self) -> &str","details":{"description":["Extracts a string slice containing the entire String."],"example":["Basic usage:","let s = String::from(\"foo\");\n\nassert_eq!(\"foo\", s.as_str());"]}},{"name":"pub fn as_mut_str(&mut self) -> &mut str","details":{"description":["Converts a String into a mutable string slice."],"example":["Basic usage:","let mut s = String::from(\"foobar\");\nlet s_mut_str = s.as_mut_str();\n\ns_mut_str.make_ascii_uppercase();\n\nassert_eq!(\"FOOBAR\", s_mut_str);"]}},{"name":"pub fn push_str(&mut self, string: &str)","details":{"description":["Appends a given string slice onto the end of this String."],"example":["Basic usage:","let mut s = String::from(\"foo\");\n\ns.push_str(\"bar\");\n\nassert_eq!(\"foobar\", s);"]}},{"name":"pub fn capacity(&self) -> usize","details":{"description":["Returns this String's capacity, in bytes."],"example":["Basic usage:","let s = String::with_capacity(10);\n\nassert!(s.capacity() >= 10);"]}},{"name":"pub fn reserve(&mut self, additional: usize)","details":{"description":["Ensures that this String's capacity is at least additional bytes larger than its length.","The capacity may be increased by more than additional bytes if it chooses, to prevent frequent reallocations.","If you do not want this \"at least\" behavior, see the reserve_exact method.","Panics","Panics if the new capacity overflows usize."],"example":["Basic usage:","let mut s = String::new();\n\ns.reserve(10);\n\nassert!(s.capacity() >= 10);","This may not actually increase the capacity:","let mut s = String::with_capacity(10);\ns.push('a');\ns.push('b');\n\n// s now has a length of 2 and a capacity of 10\nassert_eq!(2, s.len());\nassert_eq!(10, s.capacity());\n\n// Since we already have an extra 8 capacity, calling this...\ns.reserve(8);\n\n// ... doesn't actually increase.\nassert_eq!(10, s.capacity());"]}},{"name":"pub fn reserve_exact(&mut self, additional: usize)","details":{"description":["Ensures that this String's capacity is additional bytes larger than its length.","Consider using the reserve method unless you absolutely know better than the allocator.","Panics","Panics if the new capacity overflows usize."],"example":["Basic usage:","let mut s = String::new();\n\ns.reserve_exact(10);\n\nassert!(s.capacity() >= 10);","This may not actually increase the capacity:","let mut s = String::with_capacity(10);\ns.push('a');\ns.push('b');\n\n// s now has a length of 2 and a capacity of 10\nassert_eq!(2, s.len());\nassert_eq!(10, s.capacity());\n\n// Since we already have an extra 8 capacity, calling this...\ns.reserve_exact(8);\n\n// ... doesn't actually increase.\nassert_eq!(10, s.capacity());"]}},{"name":"pub fn try_reserve( &mut self, additional: usize) -> Result<(), CollectionAllocErr>","stability":["🔬 This is a nightly-only experimental API.  (try_reserve #48043)new API\n"]},{"name":"pub fn try_reserve_exact( &mut self, additional: usize) -> Result<(), CollectionAllocErr>","stability":["🔬 This is a nightly-only experimental API.  (try_reserve #48043)new API\n"]},{"name":"pub fn shrink_to_fit(&mut self)","details":{"description":["Shrinks the capacity of this String to match its length."],"example":["Basic usage:","let mut s = String::from(\"foo\");\n\ns.reserve(100);\nassert!(s.capacity() >= 100);\n\ns.shrink_to_fit();\nassert_eq!(3, s.capacity());"]}},{"name":"pub fn shrink_to(&mut self, min_capacity: usize)","stability":["🔬 This is a nightly-only experimental API.  (shrink_to)new API\n"]},{"name":"pub fn push(&mut self, ch: char)","details":{"description":["Appends the given char to the end of this String."],"example":["Basic usage:","let mut s = String::from(\"abc\");\n\ns.push('1');\ns.push('2');\ns.push('3');\n\nassert_eq!(\"abc123\", s);"]}},{"name":"pub fn as_bytes(&self) -> &[u8]","details":{"description":["Returns a byte slice of this String's contents.","The inverse of this method is from_utf8."],"example":["Basic usage:","let s = String::from(\"hello\");\n\nassert_eq!(&[104, 101, 108, 108, 111], s.as_bytes());"]}},{"name":"pub fn truncate(&mut self, new_len: usize)","details":{"description":["Shortens this String to the specified length.","If new_len is greater than the string's current length, this has no effect.","Note that this method has no effect on the allocated capacity of the string","Panics","Panics if new_len does not lie on a char boundary."],"example":["Basic usage:","let mut s = String::from(\"hello\");\n\ns.truncate(2);\n\nassert_eq!(\"he\", s);"]}},{"name":"pub fn pop(&mut self) -> Option<char>","details":{"description":["Removes the last character from the string buffer and returns it.","Returns None if this String is empty."],"example":["Basic usage:","let mut s = String::from(\"foo\");\n\nassert_eq!(s.pop(), Some('o'));\nassert_eq!(s.pop(), Some('o'));\nassert_eq!(s.pop(), Some('f'));\n\nassert_eq!(s.pop(), None);"]}},{"name":"pub fn remove(&mut self, idx: usize) -> char","details":{"description":["Removes a char from this String at a byte position and returns it.","This is an O(n) operation, as it requires copying every element in the buffer.","Panics","Panics if idx is larger than or equal to the String's length, or if it does not lie on a char boundary."],"example":["Basic usage:","let mut s = String::from(\"foo\");\n\nassert_eq!(s.remove(0), 'f');\nassert_eq!(s.remove(1), 'o');\nassert_eq!(s.remove(0), 'o');"]}},{"name":"pub fn retain<F>(&mut self, f: F) where F: FnMut(char) -> bool","details":{"description":["Retains only the characters specified by the predicate.","In other words, remove all characters c such that f(c) returns false. This method operates in place and preserves the order of the retained characters."],"example":["let mut s = String::from(\"f_o_ob_ar\");\n\ns.retain(|c| c != '_');\n\nassert_eq!(s, \"foobar\");"]}},{"name":"pub fn insert(&mut self, idx: usize, ch: char)","details":{"description":["Inserts a character into this String at a byte position.","This is an O(n) operation as it requires copying every element in the buffer.","Panics","Panics if idx is larger than the String's length, or if it does not lie on a char boundary."],"example":["Basic usage:","let mut s = String::with_capacity(3);\n\ns.insert(0, 'f');\ns.insert(1, 'o');\ns.insert(2, 'o');\n\nassert_eq!(\"foo\", s);"]}},{"name":"pub fn insert_str(&mut self, idx: usize, string: &str)","details":{"description":["Inserts a string slice into this String at a byte position.","This is an O(n) operation as it requires copying every element in the buffer.","Panics","Panics if idx is larger than the String's length, or if it does not lie on a char boundary."],"example":["Basic usage:","let mut s = String::from(\"bar\");\n\ns.insert_str(0, \"foo\");\n\nassert_eq!(\"foobar\", s);"]}},{"name":"pub unsafe fn as_mut_vec(&mut self) -> &mut Vec<u8>","details":{"description":["Returns a mutable reference to the contents of this String.","Safety","This function is unsafe because it does not check that the bytes passed to it are valid UTF-8. If this constraint is violated, it may cause memory unsafety issues with future users of the String, as the rest of the standard library assumes that Strings are valid UTF-8."],"example":["Basic usage:","let mut s = String::from(\"hello\");\n\nunsafe {\n    let vec = s.as_mut_vec();\n    assert_eq!(&[104, 101, 108, 108, 111][..], &vec[..]);\n\n    vec.reverse();\n}\nassert_eq!(s, \"olleh\");"]}},{"name":"pub fn len(&self) -> usize","details":{"description":["Returns the length of this String, in bytes."],"example":["Basic usage:","let a = String::from(\"foo\");\n\nassert_eq!(a.len(), 3);"]}},{"name":"pub fn is_empty(&self) -> bool","details":{"description":["Returns true if this String has a length of zero.","Returns false otherwise."],"example":["Basic usage:","let mut v = String::new();\nassert!(v.is_empty());\n\nv.push('a');\nassert!(!v.is_empty());"]}},{"name":"pub fn split_off(&mut self, at: usize) -> String","details":{"description":["Splits the string into two at the given index.","Returns a newly allocated String. self contains bytes [0, at), and the returned String contains bytes [at, len). at must be on the boundary of a UTF-8 code point.","Note that the capacity of self does not change.","Panics","Panics if at is not on a UTF-8 code point boundary, or if it is beyond the last code point of the string."],"example":["let mut hello = String::from(\"Hello, World!\");\nlet world = hello.split_off(7);\nassert_eq!(hello, \"Hello, \");\nassert_eq!(world, \"World!\");"]}},{"name":"pub fn clear(&mut self)","details":{"description":["Truncates this String, removing all contents.","While this means the String will have a length of zero, it does not touch its capacity."],"example":["Basic usage:","let mut s = String::from(\"foo\");\n\ns.clear();\n\nassert!(s.is_empty());\nassert_eq!(0, s.len());\nassert_eq!(3, s.capacity());"]}},{"name":"pub fn drain<R>(&mut self, range: R) -> Drain where R: RangeBounds<usize>","details":{"description":["Creates a draining iterator that removes the specified range in the String and yields the removed chars.","Note: The element range is removed even if the iterator is not consumed until the end.","Panics","Panics if the starting point or end point do not lie on a char boundary, or if they're out of bounds."],"example":["Basic usage:","let mut s = String::from(\"α is alpha, β is beta\");\nlet beta_offset = s.find('β').unwrap_or(s.len());\n\n// Remove the range up until the β from the string\nlet t: String = s.drain(..beta_offset).collect();\nassert_eq!(t, \"α is alpha, \");\nassert_eq!(s, \"β is beta\");\n\n// A full range clears the string\ns.drain(..);\nassert_eq!(s, \"\");"]}},{"name":"pub fn replace_range<R>(&mut self, range: R, replace_with: &str) where R: RangeBounds<usize>","details":{"description":["Removes the specified range in the string, and replaces it with the given string. The given string doesn't need to be the same length as the range.","Panics","Panics if the starting point or end point do not lie on a char boundary, or if they're out of bounds."],"example":["Basic usage:","let mut s = String::from(\"α is alpha, β is beta\");\nlet beta_offset = s.find('β').unwrap_or(s.len());\n\n// Replace the range up until the β from the string\ns.replace_range(..beta_offset, \"Α is capital alpha; \");\nassert_eq!(s, \"Α is capital alpha; β is beta\");"]}},{"name":"pub fn into_boxed_str(self) -> Box<str>","details":{"description":["Converts this String into a Box<str>.","This will drop any excess capacity."],"example":["Basic usage:","let s = String::from(\"hello\");\n\nlet b = s.into_boxed_str();"]}}]}