{"stability":{"stable since":"1.0.0"},"apiName":"std::net::TcpListener","apiType":"struct","apiDocumentation":{"apiDescription":["A TCP socket server, listening for connections.","After creating a TcpListener by binding it to a socket address, it listens for incoming TCP connections. These can be accepted by calling accept or by iterating over the Incoming iterator returned by incoming.","The socket will be closed when the value is dropped.","The Transmission Control Protocol is specified in IETF RFC 793."],"examples":["use std::net::{TcpListener, TcpStream};\n\nfn handle_client(stream: TcpStream) {\n    // ...\n}\n\nfn main() -> io::Result<()> {\n    let listener = TcpListener::bind(\"127.0.0.1:80\")?;\n\n    // accept connections and process them serially\n    for stream in listener.incoming() {\n        handle_client(stream?);\n    }\n    Ok(())\n}"]},"trait implementations":[{"name":"impl std::fmt::Debug for std::net::TcpListener","stable since":"1.0.0"},{"name":"impl std::os::windows::io::AsRawSocket for std::net::TcpListener","stable since":"1.0.0"},{"name":"impl std::os::windows::io::FromRawSocket for std::net::TcpListener","stable since":"1.1.0"},{"name":"impl std::os::windows::io::IntoRawSocket for std::net::TcpListener","stable since":"1.4.0"},{"name":"impl std::os::unix::io::AsRawFd for std::net::TcpListener","stable since":"1.0.0"},{"name":"impl std::os::unix::io::FromRawFd for std::net::TcpListener","stable since":"1.1.0"},{"name":"impl std::os::unix::io::IntoRawFd for std::net::TcpListener","stable since":"1.4.0"},{"name":"impl std::marker::Send for std::net::TcpListener","stable since":"1.0.0"},{"name":"impl std::marker::Sync for std::net::TcpListener","stable since":"1.0.0"}],"methods":[{"name":"pub fn bind<A: ToSocketAddrs>(addr: A) -> Result<TcpListener>","details":{"description":["Creates a new TcpListener which will be bound to the specified address.","The returned listener is ready for accepting connections.","Binding with a port number of 0 will request that the OS assigns a port to this listener. The port allocated can be queried via the local_addr method.","The address type can be any implementor of ToSocketAddrs trait. See its documentation for concrete examples.","If addr yields multiple addresses, bind will be attempted with each of the addresses until one succeeds and returns the listener. If none of the addresses succeed in creating a listener, the error returned from the last attempt (the last address) is returned."],"example":["Create a TCP listener bound to 127.0.0.1:80:","use std::net::TcpListener;\n\nlet listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();","Create a TCP listener bound to 127.0.0.1:80. If that fails, create a\nTCP listener bound to 127.0.0.1:443:","use std::net::{SocketAddr, TcpListener};\n\nlet addrs = [\n    SocketAddr::from(([127, 0, 0, 1], 80)),\n    SocketAddr::from(([127, 0, 0, 1], 443)),\n];\nlet listener = TcpListener::bind(&addrs[..]).unwrap();"]}},{"name":"pub fn local_addr(&self) -> Result<SocketAddr>","details":{"description":["Returns the local socket address of this listener."],"example":["use std::net::{Ipv4Addr, SocketAddr, SocketAddrV4, TcpListener};\n\nlet listener = TcpListener::bind(\"127.0.0.1:8080\").unwrap();\nassert_eq!(listener.local_addr().unwrap(),\n           SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080)));"]}},{"name":"pub fn try_clone(&self) -> Result<TcpListener>","details":{"description":["Creates a new independently owned handle to the underlying socket.","The returned TcpListener is a reference to the same socket that this object references. Both handles can be used to accept incoming connections and options set on one listener will affect the other."],"example":["use std::net::TcpListener;\n\nlet listener = TcpListener::bind(\"127.0.0.1:8080\").unwrap();\nlet listener_clone = listener.try_clone().unwrap();"]}},{"name":"pub fn accept(&self) -> Result<(TcpStream, SocketAddr)>","details":{"description":["Accept a new incoming connection from this listener.","This function will block the calling thread until a new TCP connection is established. When established, the corresponding TcpStream and the remote peer's address will be returned."],"example":["use std::net::TcpListener;\n\nlet listener = TcpListener::bind(\"127.0.0.1:8080\").unwrap();\nmatch listener.accept() {\n    Ok((_socket, addr)) => println!(\"new client: {:?}\", addr),\n    Err(e) => println!(\"couldn't get client: {:?}\", e),\n}"]}},{"name":"pub fn incoming(&self) -> Incoming","details":{"description":["Returns an iterator over the connections being received on this listener.","The returned iterator will never return None and will also not yield the peer's SocketAddr structure. Iterating over it is equivalent to calling accept in a loop."],"example":["use std::net::TcpListener;\n\nlet listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n\nfor stream in listener.incoming() {\n    match stream {\n        Ok(stream) => {\n            println!(\"new client!\");\n        }\n        Err(e) => { /* connection failed */ }\n    }\n}"]}},{"name":"pub fn set_ttl(&self, ttl: u32) -> Result<()>","details":{"description":["Sets the value for the IP_TTL option on this socket.","This value sets the time-to-live field that is used in every packet sent from this socket."],"example":["use std::net::TcpListener;\n\nlet listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\nlistener.set_ttl(100).expect(\"could not set TTL\");"]}},{"name":"pub fn ttl(&self) -> Result<u32>","details":{"description":["Gets the value of the IP_TTL option for this socket.","For more information about this option, see set_ttl."],"example":["use std::net::TcpListener;\n\nlet listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\nlistener.set_ttl(100).expect(\"could not set TTL\");\nassert_eq!(listener.ttl().unwrap_or(0), 100);"]}},{"name":"pub fn set_only_v6(&self, only_v6: bool) -> Result<()>","stability":["Deprecated since 1.16.0: this option can only be set before the socket is bound\n"]},{"name":"pub fn only_v6(&self) -> Result<bool>","stability":["Deprecated since 1.16.0: this option can only be set before the socket is bound\n"]},{"name":"pub fn take_error(&self) -> Result<Option<Error>>","details":{"description":["Get the value of the SO_ERROR option on this socket.","This will retrieve the stored error in the underlying socket, clearing the field in the process. This can be useful for checking errors between calls."],"example":["use std::net::TcpListener;\n\nlet listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\nlistener.take_error().expect(\"No error was expected\");"]}},{"name":"pub fn set_nonblocking(&self, nonblocking: bool) -> Result<()>","details":{"description":["Moves this TCP stream into or out of nonblocking mode.","This will result in the accept operation becoming nonblocking, i.e. immediately returning from their calls. If the IO operation is successful, Ok is returned and no further action is required. If the IO operation could not be completed and needs to be retried, an error with kind io::ErrorKind::WouldBlock is returned.","On Unix platforms, calling this method corresponds to calling fcntl FIONBIO. On Windows calling this method corresponds to calling ioctlsocket FIONBIO."],"example":["Bind a TCP listener to an address, listen for connections, and read\nbytes in nonblocking mode:","use std::io;\nuse std::net::TcpListener;\n\nlet listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\nlistener.set_nonblocking(true).expect(\"Cannot set non-blocking\");\n\nfor stream in listener.incoming() {\n    match stream {\n        Ok(s) => {\n            // do something with the TcpStream\n            handle_connection(s);\n        }\n        Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {\n            // wait until network socket is ready, typically implemented\n            // via platform-specific APIs such as epoll or IOCP\n            wait_for_fd();\n            continue;\n        }\n        Err(e) => panic!(\"encountered IO error: {}\", e),\n    }\n}"]}}]}