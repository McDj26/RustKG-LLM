{"stability":{"stable since":"1.0.0"},"apiName":"std::hash::Hash","apiType":"trait","apiDocumentation":{"apiDescription":["A hashable type.","Types implementing Hash are able to be hashed with an instance of Hasher.","Implementing Hash","You can derive Hash with #[derive(Hash)] if all fields implement Hash. The resulting hash will be the combination of the values from calling hash on each field.","#[derive(Hash)] struct Rustacean { name: String, country: String, }","If you need more control over how a value is hashed, you can of course implement the Hash trait yourself:","use std::hash::{Hash, Hasher}; struct Person { id: u32, name: String, phone: u64, } impl Hash for Person { fn hash<H: Hasher>(&self, state: &mut H) { self.id.hash(state); self.phone.hash(state); } }","Hash and Eq","When implementing both Hash and Eq, it is important that the following property holds:","k1 == k2 -> hash(k1) == hash(k2)","In other words, if two keys are equal, their hashes must also be equal. HashMap and HashSet both rely on this behavior.","Thankfully, you won't need to worry about upholding this property when deriving both Eq and Hash with #[derive(PartialEq, Eq, Hash)]."]},"trait required methods":[{"name":"fn hash<H>(&self, state: &mut H) where H: Hasher","details":{"description":"Feeds this value into the given Hasher.","example":["use std::collections::hash_map::DefaultHasher;\nuse std::hash::{Hash, Hasher};\n\nlet mut hasher = DefaultHasher::new();\n7920.hash(&mut hasher);\nprintln!(\"Hash is {:x}!\", hasher.finish());"]}}],"trait provided methods":[{"name":"fn hash_slice<H>(data: &[Self], state: &mut H) where H: Hasher","details":{"description":"Feeds a slice of this type into the given Hasher.","example":["use std::collections::hash_map::DefaultHasher;\nuse std::hash::{Hash, Hasher};\n\nlet mut hasher = DefaultHasher::new();\nlet numbers = [6, 28, 496, 8128];\nHash::hash_slice(&numbers, &mut hasher);\nprintln!(\"Hash is {:x}!\", hasher.finish());"]}}]}