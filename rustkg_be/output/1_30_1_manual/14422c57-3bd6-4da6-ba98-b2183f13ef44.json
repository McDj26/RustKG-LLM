{"stability":{"stable since":"1.0.0"},"apiName":"std::sync::atomic::AtomicUsize","apiType":"struct","apiDocumentation":{"apiDescription":["An integer type which can be safely shared between threads.","This type has the same in-memory representation as the underlying integer type, usize. For more about the differences between atomic types and non-atomic types, please see the module-level documentation."]},"trait implementations":[{"name":"impl std::fmt::Debug for std::sync::atomic::AtomicUsize","stable since":"1.3.0"},{"name":"impl std::convert::From<usize> for std::sync::atomic::AtomicUsize","stable since":"1.23.0"},{"name":"impl std::marker::Sync for std::sync::atomic::AtomicUsize","stable since":"1.0.0"},{"name":"impl std::default::Default for std::sync::atomic::AtomicUsize","stable since":"1.0.0"},{"name":"impl std::panic::RefUnwindSafe for std::sync::atomic::AtomicUsize","stable since":"1.14.0"},{"name":"impl std::marker::Send for std::sync::atomic::AtomicUsize","stable since":"1.0.0"}],"methods":[{"name":"pub const fn new(v: usize) -> AtomicUsize","details":{"description":["Creates a new atomic integer."],"example":["use std::sync::atomic::AtomicUsize;\n\nlet atomic_forty_two = AtomicUsize::new(42);"]}},{"name":"pub fn get_mut(&mut self) -> &mut usize","details":{"description":["Returns a mutable reference to the underlying integer.","This is safe because the mutable reference guarantees that no other threads are concurrently accessing the atomic data."],"example":["use std::sync::atomic::{AtomicUsize, Ordering};\n\nlet mut some_var = AtomicUsize::new(10);\nassert_eq!(*some_var.get_mut(), 10);\n*some_var.get_mut() = 5;\nassert_eq!(some_var.load(Ordering::SeqCst), 5);"]}},{"name":"pub fn into_inner(self) -> usize","details":{"description":["Consumes the atomic and returns the contained value.","This is safe because passing self by value guarantees that no other threads are concurrently accessing the atomic data."],"example":["use std::sync::atomic::AtomicUsize;\n\nlet some_var = AtomicUsize::new(5);\nassert_eq!(some_var.into_inner(), 5);"]}},{"name":"pub fn load(&self, order: Ordering) -> usize","details":{"description":["Loads a value from the atomic integer.","load takes an Ordering argument which describes the memory ordering of this operation. Possible values are SeqCst, Acquire and Relaxed.","Panics","Panics if order is Release or AcqRel."],"example":["use std::sync::atomic::{AtomicUsize, Ordering};\n\nlet some_var = AtomicUsize::new(5);\n\nassert_eq!(some_var.load(Ordering::Relaxed), 5);"]}},{"name":"pub fn store(&self, val: usize, order: Ordering)","details":{"description":["Stores a value into the atomic integer.","store takes an Ordering argument which describes the memory ordering of this operation. Possible values are SeqCst, Release and Relaxed.","Panics","Panics if order is Acquire or AcqRel."],"example":["use std::sync::atomic::{AtomicUsize, Ordering};\n\nlet some_var = AtomicUsize::new(5);\n\nsome_var.store(10, Ordering::Relaxed);\nassert_eq!(some_var.load(Ordering::Relaxed), 10);"]}},{"name":"pub fn swap(&self, val: usize, order: Ordering) -> usize","details":{"description":["Stores a value into the atomic integer, returning the previous value.","swap takes an Ordering argument which describes the memory ordering of this operation. All ordering modes are possible. Note that using Acquire makes the store part of this operation Relaxed, and using Release makes the load part Relaxed."],"example":["use std::sync::atomic::{AtomicUsize, Ordering};\n\nlet some_var = AtomicUsize::new(5);\n\nassert_eq!(some_var.swap(10, Ordering::Relaxed), 5);"]}},{"name":"pub fn compare_and_swap( &self, current: usize, new: usize, order: Ordering) -> usize","details":{"description":["Stores a value into the atomic integer if the current value is the same as the current value.","The return value is always the previous value. If it is equal to current, then the value was updated.","compare_and_swap also takes an Ordering argument which describes the memory ordering of this operation. Notice that even when using AcqRel, the operation might fail and hence just perform an Acquire load, but not have Release semantics. Using Acquire makes the store part of this operation Relaxed if it happens, and using Release makes the load part Relaxed."],"example":["use std::sync::atomic::{AtomicUsize, Ordering};\n\nlet some_var = AtomicUsize::new(5);\n\nassert_eq!(some_var.compare_and_swap(5, 10, Ordering::Relaxed), 5);\nassert_eq!(some_var.load(Ordering::Relaxed), 10);\n\nassert_eq!(some_var.compare_and_swap(6, 12, Ordering::Relaxed), 10);\nassert_eq!(some_var.load(Ordering::Relaxed), 10);"]}},{"name":"pub fn compare_exchange( &self, current: usize, new: usize, success: Ordering, failure: Ordering) -> Result<usize, usize>","details":{"description":["Stores a value into the atomic integer if the current value is the same as the current value.","The return value is a result indicating whether the new value was written and containing the previous value. On success this value is guaranteed to be equal to current.","compare_exchange takes two Ordering arguments to describe the memory ordering of this operation. The first describes the required ordering if the operation succeeds while the second describes the required ordering when the operation fails. Using Acquire as success ordering makes the store part of this operation Relaxed, and using Release makes the successful load Relaxed. The failure ordering can only be SeqCst, Acquire or Relaxed and must be equivalent to or weaker than the success ordering."],"example":["use std::sync::atomic::{AtomicUsize, Ordering};\n\nlet some_var = AtomicUsize::new(5);\n\nassert_eq!(some_var.compare_exchange(5, 10,\n                                     Ordering::Acquire,\n                                     Ordering::Relaxed),\n           Ok(5));\nassert_eq!(some_var.load(Ordering::Relaxed), 10);\n\nassert_eq!(some_var.compare_exchange(6, 12,\n                                     Ordering::SeqCst,\n                                     Ordering::Acquire),\n           Err(10));\nassert_eq!(some_var.load(Ordering::Relaxed), 10);"]}},{"name":"pub fn compare_exchange_weak( &self, current: usize, new: usize, success: Ordering, failure: Ordering) -> Result<usize, usize>","details":{"description":["Stores a value into the atomic integer if the current value is the same as the current value.","Unlike compare_exchange, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.","compare_exchange_weak takes two Ordering arguments to describe the memory ordering of this operation. The first describes the required ordering if the operation succeeds while the second describes the required ordering when the operation fails. Using Acquire as success ordering makes the store part of this operation Relaxed, and using Release makes the successful load Relaxed. The failure ordering can only be SeqCst, Acquire or Relaxed and must be equivalent to or weaker than the success ordering."],"example":["use std::sync::atomic::{AtomicUsize, Ordering};\n\nlet val = AtomicUsize::new(4);\n\nlet mut old = val.load(Ordering::Relaxed);\nloop {\n    let new = old * 2;\n    match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n        Ok(_) => break,\n        Err(x) => old = x,\n    }\n}"]}},{"name":"pub fn fetch_add(&self, val: usize, order: Ordering) -> usize","details":{"description":["Adds to the current value, returning the previous value.","This operation wraps around on overflow.","fetch_add takes an Ordering argument which describes the memory ordering of this operation. All ordering modes are possible. Note that using Acquire makes the store part of this operation Relaxed, and using Release makes the load part Relaxed."],"example":["use std::sync::atomic::{AtomicUsize, Ordering};\n\nlet foo = AtomicUsize::new(0);\nassert_eq!(foo.fetch_add(10, Ordering::SeqCst), 0);\nassert_eq!(foo.load(Ordering::SeqCst), 10);"]}},{"name":"pub fn fetch_sub(&self, val: usize, order: Ordering) -> usize","details":{"description":["Subtracts from the current value, returning the previous value.","This operation wraps around on overflow.","fetch_sub takes an Ordering argument which describes the memory ordering of this operation. All ordering modes are possible. Note that using Acquire makes the store part of this operation Relaxed, and using Release makes the load part Relaxed."],"example":["use std::sync::atomic::{AtomicUsize, Ordering};\n\nlet foo = AtomicUsize::new(20);\nassert_eq!(foo.fetch_sub(10, Ordering::SeqCst), 20);\nassert_eq!(foo.load(Ordering::SeqCst), 10);"]}},{"name":"pub fn fetch_and(&self, val: usize, order: Ordering) -> usize","details":{"description":["Bitwise \"and\" with the current value.","Performs a bitwise \"and\" operation on the current value and the argument val, and sets the new value to the result.","Returns the previous value.","fetch_and takes an Ordering argument which describes the memory ordering of this operation. All ordering modes are possible. Note that using Acquire makes the store part of this operation Relaxed, and using Release makes the load part Relaxed."],"example":["use std::sync::atomic::{AtomicUsize, Ordering};\n\nlet foo = AtomicUsize::new(0b101101);\nassert_eq!(foo.fetch_and(0b110011, Ordering::SeqCst), 0b101101);\nassert_eq!(foo.load(Ordering::SeqCst), 0b100001);"]}},{"name":"pub fn fetch_nand(&self, val: usize, order: Ordering) -> usize","details":{"description":["Bitwise \"nand\" with the current value.","Performs a bitwise \"nand\" operation on the current value and the argument val, and sets the new value to the result.","Returns the previous value.","fetch_nand takes an Ordering argument which describes the memory ordering of this operation. All ordering modes are possible. Note that using Acquire makes the store part of this operation Relaxed, and using Release makes the load part Relaxed."],"example":["use std::sync::atomic::{AtomicUsize, Ordering};\n\nlet foo = AtomicUsize::new(0x13);\nassert_eq!(foo.fetch_nand(0x31, Ordering::SeqCst), 0x13);\nassert_eq!(foo.load(Ordering::SeqCst), !(0x13 & 0x31));"]}},{"name":"pub fn fetch_or(&self, val: usize, order: Ordering) -> usize","details":{"description":["Bitwise \"or\" with the current value.","Performs a bitwise \"or\" operation on the current value and the argument val, and sets the new value to the result.","Returns the previous value.","fetch_or takes an Ordering argument which describes the memory ordering of this operation. All ordering modes are possible. Note that using Acquire makes the store part of this operation Relaxed, and using Release makes the load part Relaxed."],"example":["use std::sync::atomic::{AtomicUsize, Ordering};\n\nlet foo = AtomicUsize::new(0b101101);\nassert_eq!(foo.fetch_or(0b110011, Ordering::SeqCst), 0b101101);\nassert_eq!(foo.load(Ordering::SeqCst), 0b111111);"]}},{"name":"pub fn fetch_xor(&self, val: usize, order: Ordering) -> usize","details":{"description":["Bitwise \"xor\" with the current value.","Performs a bitwise \"xor\" operation on the current value and the argument val, and sets the new value to the result.","Returns the previous value.","fetch_xor takes an Ordering argument which describes the memory ordering of this operation. All ordering modes are possible. Note that using Acquire makes the store part of this operation Relaxed, and using Release makes the load part Relaxed."],"example":["use std::sync::atomic::{AtomicUsize, Ordering};\n\nlet foo = AtomicUsize::new(0b101101);\nassert_eq!(foo.fetch_xor(0b110011, Ordering::SeqCst), 0b101101);\nassert_eq!(foo.load(Ordering::SeqCst), 0b011110);"]}},{"name":"pub fn fetch_update<F>( &self, f: F, fetch_order: Ordering, set_order: Ordering) -> Result<usize, usize> where F: FnMut(usize) -> Option<usize>","stability":["🔬 This is a nightly-only experimental API.  (no_more_cas #48655)no more CAS loops in user code\n"]},{"name":"pub fn fetch_max(&self, val: usize, order: Ordering) -> usize","stability":["🔬 This is a nightly-only experimental API.  (atomic_min_max #48655)easier and faster min/max than writing manual CAS loop\n"]},{"name":"pub fn fetch_min(&self, val: usize, order: Ordering) -> usize","stability":["🔬 This is a nightly-only experimental API.  (atomic_min_max #48655)easier and faster min/max than writing manual CAS loop\n"]}]}