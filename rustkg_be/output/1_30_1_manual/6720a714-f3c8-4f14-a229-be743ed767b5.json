{"stability":{"stable since":"1.0.0"},"apiName":"std::io::BufRead","apiType":"trait","apiDocumentation":{"apiDescription":["A BufRead is a type of Reader which has an internal buffer, allowing it to perform extra ways of reading.","For example, reading line-by-line is inefficient without using a buffer, so if you want to read by line, you'll need BufRead, which includes a read_line method as well as a lines iterator."],"examples":["A locked standard input implements BufRead:","use std::io;\nuse std::io::prelude::*;\n\nlet stdin = io::stdin();\nfor line in stdin.lock().lines() {\n    println!(\"{}\", line.unwrap());\n}","If you have something that implements Read, you can use the BufReader\ntype to turn it into a BufRead.","For example, File implements Read, but not BufRead.\nBufReader to the rescue!","use std::io::{self, BufReader};\nuse std::io::prelude::*;\nuse std::fs::File;\n\nfn main() -> io::Result<()> {\n    let f = File::open(\"foo.txt\")?;\n    let f = BufReader::new(f);\n\n    for line in f.lines() {\n        println!(\"{}\", line.unwrap());\n    }\n\n    Ok(())\n}"]},"trait required methods":[{"name":"fn fill_buf(&mut self) -> Result<&[u8]>","details":{"description":"Returns the contents of the internal buffer, filling it with more data\nfrom the inner reader if it is empty.","example":["A locked standard input implements BufRead:","use std::io;\nuse std::io::prelude::*;\n\nlet stdin = io::stdin();\nlet mut stdin = stdin.lock();\n\n// we can't have two `&mut` references to `stdin`, so use a block\n// to end the borrow early.\nlet length = {\n    let buffer = stdin.fill_buf().unwrap();\n\n    // work with buffer\n    println!(\"{:?}\", buffer);\n\n    buffer.len()\n};\n\n// ensure the bytes we worked with aren't returned again later\nstdin.consume(length);"]}},{"name":"fn consume(&mut self, amt: usize)","details":{"description":"Tells this buffer that amt bytes have been consumed from the buffer,\nso they should no longer be returned in calls to read.","example":["Since consume() is meant to be used with fill_buf,\nthat method's example includes an example of consume()."]}}],"trait provided methods":[{"name":"fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> Result<usize>","details":{"description":"Read all bytes into buf until the delimiter byte or EOF is reached.","example":["std::io::Cursor is a type that implements BufRead. In\nthis example, we use Cursor to read all the bytes in a byte slice\nin hyphen delimited segments:","use std::io::{self, BufRead};\n\nlet mut cursor = io::Cursor::new(b\"lorem-ipsum\");\nlet mut buf = vec![];\n\n// cursor is at 'l'\nlet num_bytes = cursor.read_until(b'-', &mut buf)\n    .expect(\"reading from cursor won't fail\");\nassert_eq!(num_bytes, 6);\nassert_eq!(buf, b\"lorem-\");\nbuf.clear();\n\n// cursor is at 'i'\nlet num_bytes = cursor.read_until(b'-', &mut buf)\n    .expect(\"reading from cursor won't fail\");\nassert_eq!(num_bytes, 5);\nassert_eq!(buf, b\"ipsum\");\nbuf.clear();\n\n// cursor is at EOF\nlet num_bytes = cursor.read_until(b'-', &mut buf)\n    .expect(\"reading from cursor won't fail\");\nassert_eq!(num_bytes, 0);\nassert_eq!(buf, b\"\");"]}},{"name":"fn read_line(&mut self, buf: &mut String) -> Result<usize>","details":{"description":"Read all bytes until a newline (the 0xA byte) is reached, and append\nthem to the provided buffer.","example":["std::io::Cursor is a type that implements BufRead. In\nthis example, we use Cursor to read all the lines in a byte slice:","use std::io::{self, BufRead};\n\nlet mut cursor = io::Cursor::new(b\"foo\\nbar\");\nlet mut buf = String::new();\n\n// cursor is at 'f'\nlet num_bytes = cursor.read_line(&mut buf)\n    .expect(\"reading from cursor won't fail\");\nassert_eq!(num_bytes, 4);\nassert_eq!(buf, \"foo\\n\");\nbuf.clear();\n\n// cursor is at 'b'\nlet num_bytes = cursor.read_line(&mut buf)\n    .expect(\"reading from cursor won't fail\");\nassert_eq!(num_bytes, 3);\nassert_eq!(buf, \"bar\");\nbuf.clear();\n\n// cursor is at EOF\nlet num_bytes = cursor.read_line(&mut buf)\n    .expect(\"reading from cursor won't fail\");\nassert_eq!(num_bytes, 0);\nassert_eq!(buf, \"\");"]}},{"name":"fn split(self, byte: u8) -> Split<Self> where Self: Sized","details":{"description":"Returns an iterator over the contents of this reader split on the byte\nbyte.","example":["std::io::Cursor is a type that implements BufRead. In\nthis example, we use Cursor to iterate over all hyphen delimited\nsegments in a byte slice","use std::io::{self, BufRead};\n\nlet cursor = io::Cursor::new(b\"lorem-ipsum-dolor\");\n\nlet mut split_iter = cursor.split(b'-').map(|l| l.unwrap());\nassert_eq!(split_iter.next(), Some(b\"lorem\".to_vec()));\nassert_eq!(split_iter.next(), Some(b\"ipsum\".to_vec()));\nassert_eq!(split_iter.next(), Some(b\"dolor\".to_vec()));\nassert_eq!(split_iter.next(), None);"]}},{"name":"fn lines(self) -> Lines<Self> where Self: Sized","details":{"description":"Returns an iterator over the lines of this reader.","example":["std::io::Cursor is a type that implements BufRead. In\nthis example, we use Cursor to iterate over all the lines in a byte\nslice.","use std::io::{self, BufRead};\n\nlet cursor = io::Cursor::new(b\"lorem\\nipsum\\r\\ndolor\");\n\nlet mut lines_iter = cursor.lines().map(|l| l.unwrap());\nassert_eq!(lines_iter.next(), Some(String::from(\"lorem\")));\nassert_eq!(lines_iter.next(), Some(String::from(\"ipsum\")));\nassert_eq!(lines_iter.next(), Some(String::from(\"dolor\")));\nassert_eq!(lines_iter.next(), None);","Errors","Each line of the iterator has the same error semantics as BufRead::read_line."]}}]}