{"stability":{"unstable":"ðŸ”¬ This is a nightly-only experimental API.  (raw #27751)"},"apiName":"std::raw::TraitObject","apiType":"struct","apiDocumentation":{"apiDescription":["The representation of a trait object like &SomeTrait.","This struct has the same layout as types like &SomeTrait and Box<AnotherTrait>. The Trait Objects chapter of the Book contains more details about the precise nature of these internals.","TraitObject is guaranteed to match layouts, but it is not the type of trait objects (e.g. the fields are not directly accessible on a &SomeTrait) nor does it control that layout (changing the definition will not change the layout of a &SomeTrait). It is only designed to be used by unsafe code that needs to manipulate the low-level details.","There is no way to refer to all trait objects generically, so the only way to create values of this type is with functions like std::mem::transmute. Similarly, the only way to create a true trait object from a TraitObject value is with transmute.","Synthesizing a trait object with mismatched typesâ€”one where the vtable does not correspond to the type of the value to which the data pointer pointsâ€”is highly likely to lead to undefined behavior."],"examples":["#![feature(raw)]\n\nuse std::{mem, raw};\n\n// an example trait\ntrait Foo {\n    fn bar(&self) -> i32;\n}\n\nimpl Foo for i32 {\n    fn bar(&self) -> i32 {\n         *self + 1\n    }\n}\n\nlet value: i32 = 123;\n\n// let the compiler make a trait object\nlet object: &Foo = &value;\n\n// look at the raw representation\nlet raw_object: raw::TraitObject = unsafe { mem::transmute(object) };\n\n// the data pointer is the address of `value`\nassert_eq!(raw_object.data as *const i32, &value as *const _);\n\nlet other_value: i32 = 456;\n\n// construct a new object, pointing to a different `i32`, being\n// careful to use the `i32` vtable from `object`\nlet synthesized: &Foo = unsafe {\n     mem::transmute(raw::TraitObject {\n         data: &other_value as *const _ as *mut (),\n         vtable: raw_object.vtable,\n     })\n};\n\n// it should work just as if we had constructed a trait object out of\n// `other_value` directly\nassert_eq!(synthesized.bar(), 457);"]},"trait implementations":[{"name":"impl std::clone::Clone for std::raw::TraitObject","stable since":"1.0.0"},{"name":"impl std::marker::Copy for std::raw::TraitObject","stable since":"1.0.0"},{"name":"impl !std::marker::Send for std::raw::TraitObject","stable since":"1.0.0"},{"name":"impl !std::marker::Sync for std::raw::TraitObject","stable since":"1.0.0"}]}