{"stability":{"stable since":"1.0.0"},"apiName":"std::option::Option","apiType":"enum","apiDocumentation":{"apiDescription":["The Option type. See the module level documentation for more."]},"enum variants":["None","No value\n","Some(T)","Some value T\n"],"trait implementations":[{"name":"impl<T> std::iter::IntoIterator for std::option::Option<T>","stable since":"1.0.0"},{"name":"impl<'a, T> std::iter::IntoIterator for &'a std::option::Option<T>","stable since":"1.4.0"},{"name":"impl<'a, T> std::iter::IntoIterator for &'a mut std::option::Option<T>","stable since":"1.4.0"},{"name":"impl<T> std::hash::Hash for std::option::Option<T> where T: std::hash::Hash","stable since":"1.0.0"},{"name":"impl<T> std::clone::Clone for std::option::Option<T> where T: std::clone::Clone","stable since":"1.0.0"},{"name":"impl<T> std::cmp::PartialOrd<std::option::Option<T>> for std::option::Option<T> where T: std::cmp::PartialOrd<T>","stable since":"1.0.0"},{"name":"impl<T> std::cmp::Ord for std::option::Option<T> where T: std::cmp::Ord","stable since":"1.0.0"},{"name":"impl<T> std::fmt::Debug for std::option::Option<T> where T: std::fmt::Debug","stable since":"1.0.0"},{"name":"impl<T> std::cmp::Eq for std::option::Option<T> where T: std::cmp::Eq","stable since":"1.0.0"},{"name":"impl<T> std::cmp::PartialEq<std::option::Option<T>> for std::option::Option<T> where T: std::cmp::PartialEq<T>","stable since":"1.0.0"},{"name":"impl<'a, T> std::convert::From<&'a mut std::option::Option<T>> for std::option::Option<&'a mut T>","stable since":"1.30.0"},{"name":"impl<T> std::convert::From<T> for std::option::Option<T>","stable since":"1.12.0"},{"name":"impl<'a, T> std::convert::From<&'a std::option::Option<T>> for std::option::Option<&'a T>","stable since":"1.30.0"},{"name":"impl<T> std::marker::Copy for std::option::Option<T> where T: std::marker::Copy","stable since":"1.0.0"},{"name":"impl<A, V> std::iter::FromIterator<std::option::Option<A>> for std::option::Option<V> where V: std::iter::FromIterator<A>","stable since":"1.0.0"},{"name":"impl<T> std::ops::Try for std::option::Option<T>","stable since":"1.0.0"},{"name":"impl<T> std::default::Default for std::option::Option<T>","stable since":"1.0.0"},{"name":"impl<T> std::marker::Send for std::option::Option<T> where T: std::marker::Send","stable since":"1.0.0"},{"name":"impl<T> std::marker::Sync for std::option::Option<T> where T: std::marker::Sync","stable since":"1.0.0"}],"methods":[{"name":"pub fn is_some(&self) -> bool","details":{"description":["Returns true if the option is a Some value."],"example":["let x: Option<u32> = Some(2);\nassert_eq!(x.is_some(), true);\n\nlet x: Option<u32> = None;\nassert_eq!(x.is_some(), false);"]}},{"name":"pub fn is_none(&self) -> bool","details":{"description":["Returns true if the option is a None value."],"example":["let x: Option<u32> = Some(2);\nassert_eq!(x.is_none(), false);\n\nlet x: Option<u32> = None;\nassert_eq!(x.is_none(), true);"]}},{"name":"pub fn as_ref(&self) -> Option<&T>","details":{"description":["Converts from Option<T> to Option<&T>."],"example":["Convert an Option<String> into an Option<usize>, preserving the original.\nThe map method takes the self argument by value, consuming the original,\nso this technique uses as_ref to first take an Option to a reference\nto the value inside the original.","let text: Option<String> = Some(\"Hello, world!\".to_string());\n// First, cast `Option<String>` to `Option<&String>` with `as_ref`,\n// then consume *that* with `map`, leaving `text` on the stack.\nlet text_length: Option<usize> = text.as_ref().map(|s| s.len());\nprintln!(\"still can print text: {:?}\", text);"]}},{"name":"pub fn as_mut(&mut self) -> Option<&mut T>","details":{"description":["Converts from Option<T> to Option<&mut T>."],"example":["let mut x = Some(2);\nmatch x.as_mut() {\n    Some(v) => *v = 42,\n    None => {},\n}\nassert_eq!(x, Some(42));"]}},{"name":"pub fn as_pin_mut(self: PinMut<'a, Option<T>>) -> Option<PinMut<'a, T>>","stability":["ðŸ”¬ This is a nightly-only experimental API.  (pin #49150)"]},{"name":"pub fn expect(self, msg: &str) -> T","details":{"description":["Unwraps an option, yielding the content of a Some.","Panics","Panics if the value is a None with a custom panic message provided by msg."],"example":["let x = Some(\"value\");\nassert_eq!(x.expect(\"the world is ending\"), \"value\");","let x: Option<&str> = None;\nx.expect(\"the world is ending\"); // panics with `the world is ending`"]}},{"name":"pub fn unwrap(self) -> T","details":{"description":["Moves the value v out of the Option<T> if it is Some(v).","In general, because this function may panic, its use is discouraged. Instead, prefer to use pattern matching and handle the None case explicitly.","Panics","Panics if the self value equals None."],"example":["let x = Some(\"air\");\nassert_eq!(x.unwrap(), \"air\");","let x: Option<&str> = None;\nassert_eq!(x.unwrap(), \"air\"); // fails"]}},{"name":"pub fn unwrap_or(self, def: T) -> T","details":{"description":["Returns the contained value or a default.","Arguments passed to unwrap_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use unwrap_or_else, which is lazily evaluated."],"example":["assert_eq!(Some(\"car\").unwrap_or(\"bike\"), \"car\");\nassert_eq!(None.unwrap_or(\"bike\"), \"bike\");"]}},{"name":"pub fn unwrap_or_else<F>(self, f: F) -> T where F: FnOnce() -> T","details":{"description":["Returns the contained value or computes it from a closure."],"example":["let k = 10;\nassert_eq!(Some(4).unwrap_or_else(|| 2 * k), 4);\nassert_eq!(None.unwrap_or_else(|| 2 * k), 20);"]}},{"name":"pub fn map<U, F>(self, f: F) -> Option<U> where F: FnOnce(T) -> U","details":{"description":["Maps an Option<T> to Option<U> by applying a function to a contained value."],"example":["Convert an Option<String> into an Option<usize>, consuming the original:","let maybe_some_string = Some(String::from(\"Hello, World!\"));\n// `Option::map` takes self *by value*, consuming `maybe_some_string`\nlet maybe_some_len = maybe_some_string.map(|s| s.len());\n\nassert_eq!(maybe_some_len, Some(13));"]}},{"name":"pub fn map_or<U, F>(self, default: U, f: F) -> U where F: FnOnce(T) -> U","details":{"description":["Applies a function to the contained value (if any), or returns the provided default (if not)."],"example":["let x = Some(\"foo\");\nassert_eq!(x.map_or(42, |v| v.len()), 3);\n\nlet x: Option<&str> = None;\nassert_eq!(x.map_or(42, |v| v.len()), 42);"]}},{"name":"pub fn map_or_else<U, D, F>(self, default: D, f: F) -> U where D: FnOnce() -> U, F: FnOnce(T) -> U","details":{"description":["Applies a function to the contained value (if any), or computes a default (if not)."],"example":["let k = 21;\n\nlet x = Some(\"foo\");\nassert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 3);\n\nlet x: Option<&str> = None;\nassert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 42);"]}},{"name":"pub fn ok_or<E>(self, err: E) -> Result<T, E>","details":{"description":["Transforms the Option<T> into a Result<T, E>, mapping Some(v) to Ok(v) and None to Err(err).","Arguments passed to ok_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use ok_or_else, which is lazily evaluated."],"example":["let x = Some(\"foo\");\nassert_eq!(x.ok_or(0), Ok(\"foo\"));\n\nlet x: Option<&str> = None;\nassert_eq!(x.ok_or(0), Err(0));"]}},{"name":"pub fn ok_or_else<E, F>(self, err: F) -> Result<T, E> where F: FnOnce() -> E","details":{"description":["Transforms the Option<T> into a Result<T, E>, mapping Some(v) to Ok(v) and None to Err(err())."],"example":["let x = Some(\"foo\");\nassert_eq!(x.ok_or_else(|| 0), Ok(\"foo\"));\n\nlet x: Option<&str> = None;\nassert_eq!(x.ok_or_else(|| 0), Err(0));"]}},{"name":"pub fn iter(&self) -> Iter<T>","details":{"description":["Returns an iterator over the possibly contained value."],"example":["let x = Some(4);\nassert_eq!(x.iter().next(), Some(&4));\n\nlet x: Option<u32> = None;\nassert_eq!(x.iter().next(), None);"]}},{"name":"pub fn iter_mut(&mut self) -> IterMut<T>","details":{"description":["Returns a mutable iterator over the possibly contained value."],"example":["let mut x = Some(4);\nmatch x.iter_mut().next() {\n    Some(v) => *v = 42,\n    None => {},\n}\nassert_eq!(x, Some(42));\n\nlet mut x: Option<u32> = None;\nassert_eq!(x.iter_mut().next(), None);"]}},{"name":"pub fn and<U>(self, optb: Option<U>) -> Option<U>","details":{"description":["Returns None if the option is None, otherwise returns optb."],"example":["let x = Some(2);\nlet y: Option<&str> = None;\nassert_eq!(x.and(y), None);\n\nlet x: Option<u32> = None;\nlet y = Some(\"foo\");\nassert_eq!(x.and(y), None);\n\nlet x = Some(2);\nlet y = Some(\"foo\");\nassert_eq!(x.and(y), Some(\"foo\"));\n\nlet x: Option<u32> = None;\nlet y: Option<&str> = None;\nassert_eq!(x.and(y), None);"]}},{"name":"pub fn and_then<U, F>(self, f: F) -> Option<U> where F: FnOnce(T) -> Option<U>","details":{"description":["Returns None if the option is None, otherwise calls f with the wrapped value and returns the result.","Some languages call this operation flatmap."],"example":["fn sq(x: u32) -> Option<u32> { Some(x * x) }\nfn nope(_: u32) -> Option<u32> { None }\n\nassert_eq!(Some(2).and_then(sq).and_then(sq), Some(16));\nassert_eq!(Some(2).and_then(sq).and_then(nope), None);\nassert_eq!(Some(2).and_then(nope).and_then(sq), None);\nassert_eq!(None.and_then(sq).and_then(sq), None);"]}},{"name":"pub fn filter<P>(self, predicate: P) -> Option<T> where P: FnOnce(&T) -> bool","details":{"description":["Returns None if the option is None, otherwise calls predicate with the wrapped value and returns:","Some(t) if predicate returns true (where t is the wrapped value), and None if predicate returns false.","This function works similar to Iterator::filter(). You can imagine the Option<T> being an iterator over one or zero elements. filter() lets you decide which elements to keep."],"example":["fn is_even(n: &i32) -> bool {\n    n % 2 == 0\n}\n\nassert_eq!(None.filter(is_even), None);\nassert_eq!(Some(3).filter(is_even), None);\nassert_eq!(Some(4).filter(is_even), Some(4));"]}},{"name":"pub fn or(self, optb: Option<T>) -> Option<T>","details":{"description":["Returns the option if it contains a value, otherwise returns optb.","Arguments passed to or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use or_else, which is lazily evaluated."],"example":["let x = Some(2);\nlet y = None;\nassert_eq!(x.or(y), Some(2));\n\nlet x = None;\nlet y = Some(100);\nassert_eq!(x.or(y), Some(100));\n\nlet x = Some(2);\nlet y = Some(100);\nassert_eq!(x.or(y), Some(2));\n\nlet x: Option<u32> = None;\nlet y = None;\nassert_eq!(x.or(y), None);"]}},{"name":"pub fn or_else<F>(self, f: F) -> Option<T> where F: FnOnce() -> Option<T>","details":{"description":["Returns the option if it contains a value, otherwise calls f and returns the result."],"example":["fn nobody() -> Option<&'static str> { None }\nfn vikings() -> Option<&'static str> { Some(\"vikings\") }\n\nassert_eq!(Some(\"barbarians\").or_else(vikings), Some(\"barbarians\"));\nassert_eq!(None.or_else(vikings), Some(\"vikings\"));\nassert_eq!(None.or_else(nobody), None);"]}},{"name":"pub fn xor(self, optb: Option<T>) -> Option<T>","stability":["ðŸ”¬ This is a nightly-only experimental API.  (option_xor #50512)"]},{"name":"pub fn get_or_insert(&mut self, v: T) -> &mut T","details":{"description":["Inserts v into the option if it is None, then returns a mutable reference to the contained value."],"example":["let mut x = None;\n\n{\n    let y: &mut u32 = x.get_or_insert(5);\n    assert_eq!(y, &5);\n\n    *y = 7;\n}\n\nassert_eq!(x, Some(7));"]}},{"name":"pub fn get_or_insert_with<F>(&mut self, f: F) -> &mut T where F: FnOnce() -> T","details":{"description":["Inserts a value computed from f into the option if it is None, then returns a mutable reference to the contained value."],"example":["let mut x = None;\n\n{\n    let y: &mut u32 = x.get_or_insert_with(|| 5);\n    assert_eq!(y, &5);\n\n    *y = 7;\n}\n\nassert_eq!(x, Some(7));"]}},{"name":"pub fn take(&mut self) -> Option<T>","details":{"description":["Takes the value out of the option, leaving a None in its place."],"example":["let mut x = Some(2);\nlet y = x.take();\nassert_eq!(x, None);\nassert_eq!(y, Some(2));\n\nlet mut x: Option<u32> = None;\nlet y = x.take();\nassert_eq!(x, None);\nassert_eq!(y, None);"]}},{"name":"pub fn replace(&mut self, value: T) -> Option<T>","stability":["ðŸ”¬ This is a nightly-only experimental API.  (option_replace #51998)"]},{"name":"pub fn cloned(self) -> Option<T>","details":{"description":["Maps an Option<&T> to an Option<T> by cloning the contents of the option."],"example":["let x = 12;\nlet opt_x = Some(&x);\nassert_eq!(opt_x, Some(&12));\nlet cloned = opt_x.cloned();\nassert_eq!(cloned, Some(12));"]}},{"name":"pub fn cloned(self) -> Option<T>","details":{"description":["Maps an Option<&mut T> to an Option<T> by cloning the contents of the option."],"example":["let mut x = 12;\nlet opt_x = Some(&mut x);\nassert_eq!(opt_x, Some(&mut 12));\nlet cloned = opt_x.cloned();\nassert_eq!(cloned, Some(12));"]}},{"name":"pub fn unwrap_or_default(self) -> T","details":{"description":["Returns the contained value or a default","Consumes the self argument then, if Some, returns the contained value, otherwise if None, returns the default value for that type."],"example":["Convert a string to an integer, turning poorly-formed strings\ninto 0 (the default value for integers). parse converts\na string to any other type that implements FromStr, returning\nNone on error.","let good_year_from_input = \"1909\";\nlet bad_year_from_input = \"190blarg\";\nlet good_year = good_year_from_input.parse().ok().unwrap_or_default();\nlet bad_year = bad_year_from_input.parse().ok().unwrap_or_default();\n\nassert_eq!(1909, good_year);\nassert_eq!(0, bad_year);"]}},{"name":"pub fn deref(&self) -> Option<&<T as Deref>::Target>","stability":["ðŸ”¬ This is a nightly-only experimental API.  (inner_deref #50264)newly added\n"]},{"name":"pub fn transpose(self) -> Result<Option<T>, E>","stability":["ðŸ”¬ This is a nightly-only experimental API.  (transpose_result #47338)"]}]}