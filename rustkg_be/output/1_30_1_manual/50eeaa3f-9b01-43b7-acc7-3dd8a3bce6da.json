{"stability":{"stable since":"1.0.0"},"apiName":"std::ascii::escape_default","apiType":"function","apiDocumentation":{"apiDescription":["Returns an iterator that produces an escaped version of a u8.","The default is chosen with a bias toward producing literals that are legal in a variety of languages, including C++11 and similar C-family languages. The exact rules are:","Tab is escaped as \\t. Carriage return is escaped as \\r. Line feed is escaped as \\n. Single quote is escaped as \\'. Double quote is escaped as \\\". Backslash is escaped as \\\\. Any character in the 'printable ASCII' range 0x20 .. 0x7e inclusive is not escaped. Any other chars are given hex escapes of the form '\\xNN'. Unicode escapes are never generated by this function."],"examples":["use std::ascii;\n\nlet escaped = ascii::escape_default(b'0').next().unwrap();\nassert_eq!(b'0', escaped);\n\nlet mut escaped = ascii::escape_default(b'\\t');\n\nassert_eq!(b'\\\\', escaped.next().unwrap());\nassert_eq!(b't', escaped.next().unwrap());\n\nlet mut escaped = ascii::escape_default(b'\\r');\n\nassert_eq!(b'\\\\', escaped.next().unwrap());\nassert_eq!(b'r', escaped.next().unwrap());\n\nlet mut escaped = ascii::escape_default(b'\\n');\n\nassert_eq!(b'\\\\', escaped.next().unwrap());\nassert_eq!(b'n', escaped.next().unwrap());\n\nlet mut escaped = ascii::escape_default(b'\\'');\n\nassert_eq!(b'\\\\', escaped.next().unwrap());\nassert_eq!(b'\\'', escaped.next().unwrap());\n\nlet mut escaped = ascii::escape_default(b'\"');\n\nassert_eq!(b'\\\\', escaped.next().unwrap());\nassert_eq!(b'\"', escaped.next().unwrap());\n\nlet mut escaped = ascii::escape_default(b'\\\\');\n\nassert_eq!(b'\\\\', escaped.next().unwrap());\nassert_eq!(b'\\\\', escaped.next().unwrap());\n\nlet mut escaped = ascii::escape_default(b'\\x9d');\n\nassert_eq!(b'\\\\', escaped.next().unwrap());\nassert_eq!(b'x', escaped.next().unwrap());\nassert_eq!(b'9', escaped.next().unwrap());\nassert_eq!(b'd', escaped.next().unwrap());"]}}