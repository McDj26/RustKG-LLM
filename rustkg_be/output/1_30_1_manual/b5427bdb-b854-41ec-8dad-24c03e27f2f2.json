{"stability":{"stable since":"1.0.0"},"apiName":"std::mem::replace","apiType":"function","apiDocumentation":{"apiDescription":["Moves src into the referenced dest, returning the previous dest value.","Neither value is dropped."],"examples":["A simple example:","use std::mem;\n\nlet mut v: Vec<i32> = vec![1, 2];\n\nlet old_v = mem::replace(&mut v, vec![3, 4, 5]);\nassert_eq!(2, old_v.len());\nassert_eq!(3, v.len());","replace allows consumption of a struct field by replacing it with another value.\nWithout replace you can run into issues like these:","â“˜This example deliberately fails to compile","struct Buffer<T> { buf: Vec<T> }\n\nimpl<T> Buffer<T> {\n    fn get_and_reset(&mut self) -> Vec<T> {\n        // error: cannot move out of dereference of `&mut`-pointer\n        let buf = self.buf;\n        self.buf = Vec::new();\n        buf\n    }\n}","Note that T does not necessarily implement Clone, so it can't even clone and reset\nself.buf. But replace can be used to disassociate the original value of self.buf from\nself, allowing it to be returned:","use std::mem;\n\nimpl<T> Buffer<T> {\n    fn get_and_reset(&mut self) -> Vec<T> {\n        mem::replace(&mut self.buf, Vec::new())\n    }\n}"]}}