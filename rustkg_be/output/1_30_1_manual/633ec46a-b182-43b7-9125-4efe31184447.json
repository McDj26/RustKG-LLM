{"stability":{"stable since":"1.0.0"},"apiName":"std::mem::drop","apiType":"function","apiDocumentation":{"apiDescription":["Disposes of a value.","While this does call the argument's implementation of Drop, it will not release any borrows, as borrows are based on lexical scope.","This effectively does nothing for types which implement Copy, e.g. integers. Such values are copied and then moved into the function, so the value persists after this function call.","This function is not magic; it is literally defined as","pub fn drop<T>(_x: T) { }","Because _x is moved into the function, it is automatically dropped before the function returns."],"examples":["Basic usage:","let v = vec![1, 2, 3];\n\ndrop(v); // explicitly drop the vector","Borrows are based on lexical scope, so this produces an error:","â“˜This example deliberately fails to compile","let mut v = vec![1, 2, 3];\nlet x = &v[0];\n\ndrop(x); // explicitly drop the reference, but the borrow still exists\n\nv.push(4); // error: cannot borrow `v` as mutable because it is also\n           // borrowed as immutable","An inner scope is needed to fix this:","let mut v = vec![1, 2, 3];\n\n{\n    let x = &v[0];\n\n    drop(x); // this is now redundant, as `x` is going out of scope anyway\n}\n\nv.push(4); // no problems","Since RefCell enforces the borrow rules at runtime, drop can\nrelease a RefCell borrow:","use std::cell::RefCell;\n\nlet x = RefCell::new(1);\n\nlet mut mutable_borrow = x.borrow_mut();\n*mutable_borrow = 1;\n\ndrop(mutable_borrow); // relinquish the mutable borrow on this slot\n\nlet borrow = x.borrow();\nprintln!(\"{}\", *borrow);","Integers and other types implementing Copy are unaffected by drop.","#[derive(Copy, Clone)]\nstruct Foo(u8);\n\nlet x = 1;\nlet y = Foo(2);\ndrop(x); // a copy of `x` is moved and dropped\ndrop(y); // a copy of `y` is moved and dropped\n\nprintln!(\"x: {}, y: {}\", x, y.0); // still available"]}}