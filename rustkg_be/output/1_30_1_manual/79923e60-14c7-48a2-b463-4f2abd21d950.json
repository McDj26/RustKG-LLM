{"stability":{"stable since":"1.0.0"},"apiName":"std::hash","apiType":"module","apiDocumentation":{"apiDescription":["Generic hashing support.","This module provides a generic way to compute the hash of a value. The simplest way to make a type hashable is to use #[derive(Hash)]:"],"examples":["use std::collections::hash_map::DefaultHasher;\nuse std::hash::{Hash, Hasher};\n\n#[derive(Hash)]\nstruct Person {\n    id: u32,\n    name: String,\n    phone: u64,\n}\n\nlet person1 = Person {\n    id: 5,\n    name: \"Janet\".to_string(),\n    phone: 555_666_7777,\n};\nlet person2 = Person {\n    id: 5,\n    name: \"Bob\".to_string(),\n    phone: 555_666_7777,\n};\n\nassert!(calculate_hash(&person1) != calculate_hash(&person2));\n\nfn calculate_hash<T: Hash>(t: &T) -> u64 {\n    let mut s = DefaultHasher::new();\n    t.hash(&mut s);\n    s.finish()\n}","If you need more control over how a value is hashed, you need to implement\nthe Hash trait:","use std::collections::hash_map::DefaultHasher;\nuse std::hash::{Hash, Hasher};\n\nstruct Person {\n    id: u32,\n    name: String,\n    phone: u64,\n}\n\nimpl Hash for Person {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        self.id.hash(state);\n        self.phone.hash(state);\n    }\n}\n\nlet person1 = Person {\n    id: 5,\n    name: \"Janet\".to_string(),\n    phone: 555_666_7777,\n};\nlet person2 = Person {\n    id: 5,\n    name: \"Bob\".to_string(),\n    phone: 555_666_7777,\n};\n\nassert_eq!(calculate_hash(&person1), calculate_hash(&person2));\n\nfn calculate_hash<T: Hash>(t: &T) -> u64 {\n    let mut s = DefaultHasher::new();\n    t.hash(&mut s);\n    s.finish()\n}"]},"children":["std::hash::BuildHasherDefault","std::hash::SipHasher","std::hash::BuildHasher","std::hash::Hash","std::hash::Hasher"]}