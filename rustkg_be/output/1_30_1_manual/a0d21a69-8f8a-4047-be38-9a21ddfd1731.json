{"stability":{"unstable":"ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"},"apiName":"std::sync::atomic::AtomicU64","apiType":"struct","apiDocumentation":{"apiDescription":["An integer type which can be safely shared between threads.","This type has the same in-memory representation as the underlying integer type, u64. For more about the differences between atomic types and non-atomic types, please see the module-level documentation."]},"trait implementations":[{"name":"impl std::fmt::Debug for std::sync::atomic::AtomicU64","stable since":"1.0.0"},{"name":"impl std::convert::From<u64> for std::sync::atomic::AtomicU64","stable since":"1.0.0"},{"name":"impl std::marker::Sync for std::sync::atomic::AtomicU64","stable since":"1.0.0"},{"name":"impl std::default::Default for std::sync::atomic::AtomicU64","stable since":"1.0.0"},{"name":"impl std::panic::RefUnwindSafe for std::sync::atomic::AtomicU64","stable since":"1.0.0"},{"name":"impl std::marker::Send for std::sync::atomic::AtomicU64","stable since":"1.0.0"}],"methods":[{"name":"pub const fn new(v: u64) -> AtomicU64","stability":["ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"]},{"name":"pub fn get_mut(&mut self) -> &mut u64","stability":["ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"]},{"name":"pub fn into_inner(self) -> u64","stability":["ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"]},{"name":"pub fn load(&self, order: Ordering) -> u64","stability":["ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"]},{"name":"pub fn store(&self, val: u64, order: Ordering)","stability":["ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"]},{"name":"pub fn swap(&self, val: u64, order: Ordering) -> u64","stability":["ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"]},{"name":"pub fn compare_and_swap(&self, current: u64, new: u64, order: Ordering) -> u64","stability":["ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"]},{"name":"pub fn compare_exchange( &self, current: u64, new: u64, success: Ordering, failure: Ordering) -> Result<u64, u64>","stability":["ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"]},{"name":"pub fn compare_exchange_weak( &self, current: u64, new: u64, success: Ordering, failure: Ordering) -> Result<u64, u64>","stability":["ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"]},{"name":"pub fn fetch_add(&self, val: u64, order: Ordering) -> u64","stability":["ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"]},{"name":"pub fn fetch_sub(&self, val: u64, order: Ordering) -> u64","stability":["ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"]},{"name":"pub fn fetch_and(&self, val: u64, order: Ordering) -> u64","stability":["ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"]},{"name":"pub fn fetch_nand(&self, val: u64, order: Ordering) -> u64","stability":["ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"]},{"name":"pub fn fetch_or(&self, val: u64, order: Ordering) -> u64","stability":["ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"]},{"name":"pub fn fetch_xor(&self, val: u64, order: Ordering) -> u64","stability":["ðŸ”¬ This is a nightly-only experimental API.  (integer_atomics #32976)"]},{"name":"pub fn fetch_update<F>( &self, f: F, fetch_order: Ordering, set_order: Ordering) -> Result<u64, u64> where F: FnMut(u64) -> Option<u64>","stability":["ðŸ”¬ This is a nightly-only experimental API.  (no_more_cas #48655)no more CAS loops in user code\n"]},{"name":"pub fn fetch_max(&self, val: u64, order: Ordering) -> u64","stability":["ðŸ”¬ This is a nightly-only experimental API.  (atomic_min_max #48655)easier and faster min/max than writing manual CAS loop\n"]},{"name":"pub fn fetch_min(&self, val: u64, order: Ordering) -> u64","stability":["ðŸ”¬ This is a nightly-only experimental API.  (atomic_min_max #48655)easier and faster min/max than writing manual CAS loop\n"]}]}