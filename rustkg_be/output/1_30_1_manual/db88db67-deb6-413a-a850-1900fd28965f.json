{"stability":{"stable since":"1.0.0"},"apiName":"char","apiType":"primitive","apiDocumentation":{"apiDescription":["A character type.","The char type represents a single character. More specifically, since 'character' isn't a well-defined concept in Unicode, char is a 'Unicode scalar value', which is similar to, but not the same as, a 'Unicode code point'.","This documentation describes a number of methods and trait implementations on the char type. For technical reasons, there is additional, separate documentation in the std::char module as well.","Representation","char is always four bytes in size. This is a different representation than a given character would have as part of a String. For example:","let v = vec!['h', 'e', 'l', 'l', 'o']; // five elements times four bytes for each element assert_eq!(20, v.len() * std::mem::size_of::<char>()); let s = String::from(\"hello\"); // five elements times one byte per element assert_eq!(5, s.len() * std::mem::size_of::<u8>());","As always, remember that a human intuition for 'character' may not map to Unicode's definitions. For example, despite looking similar, the '√©' character is one Unicode code point while '√©' is two Unicode code points:","let mut chars = \"√©\".chars(); // U+00e9: 'latin small letter e with acute' assert_eq!(Some('\\u{00e9}'), chars.next()); assert_eq!(None, chars.next()); let mut chars = \"eÃÅ\".chars(); // U+0065: 'latin small letter e' assert_eq!(Some('\\u{0065}'), chars.next()); // U+0301: 'combining acute accent' assert_eq!(Some('\\u{0301}'), chars.next()); assert_eq!(None, chars.next());","This means that the contents of the first string above will fit into a char while the contents of the second string will not. Trying to create a char literal with the contents of the second string gives an error:","error: character literal may only contain one codepoint: 'eÃÅ' let c = 'eÃÅ'; ^^^^","Another implication of the 4-byte fixed size of a char is that per-char processing can end up using a lot more memory:","let s = String::from(\"love: ‚ù§Ô∏è\"); let v: Vec<char> = s.chars().collect(); assert_eq!(12, s.len() * std::mem::size_of::<u8>()); assert_eq!(32, v.len() * std::mem::size_of::<char>());"]},"trait implementations":[{"name":"impl std::convert::TryFrom<u32> for char","stable since":"1.0.0"},{"name":"impl std::str::FromStr for char","stable since":"1.20.0"},{"name":"impl std::hash::Hash for char","stable since":"1.0.0"},{"name":"impl std::clone::Clone for char","stable since":"1.0.0"},{"name":"impl std::cmp::PartialOrd<char> for char","stable since":"1.0.0"},{"name":"impl std::cmp::Ord for char","stable since":"1.0.0"},{"name":"impl std::fmt::Debug for char","stable since":"1.0.0"},{"name":"impl std::cmp::Eq for char","stable since":"1.0.0"},{"name":"impl std::cmp::PartialEq<char> for char","stable since":"1.0.0"},{"name":"impl<'a> std::str::pattern::Pattern<'a> for char","stable since":"1.0.0"},{"name":"impl std::convert::From<u8> for char","stable since":"1.13.0"},{"name":"impl std::marker::Copy for char","stable since":"1.0.0"},{"name":"impl std::default::Default for char","stable since":"1.0.0"},{"name":"impl std::fmt::Display for char","stable since":"1.0.0"},{"name":"impl std::ascii::AsciiExt for char","stable since":"1.0.0"},{"name":"impl std::marker::Send for char","stable since":"1.0.0"},{"name":"impl std::marker::Sync for char","stable since":"1.0.0"}],"methods":[{"name":"pub fn is_digit(self, radix: u32) -> bool","details":{"description":["Checks if a char is a digit in the given radix.","A 'radix' here is sometimes also called a 'base'. A radix of two indicates a binary number, a radix of ten, decimal, and a radix of sixteen, hexadecimal, to give some common values. Arbitrary radices are supported.","Compared to is_numeric(), this function only recognizes the characters 0-9, a-z and A-Z.","'Digit' is defined to be only the following characters:","0-9 a-z A-Z","For a more comprehensive understanding of 'digit', see is_numeric.","Panics","Panics if given a radix larger than 36."],"example":["Basic usage:","assert!('1'.is_digit(10));\nassert!('f'.is_digit(16));\nassert!(!'f'.is_digit(10));","Passing a large radix, causing a panic:","use std::thread;\n\nlet result = thread::spawn(|| {\n    // this panics\n    '1'.is_digit(37);\n}).join();\n\nassert!(result.is_err());"]}},{"name":"pub fn to_digit(self, radix: u32) -> Option<u32>","details":{"description":["Converts a char to a digit in the given radix.","A 'radix' here is sometimes also called a 'base'. A radix of two indicates a binary number, a radix of ten, decimal, and a radix of sixteen, hexadecimal, to give some common values. Arbitrary radices are supported.","'Digit' is defined to be only the following characters:","0-9 a-z A-Z","Errors","Returns None if the char does not refer to a digit in the given radix.","Panics","Panics if given a radix larger than 36."],"example":["Basic usage:","assert_eq!('1'.to_digit(10), Some(1));\nassert_eq!('f'.to_digit(16), Some(15));","Passing a non-digit results in failure:","assert_eq!('f'.to_digit(10), None);\nassert_eq!('z'.to_digit(16), None);","Passing a large radix, causing a panic:","use std::thread;\n\nlet result = thread::spawn(|| {\n    '1'.to_digit(37);\n}).join();\n\nassert!(result.is_err());"]}},{"name":"pub fn escape_unicode(self) -> EscapeUnicode","details":{"description":["Returns an iterator that yields the hexadecimal Unicode escape of a character as chars.","This will escape characters with the Rust syntax of the form \\u{NNNNNN} where NNNNNN is a hexadecimal representation."],"example":["As an iterator:","for c in '‚ù§'.escape_unicode() {\n    print!(\"{}\", c);\n}\nprintln!();","Using println! directly:","println!(\"{}\", '‚ù§'.escape_unicode());","Both are equivalent to:","println!(\"\\\\u{{2764}}\");","Using to_string:","assert_eq!('‚ù§'.escape_unicode().to_string(), \"\\\\u{2764}\");"]}},{"name":"pub fn escape_debug(self) -> EscapeDebug","details":{"description":["Returns an iterator that yields the literal escape code of a character as chars.","This will escape the characters similar to the Debug implementations of str or char."],"example":["As an iterator:","for c in '\\n'.escape_debug() {\n    print!(\"{}\", c);\n}\nprintln!();","Using println! directly:","println!(\"{}\", '\\n'.escape_debug());","Both are equivalent to:","println!(\"\\\\n\");","Using to_string:","assert_eq!('\\n'.escape_debug().to_string(), \"\\\\n\");"]}},{"name":"pub fn escape_default(self) -> EscapeDefault","details":{"description":["Returns an iterator that yields the literal escape code of a character as chars.","The default is chosen with a bias toward producing literals that are legal in a variety of languages, including C++11 and similar C-family languages. The exact rules are:","Tab is escaped as \\t. Carriage return is escaped as \\r. Line feed is escaped as \\n. Single quote is escaped as \\'. Double quote is escaped as \\\". Backslash is escaped as \\\\. Any character in the 'printable ASCII' range 0x20 .. 0x7e inclusive is not escaped. All other characters are given hexadecimal Unicode escapes; see escape_unicode."],"example":["As an iterator:","for c in '\"'.escape_default() {\n    print!(\"{}\", c);\n}\nprintln!();","Using println! directly:","println!(\"{}\", '\"'.escape_default());","Both are equivalent to:","println!(\"\\\\\\\"\");","Using to_string:","assert_eq!('\"'.escape_default().to_string(), \"\\\\\\\"\");"]}},{"name":"pub fn len_utf8(self) -> usize","details":{"description":["Returns the number of bytes this char would need if encoded in UTF-8.","That number of bytes is always between 1 and 4, inclusive."],"example":["Basic usage:","let len = 'A'.len_utf8();\nassert_eq!(len, 1);\n\nlet len = '√ü'.len_utf8();\nassert_eq!(len, 2);\n\nlet len = '‚Ñù'.len_utf8();\nassert_eq!(len, 3);\n\nlet len = 'üí£'.len_utf8();\nassert_eq!(len, 4);","The &str type guarantees that its contents are UTF-8, and so we can compare the length it\nwould take if each code point was represented as a char vs in the &str itself:","// as chars\nlet eastern = 'Êù±';\nlet capitol = '‰∫¨';\n\n// both can be represented as three bytes\nassert_eq!(3, eastern.len_utf8());\nassert_eq!(3, capitol.len_utf8());\n\n// as a &str, these two are encoded in UTF-8\nlet tokyo = \"Êù±‰∫¨\";\n\nlet len = eastern.len_utf8() + capitol.len_utf8();\n\n// we can see that they take six bytes total...\nassert_eq!(6, tokyo.len());\n\n// ... just like the &str\nassert_eq!(len, tokyo.len());"]}},{"name":"pub fn len_utf16(self) -> usize","details":{"description":["Returns the number of 16-bit code units this char would need if encoded in UTF-16.","See the documentation for len_utf8 for more explanation of this concept. This function is a mirror, but for UTF-16 instead of UTF-8."],"example":["Basic usage:","let n = '√ü'.len_utf16();\nassert_eq!(n, 1);\n\nlet len = 'üí£'.len_utf16();\nassert_eq!(len, 2);"]}},{"name":"pub fn encode_utf8(self, dst: &mut [u8]) -> &mut str","details":{"description":["Encodes this character as UTF-8 into the provided byte buffer, and then returns the subslice of the buffer that contains the encoded character.","Panics","Panics if the buffer is not large enough. A buffer of length four is large enough to encode any char."],"example":["In both of these examples, '√ü' takes two bytes to encode.","let mut b = [0; 2];\n\nlet result = '√ü'.encode_utf8(&mut b);\n\nassert_eq!(result, \"√ü\");\n\nassert_eq!(result.len(), 2);","A buffer that's too small:","use std::thread;\n\nlet result = thread::spawn(|| {\n    let mut b = [0; 1];\n\n    // this panics\n   '√ü'.encode_utf8(&mut b);\n}).join();\n\nassert!(result.is_err());"]}},{"name":"pub fn encode_utf16(self, dst: &mut [u16]) -> &mut [u16]","details":{"description":["Encodes this character as UTF-16 into the provided u16 buffer, and then returns the subslice of the buffer that contains the encoded character.","Panics","Panics if the buffer is not large enough. A buffer of length 2 is large enough to encode any char."],"example":["In both of these examples, 'ùïä' takes two u16s to encode.","let mut b = [0; 2];\n\nlet result = 'ùïä'.encode_utf16(&mut b);\n\nassert_eq!(result.len(), 2);","A buffer that's too small:","use std::thread;\n\nlet result = thread::spawn(|| {\n    let mut b = [0; 1];\n\n    // this panics\n    'ùïä'.encode_utf16(&mut b);\n}).join();\n\nassert!(result.is_err());"]}},{"name":"pub fn is_alphabetic(self) -> bool","details":{"description":["Returns true if this char is an alphabetic code point, and false if not."],"example":["Basic usage:","assert!('a'.is_alphabetic());\nassert!('‰∫¨'.is_alphabetic());\n\nlet c = 'üíù';\n// love is many things, but it is not alphabetic\nassert!(!c.is_alphabetic());"]}},{"name":"pub fn is_xid_start(self) -> bool","stability":["üî¨ This is a nightly-only experimental API.  (rustc_private #27812)mainly needed for compiler internals\n"]},{"name":"pub fn is_xid_continue(self) -> bool","stability":["üî¨ This is a nightly-only experimental API.  (rustc_private #27812)mainly needed for compiler internals\n"]},{"name":"pub fn is_lowercase(self) -> bool","details":{"description":["Returns true if this char is lowercase, and false otherwise.","'Lowercase' is defined according to the terms of the Unicode Derived Core Property Lowercase."],"example":["Basic usage:","assert!('a'.is_lowercase());\nassert!('Œ¥'.is_lowercase());\nassert!(!'A'.is_lowercase());\nassert!(!'Œî'.is_lowercase());\n\n// The various Chinese scripts do not have case, and so:\nassert!(!'‰∏≠'.is_lowercase());"]}},{"name":"pub fn is_uppercase(self) -> bool","details":{"description":["Returns true if this char is uppercase, and false otherwise.","'Uppercase' is defined according to the terms of the Unicode Derived Core Property Uppercase."],"example":["Basic usage:","assert!(!'a'.is_uppercase());\nassert!(!'Œ¥'.is_uppercase());\nassert!('A'.is_uppercase());\nassert!('Œî'.is_uppercase());\n\n// The various Chinese scripts do not have case, and so:\nassert!(!'‰∏≠'.is_uppercase());"]}},{"name":"pub fn is_whitespace(self) -> bool","details":{"description":["Returns true if this char is whitespace, and false otherwise.","'Whitespace' is defined according to the terms of the Unicode Derived Core Property White_Space."],"example":["Basic usage:","assert!(' '.is_whitespace());\n\n// a non-breaking space\nassert!('\\u{A0}'.is_whitespace());\n\nassert!(!'Ë∂ä'.is_whitespace());"]}},{"name":"pub fn is_alphanumeric(self) -> bool","details":{"description":["Returns true if this char is alphanumeric, and false otherwise.","'Alphanumeric'-ness is defined in terms of the Unicode General Categories 'Nd', 'Nl', 'No' and the Derived Core Property 'Alphabetic'."],"example":["Basic usage:","assert!('Ÿ£'.is_alphanumeric());\nassert!('7'.is_alphanumeric());\nassert!('‡ß¨'.is_alphanumeric());\nassert!('¬æ'.is_alphanumeric());\nassert!('‚ë†'.is_alphanumeric());\nassert!('K'.is_alphanumeric());\nassert!('Ÿà'.is_alphanumeric());\nassert!('Ëóè'.is_alphanumeric());"]}},{"name":"pub fn is_control(self) -> bool","details":{"description":["Returns true if this char is a control code point, and false otherwise.","'Control code point' is defined in terms of the Unicode General Category Cc."],"example":["Basic usage:","// U+009C, STRING TERMINATOR\nassert!('¬ú'.is_control());\nassert!(!'q'.is_control());"]}},{"name":"pub fn is_numeric(self) -> bool","details":{"description":["Returns true if this char is numeric, and false otherwise.","'Numeric'-ness is defined in terms of the Unicode General Categories 'Nd', 'Nl', 'No'."],"example":["Basic usage:","assert!('Ÿ£'.is_numeric());\nassert!('7'.is_numeric());\nassert!('‡ß¨'.is_numeric());\nassert!('¬æ'.is_numeric());\nassert!('‚ë†'.is_numeric());\nassert!(!'K'.is_numeric());\nassert!(!'Ÿà'.is_numeric());\nassert!(!'Ëóè'.is_numeric());"]}},{"name":"pub fn to_lowercase(self) -> ToLowercase","details":{"description":["Returns an iterator that yields the lowercase equivalent of a char as one or more chars.","If a character does not have a lowercase equivalent, the same character will be returned back by the iterator.","This performs complex unconditional mappings with no tailoring: it maps one Unicode character to its lowercase equivalent according to the Unicode database and the additional complex mappings SpecialCasing.txt. Conditional mappings (based on context or language) are not considered here.","For a full reference, see here."],"example":["As an iterator:","for c in 'ƒ∞'.to_lowercase() {\n    print!(\"{}\", c);\n}\nprintln!();","Using println! directly:","println!(\"{}\", 'ƒ∞'.to_lowercase());","Both are equivalent to:","println!(\"i\\u{307}\");","Using to_string:","assert_eq!('C'.to_lowercase().to_string(), \"c\");\n\n// Sometimes the result is more than one character:\nassert_eq!('ƒ∞'.to_lowercase().to_string(), \"i\\u{307}\");\n\n// Characters that do not have both uppercase and lowercase\n// convert into themselves.\nassert_eq!('Â±±'.to_lowercase().to_string(), \"Â±±\");"]}},{"name":"pub fn to_uppercase(self) -> ToUppercase","details":{"description":["Returns an iterator that yields the uppercase equivalent of a char as one or more chars.","If a character does not have an uppercase equivalent, the same character will be returned back by the iterator.","This performs complex unconditional mappings with no tailoring: it maps one Unicode character to its uppercase equivalent according to the Unicode database and the additional complex mappings SpecialCasing.txt. Conditional mappings (based on context or language) are not considered here.","For a full reference, see here."],"example":["As an iterator:","for c in '√ü'.to_uppercase() {\n    print!(\"{}\", c);\n}\nprintln!();","Using println! directly:","println!(\"{}\", '√ü'.to_uppercase());","Both are equivalent to:","println!(\"SS\");","Using to_string:","assert_eq!('c'.to_uppercase().to_string(), \"C\");\n\n// Sometimes the result is more than one character:\nassert_eq!('√ü'.to_uppercase().to_string(), \"SS\");\n\n// Characters that do not have both uppercase and lowercase\n// convert into themselves.\nassert_eq!('Â±±'.to_uppercase().to_string(), \"Â±±\");","Note on locale","In Turkish, the equivalent of 'i' in Latin has five forms instead of two:","\n'Dotless': I / ƒ±, sometimes written √Ø\n'Dotted': ƒ∞ / i\n","Note that the lowercase dotted 'i' is the same as the Latin. Therefore:","let upper_i = 'i'.to_uppercase().to_string();","The value of upper_i here relies on the language of the text: if we're\nin en-US, it should be \"I\", but if we're in tr_TR, it should\nbe \"ƒ∞\". to_uppercase() does not take this into account, and so:","let upper_i = 'i'.to_uppercase().to_string();\n\nassert_eq!(upper_i, \"I\");","holds across languages."]}},{"name":"pub fn is_ascii(&self) -> bool","details":{"description":["Checks if the value is within the ASCII range."],"example":["let ascii = 'a';\nlet non_ascii = '‚ù§';\n\nassert!(ascii.is_ascii());\nassert!(!non_ascii.is_ascii());"]}},{"name":"pub fn to_ascii_uppercase(&self) -> char","details":{"description":["Makes a copy of the value in its ASCII upper case equivalent.","ASCII letters 'a' to 'z' are mapped to 'A' to 'Z', but non-ASCII letters are unchanged.","To uppercase the value in-place, use make_ascii_uppercase.","To uppercase ASCII characters in addition to non-ASCII characters, use to_uppercase."],"example":["let ascii = 'a';\nlet non_ascii = '‚ù§';\n\nassert_eq!('A', ascii.to_ascii_uppercase());\nassert_eq!('‚ù§', non_ascii.to_ascii_uppercase());"]}},{"name":"pub fn to_ascii_lowercase(&self) -> char","details":{"description":["Makes a copy of the value in its ASCII lower case equivalent.","ASCII letters 'A' to 'Z' are mapped to 'a' to 'z', but non-ASCII letters are unchanged.","To lowercase the value in-place, use make_ascii_lowercase.","To lowercase ASCII characters in addition to non-ASCII characters, use to_lowercase."],"example":["let ascii = 'A';\nlet non_ascii = '‚ù§';\n\nassert_eq!('a', ascii.to_ascii_lowercase());\nassert_eq!('‚ù§', non_ascii.to_ascii_lowercase());"]}},{"name":"pub fn eq_ignore_ascii_case(&self, other: &char) -> bool","details":{"description":["Checks that two values are an ASCII case-insensitive match.","Equivalent to to_ascii_lowercase(a) == to_ascii_lowercase(b)."],"example":["let upper_a = 'A';\nlet lower_a = 'a';\nlet lower_z = 'z';\n\nassert!(upper_a.eq_ignore_ascii_case(&lower_a));\nassert!(upper_a.eq_ignore_ascii_case(&upper_a));\nassert!(!upper_a.eq_ignore_ascii_case(&lower_z));"]}},{"name":"pub fn make_ascii_uppercase(&mut self)","details":{"description":["Converts this type to its ASCII upper case equivalent in-place.","ASCII letters 'a' to 'z' are mapped to 'A' to 'Z', but non-ASCII letters are unchanged.","To return a new uppercased value without modifying the existing one, use to_ascii_uppercase."],"example":["let mut ascii = 'a';\n\nascii.make_ascii_uppercase();\n\nassert_eq!('A', ascii);"]}},{"name":"pub fn make_ascii_lowercase(&mut self)","details":{"description":["Converts this type to its ASCII lower case equivalent in-place.","ASCII letters 'A' to 'Z' are mapped to 'a' to 'z', but non-ASCII letters are unchanged.","To return a new lowercased value without modifying the existing one, use to_ascii_lowercase."],"example":["let mut ascii = 'A';\n\nascii.make_ascii_lowercase();\n\nassert_eq!('a', ascii);"]}},{"name":"pub fn is_ascii_alphabetic(&self) -> bool","details":{"description":["Checks if the value is an ASCII alphabetic character:","U+0041 'A' ... U+005A 'Z', or U+0061 'a' ... U+007A 'z'."],"example":["let uppercase_a = 'A';\nlet uppercase_g = 'G';\nlet a = 'a';\nlet g = 'g';\nlet zero = '0';\nlet percent = '%';\nlet space = ' ';\nlet lf = '\\n';\nlet esc: char = 0x1b_u8.into();\n\nassert!(uppercase_a.is_ascii_alphabetic());\nassert!(uppercase_g.is_ascii_alphabetic());\nassert!(a.is_ascii_alphabetic());\nassert!(g.is_ascii_alphabetic());\nassert!(!zero.is_ascii_alphabetic());\nassert!(!percent.is_ascii_alphabetic());\nassert!(!space.is_ascii_alphabetic());\nassert!(!lf.is_ascii_alphabetic());\nassert!(!esc.is_ascii_alphabetic());"]}},{"name":"pub fn is_ascii_uppercase(&self) -> bool","details":{"description":["Checks if the value is an ASCII uppercase character: U+0041 'A' ... U+005A 'Z'."],"example":["let uppercase_a = 'A';\nlet uppercase_g = 'G';\nlet a = 'a';\nlet g = 'g';\nlet zero = '0';\nlet percent = '%';\nlet space = ' ';\nlet lf = '\\n';\nlet esc: char = 0x1b_u8.into();\n\nassert!(uppercase_a.is_ascii_uppercase());\nassert!(uppercase_g.is_ascii_uppercase());\nassert!(!a.is_ascii_uppercase());\nassert!(!g.is_ascii_uppercase());\nassert!(!zero.is_ascii_uppercase());\nassert!(!percent.is_ascii_uppercase());\nassert!(!space.is_ascii_uppercase());\nassert!(!lf.is_ascii_uppercase());\nassert!(!esc.is_ascii_uppercase());"]}},{"name":"pub fn is_ascii_lowercase(&self) -> bool","details":{"description":["Checks if the value is an ASCII lowercase character: U+0061 'a' ... U+007A 'z'."],"example":["let uppercase_a = 'A';\nlet uppercase_g = 'G';\nlet a = 'a';\nlet g = 'g';\nlet zero = '0';\nlet percent = '%';\nlet space = ' ';\nlet lf = '\\n';\nlet esc: char = 0x1b_u8.into();\n\nassert!(!uppercase_a.is_ascii_lowercase());\nassert!(!uppercase_g.is_ascii_lowercase());\nassert!(a.is_ascii_lowercase());\nassert!(g.is_ascii_lowercase());\nassert!(!zero.is_ascii_lowercase());\nassert!(!percent.is_ascii_lowercase());\nassert!(!space.is_ascii_lowercase());\nassert!(!lf.is_ascii_lowercase());\nassert!(!esc.is_ascii_lowercase());"]}},{"name":"pub fn is_ascii_alphanumeric(&self) -> bool","details":{"description":["Checks if the value is an ASCII alphanumeric character:","U+0041 'A' ... U+005A 'Z', or U+0061 'a' ... U+007A 'z', or U+0030 '0' ... U+0039 '9'."],"example":["let uppercase_a = 'A';\nlet uppercase_g = 'G';\nlet a = 'a';\nlet g = 'g';\nlet zero = '0';\nlet percent = '%';\nlet space = ' ';\nlet lf = '\\n';\nlet esc: char = 0x1b_u8.into();\n\nassert!(uppercase_a.is_ascii_alphanumeric());\nassert!(uppercase_g.is_ascii_alphanumeric());\nassert!(a.is_ascii_alphanumeric());\nassert!(g.is_ascii_alphanumeric());\nassert!(zero.is_ascii_alphanumeric());\nassert!(!percent.is_ascii_alphanumeric());\nassert!(!space.is_ascii_alphanumeric());\nassert!(!lf.is_ascii_alphanumeric());\nassert!(!esc.is_ascii_alphanumeric());"]}},{"name":"pub fn is_ascii_digit(&self) -> bool","details":{"description":["Checks if the value is an ASCII decimal digit: U+0030 '0' ... U+0039 '9'."],"example":["let uppercase_a = 'A';\nlet uppercase_g = 'G';\nlet a = 'a';\nlet g = 'g';\nlet zero = '0';\nlet percent = '%';\nlet space = ' ';\nlet lf = '\\n';\nlet esc: char = 0x1b_u8.into();\n\nassert!(!uppercase_a.is_ascii_digit());\nassert!(!uppercase_g.is_ascii_digit());\nassert!(!a.is_ascii_digit());\nassert!(!g.is_ascii_digit());\nassert!(zero.is_ascii_digit());\nassert!(!percent.is_ascii_digit());\nassert!(!space.is_ascii_digit());\nassert!(!lf.is_ascii_digit());\nassert!(!esc.is_ascii_digit());"]}},{"name":"pub fn is_ascii_hexdigit(&self) -> bool","details":{"description":["Checks if the value is an ASCII hexadecimal digit:","U+0030 '0' ... U+0039 '9', or U+0041 'A' ... U+0046 'F', or U+0061 'a' ... U+0066 'f'."],"example":["let uppercase_a = 'A';\nlet uppercase_g = 'G';\nlet a = 'a';\nlet g = 'g';\nlet zero = '0';\nlet percent = '%';\nlet space = ' ';\nlet lf = '\\n';\nlet esc: char = 0x1b_u8.into();\n\nassert!(uppercase_a.is_ascii_hexdigit());\nassert!(!uppercase_g.is_ascii_hexdigit());\nassert!(a.is_ascii_hexdigit());\nassert!(!g.is_ascii_hexdigit());\nassert!(zero.is_ascii_hexdigit());\nassert!(!percent.is_ascii_hexdigit());\nassert!(!space.is_ascii_hexdigit());\nassert!(!lf.is_ascii_hexdigit());\nassert!(!esc.is_ascii_hexdigit());"]}},{"name":"pub fn is_ascii_punctuation(&self) -> bool","details":{"description":["Checks if the value is an ASCII punctuation character:","U+0021 ... U+002F ! \" # $ % & ' ( ) * + , - . /, or U+003A ... U+0040 : ; < = > ? @, or U+005B ... U+0060 [ \\ ] ^ _ `, or U+007B ... U+007E { | } ~"],"example":["let uppercase_a = 'A';\nlet uppercase_g = 'G';\nlet a = 'a';\nlet g = 'g';\nlet zero = '0';\nlet percent = '%';\nlet space = ' ';\nlet lf = '\\n';\nlet esc: char = 0x1b_u8.into();\n\nassert!(!uppercase_a.is_ascii_punctuation());\nassert!(!uppercase_g.is_ascii_punctuation());\nassert!(!a.is_ascii_punctuation());\nassert!(!g.is_ascii_punctuation());\nassert!(!zero.is_ascii_punctuation());\nassert!(percent.is_ascii_punctuation());\nassert!(!space.is_ascii_punctuation());\nassert!(!lf.is_ascii_punctuation());\nassert!(!esc.is_ascii_punctuation());"]}},{"name":"pub fn is_ascii_graphic(&self) -> bool","details":{"description":["Checks if the value is an ASCII graphic character: U+0021 '!' ... U+007E '~'."],"example":["let uppercase_a = 'A';\nlet uppercase_g = 'G';\nlet a = 'a';\nlet g = 'g';\nlet zero = '0';\nlet percent = '%';\nlet space = ' ';\nlet lf = '\\n';\nlet esc: char = 0x1b_u8.into();\n\nassert!(uppercase_a.is_ascii_graphic());\nassert!(uppercase_g.is_ascii_graphic());\nassert!(a.is_ascii_graphic());\nassert!(g.is_ascii_graphic());\nassert!(zero.is_ascii_graphic());\nassert!(percent.is_ascii_graphic());\nassert!(!space.is_ascii_graphic());\nassert!(!lf.is_ascii_graphic());\nassert!(!esc.is_ascii_graphic());"]}},{"name":"pub fn is_ascii_whitespace(&self) -> bool","details":{"description":["Checks if the value is an ASCII whitespace character: U+0020 SPACE, U+0009 HORIZONTAL TAB, U+000A LINE FEED, U+000C FORM FEED, or U+000D CARRIAGE RETURN.","Rust uses the WhatWG Infra Standard's definition of ASCII whitespace. There are several other definitions in wide use. For instance, the POSIX locale includes U+000B VERTICAL TAB as well as all the above characters, but‚Äîfrom the very same specification‚Äîthe default rule for \"field splitting\" in the Bourne shell considers only SPACE, HORIZONTAL TAB, and LINE FEED as whitespace.","If you are writing a program that will process an existing file format, check what that format's definition of whitespace is before using this function."],"example":["let uppercase_a = 'A';\nlet uppercase_g = 'G';\nlet a = 'a';\nlet g = 'g';\nlet zero = '0';\nlet percent = '%';\nlet space = ' ';\nlet lf = '\\n';\nlet esc: char = 0x1b_u8.into();\n\nassert!(!uppercase_a.is_ascii_whitespace());\nassert!(!uppercase_g.is_ascii_whitespace());\nassert!(!a.is_ascii_whitespace());\nassert!(!g.is_ascii_whitespace());\nassert!(!zero.is_ascii_whitespace());\nassert!(!percent.is_ascii_whitespace());\nassert!(space.is_ascii_whitespace());\nassert!(lf.is_ascii_whitespace());\nassert!(!esc.is_ascii_whitespace());"]}},{"name":"pub fn is_ascii_control(&self) -> bool","details":{"description":["Checks if the value is an ASCII control character: U+0000 NUL ... U+001F UNIT SEPARATOR, or U+007F DELETE. Note that most ASCII whitespace characters are control characters, but SPACE is not."],"example":["let uppercase_a = 'A';\nlet uppercase_g = 'G';\nlet a = 'a';\nlet g = 'g';\nlet zero = '0';\nlet percent = '%';\nlet space = ' ';\nlet lf = '\\n';\nlet esc: char = 0x1b_u8.into();\n\nassert!(!uppercase_a.is_ascii_control());\nassert!(!uppercase_g.is_ascii_control());\nassert!(!a.is_ascii_control());\nassert!(!g.is_ascii_control());\nassert!(!zero.is_ascii_control());\nassert!(!percent.is_ascii_control());\nassert!(!space.is_ascii_control());\nassert!(lf.is_ascii_control());\nassert!(esc.is_ascii_control());"]}}]}