{"stability":{"unstable":"ðŸ”¬ This is a nightly-only experimental API.  (fnbox #28796)will be deprecated if and when Box<FnOnce> becomes usable\n"},"apiName":"std::boxed::FnBox","apiType":"trait","apiDocumentation":{"apiDescription":["FnBox is a version of the FnOnce intended for use with boxed closure objects. The idea is that where one would normally store a Box<FnOnce()> in a data structure, you should use Box<FnBox()>. The two traits behave essentially the same, except that a FnBox closure can only be called if it is boxed. (Note that FnBox may be deprecated in the future if Box<FnOnce()> closures become directly usable.)"],"examples":["Here is a snippet of code which creates a hashmap full of boxed\nonce closures and then removes them one by one, calling each\nclosure as it is removed. Note that the type of the closures\nstored in the map is Box<FnBox() -> i32> and not Box<FnOnce() -> i32>.","#![feature(fnbox)]\n\nuse std::boxed::FnBox;\nuse std::collections::HashMap;\n\nfn make_map() -> HashMap<i32, Box<FnBox() -> i32>> {\n    let mut map: HashMap<i32, Box<FnBox() -> i32>> = HashMap::new();\n    map.insert(1, Box::new(|| 22));\n    map.insert(2, Box::new(|| 44));\n    map\n}\n\nfn main() {\n    let mut map = make_map();\n    for i in &[1, 2] {\n        let f = map.remove(&i).unwrap();\n        assert_eq!(f(), i * 22);\n    }\n}"]},"trait required methods":[{"name":"fn call_box(self: Box<Self>, args: A) -> Self::Output","stability":["ðŸ”¬ This is a nightly-only experimental API.  (fnbox #28796)will be deprecated if and when Box<FnOnce> becomes usable\n"]}]}