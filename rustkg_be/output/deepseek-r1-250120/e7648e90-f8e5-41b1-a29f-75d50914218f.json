{"relations":["is a","has full name","stable since","is successor of","is predecessor of","has declaration","has attribute","has argument","has type","has return type","has description","has note","has safety","has example"],"relation_pairs":[["read_volatile","is a","Function"],["read_volatile","has full name","std::ptr::read_volatile"],["read_volatile","stable since","1.9.0"],["read_volatile","has declaration","pub unsafe fn read_volatile<T>(src: *const T) -> T"],["read_volatile","has attribute","unsafe"],["read_volatile","has argument","src"],["src","has type","*const T"],["read_volatile","has return type","T"],["read_volatile","has description","Performs a volatile read of the value from src without moving it. This leaves the memory in src unchanged."],["read_volatile","has description","Volatile operations are intended to act on I/O memory, and are guaranteed to not be elided or reordered by the compiler across other volatile operations."],["read_volatile","has note","Rust does not currently have a rigorously and formally defined memory model, so the precise semantics of what \"volatile\" means here is subject to change over time. That being said, the semantics will almost always end up pretty similar to C11's definition of volatile."],["read_volatile","has note","The compiler shouldn't change the relative order or number of volatile memory operations. However, volatile memory operations on zero-sized types (e.g. if a zero-sized type is passed to read_volatile) are no-ops and may be ignored."],["read_volatile","has safety","Beyond accepting a raw pointer, this is unsafe because it semantically moves the value out of src without preventing further usage of src. If T is not Copy, then care must be taken to ensure that the value at src is not used before the data is overwritten again (e.g. with write, write_bytes, or copy). Note that *src = foo counts as a use because it will attempt to drop the value previously at *src. Just like in C, whether an operation is volatile has no bearing whatsoever on questions involving concurrent access from multiple threads. Volatile accesses behave exactly like non-atomic accesses in that regard. In particular, a race between a read_volatile and any write operation to the same location is undefined behavior."],["read_volatile","has example","Basic usage: pub unsafe fn read_volatile<T>(src: *const T) -> T"]],"links":["../../src/core/ptr.rs.html","../index.html","index.html","http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"],"create_time":"2025-03-01T18:01:51.661Z","source_url":"file:///C:/Users/Dj/.rustup/toolchains/1.30-x86_64-pc-windows-msvc/share/doc/rust/html/std/ptr/fn.read_volatile.html","id":"e7648e90-f8e5-41b1-a29f-75d50914218f","model":"deepseek-r1-250120"}