{"relations":["is a","has full name","stable since","is successor of","is predecessor of","has attribute","has argument","has type","has return type","has description","has safety","has example"],"relation_pairs":[["read","is a","Function"],["read","has full name","std::ptr::read"],["read","stable since","1.0.0"],["read","has attribute","unsafe"],["read","has argument","src"],["src","has type","*const T"],["read","has return type","T"],["read","has description","Reads the value from src without moving it. This leaves the memory in src unchanged."],["read","has safety","Beyond accepting a raw pointer, this is unsafe because it semantically moves the value out of src without preventing further usage of src. If T is not Copy, then care must be taken to ensure that the value at src is not used before the data is overwritten again (e.g. with write, write_bytes, or copy). Note that *src = foo counts as a use because it will attempt to drop the value previously at *src. The pointer must be aligned; use read_unaligned if that is not the case."],["read","has example","Basic usage: pub unsafe fn read<T>(src: *const T) -> T"]],"links":["../index.html","index.html","../../src/core/ptr.rs.html"],"create_time":"2025-03-01T18:00:38.326Z","source_url":"file:///C:/Users/Dj/.rustup/toolchains/1.30-x86_64-pc-windows-msvc/share/doc/rust/html/std/ptr/fn.read.html","id":"64881398-aba0-4647-86d7-b3c4ab2cbd0f","model":"deepseek-r1-250120"}