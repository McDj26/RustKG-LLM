{"relations":["is a","has full name","stable since","is successor of","is predecessor of","has declaration","has description","has argument","has return type","implements","has stability","has attribute","requires method","has type"],"relation_pairs":[["RefCell","is a","Struct"],["RefCell","has full name","std::cell::RefCell"],["RefCell","stable since","1.0.0"],["RefCell","has declaration","pub struct RefCell<T> where T: ?Sized { /* fields omitted */ }"],["RefCell","has description","A mutable memory location with dynamically checked borrow rules"],["new","is a","function"],["new","has full name","std::cell::RefCell::new"],["new","has argument","value"],["new","has return type","RefCell<T>"],["new","has description","Creates a new RefCell containing value"],["into_inner","is a","function"],["into_inner","has full name","std::cell::RefCell::into_inner"],["into_inner","has return type","T"],["into_inner","has description","Consumes the RefCell, returning the wrapped value"],["replace","is a","function"],["replace","has full name","std::cell::RefCell::replace"],["replace","has argument","t"],["replace","has return type","T"],["replace","stable since","1.24.0"],["replace","has description","Replaces the wrapped value with a new one, returning the old value, without deinitializing either one"],["replace_with","is a","function"],["replace_with","has full name","std::cell::RefCell::replace_with"],["replace_with","has argument","f"],["replace_with","has return type","T"],["replace_with","has attribute","nightly-only experimental"],["swap","is a","function"],["swap","has full name","std::cell::RefCell::swap"],["swap","has argument","other"],["swap","stable since","1.24.0"],["swap","has description","Swaps the wrapped value of self with the wrapped value of other"],["borrow","is a","function"],["borrow","has full name","std::cell::RefCell::borrow"],["borrow","has return type","Ref<T>"],["borrow","has description","Immutably borrows the wrapped value"],["try_borrow","is a","function"],["try_borrow","has full name","std::cell::RefCell::try_borrow"],["try_borrow","has return type","Result<Ref<T>, BorrowError>"],["try_borrow","stable since","1.13.0"],["borrow_mut","is a","function"],["borrow_mut","has return type","RefMut<T>"],["borrow_mut","has description","Mutably borrows the wrapped value"],["try_borrow_mut","has return type","Result<RefMut<T>, BorrowMutError>"],["try_borrow_mut","stable since","1.13.0"],["as_ptr","stable since","1.12.0"],["as_ptr","has return type","*mut T"],["get_mut","has return type","&mut T"],["get_mut","stable since","1.11.0"],["RefCell","implements","Clone"],["RefCell","implements","PartialOrd"],["RefCell","implements","Ord"],["RefCell","implements","Debug"],["RefCell","implements","Eq"],["RefCell","implements","From<T>"],["RefCell","implements","Default"],["clone","has description","Panics if the value is currently mutably borrowed"],["PartialEq","has description","Panics if the value in either RefCell is currently borrowed"]],"links":["../index.html","index.html","../../std/cell/struct.RefCell.html","../../std/cell/struct.Ref.html","../../std/cell/struct.RefMut.html","../../std/result/enum.Result.html","../../std/cell/struct.BorrowError.html","../../std/cell/struct.BorrowMutError.html","../mem/fn.replace.html","../mem/fn.swap.html","../../std/clone/trait.Clone.html","../../std/cmp/trait.PartialOrd.html","../../std/cmp/trait.Ord.html","../../std/fmt/trait.Debug.html","../../std/cmp/trait.Eq.html","../../std/convert/trait.From.html","../../std/default/trait.Default.html","../../src/core/cell.rs.html"],"create_time":"2025-03-01T18:05:21.325Z","source_url":"file:///C:/Users/Dj/.rustup/toolchains/1.30-x86_64-pc-windows-msvc/share/doc/rust/html/std/cell/struct.RefCell.html","id":"ec27c5e4-dcd5-44ba-8db7-d6b132a55981","model":"deepseek-r1-250120"}