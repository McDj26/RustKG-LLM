{"relations":["is a","has full name","stable since","has attribute","has argument","has type","has description","has note","has safety","has example"],"relation_pairs":[["write_volatile","is a","Function"],["write_volatile","has full name","std::ptr::write_volatile"],["write_volatile","stable since","1.9.0"],["write_volatile","has attribute","unsafe"],["write_volatile","has argument","dst"],["write_volatile","has argument","src"],["dst","has type","*mut T"],["src","has type","T"],["write_volatile","has description","Performs a volatile write of a memory location with the given value without reading or dropping the old value."],["write_volatile","has description","Volatile operations are intended to act on I/O memory, and are guaranteed to not be elided or reordered by the compiler across other volatile operations."],["write_volatile","has note","Rust does not currently have a rigorously and formally defined memory model, so the precise semantics of what \"volatile\" means here is subject to change over time. That being said, the semantics will almost always end up pretty similar to C11's definition of volatile."],["write_volatile","has note","The compiler shouldn't change the relative order or number of volatile memory operations. However, volatile memory operations on zero-sized types (e.g. if a zero-sized type is passed to write_volatile) are no-ops and may be ignored."],["write_volatile","has safety","This operation is marked unsafe because it accepts a raw pointer."],["write_volatile","has safety","It does not drop the contents of dst. This is safe, but it could leak allocations or resources, so care must be taken not to overwrite an object that should be dropped."],["write_volatile","has safety","This is appropriate for initializing uninitialized memory, or overwriting memory that has previously been read from."],["write_volatile","has safety","Just like in C, whether an operation is volatile has no bearing whatsoever on questions involving concurrent access from multiple threads. Volatile accesses behave exactly like non-atomic accesses in that regard. In particular, a race between a write_volatile and any other operation (reading or writing) on the same location is undefined behavior."],["write_volatile","has example","Basic usage:"],["write_volatile","has example","pub unsafe fn write_volatile<T>(dst: *mut T, src: T)"]],"links":["../../src/core/ptr.rs.html","../index.html","index.html","http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"],"create_time":"2025-03-01T18:03:57.542Z","source_url":"file:///C:/Users/Dj/.rustup/toolchains/1.30-x86_64-pc-windows-msvc/share/doc/rust/html/std/ptr/fn.write_volatile.html","id":"de2903ce-779d-4c7a-8f68-fe7f01c58b9f","model":"deepseek-r1-250120"}