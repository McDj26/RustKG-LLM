{"relations":["is a","has full name","stable since","has attribute","has declaration","has argument","has type","has return type","has description","has calling convention"],"relation pairs":[["transmute","is a","Function"],["transmute","has full name","std::mem::transmute"],["transmute","stable since","1.0.0"],["transmute","has attribute","unsafe"],["transmute","has declaration","pub unsafe extern \"rust-intrinsic\" fn transmute<T, U>(e: T) -> U"],["transmute","has calling convention","rust-intrinsic"],["transmute","has argument","e"],["e","has type","T"],["transmute","has return type","U"],["transmute","has description","Reinterprets the bits of a value of one type as another type. Both types must have the same size. Neither the original, nor the result, may be an invalid value. transmute is semantically equivalent to a bitwise move of one type into another. It copies the bits from the source value into the destination value, then forgets the original. It's equivalent to C's memcpy under the hood, just like transmute_copy. transmute is incredibly unsafe. There are a vast number of ways to cause undefined behavior with this function. transmute should be the absolute last resort."]],"links":["../../src/core/intrinsics.rs.html","../index.html","index.html","../../nomicon/what-unsafe-does.html","../../reference/behavior-considered-undefined.html","../../nomicon/transmutes.html"],"create_time":"2025-03-01T17:24:00.644Z","source_url":"file:///C:/Users/Dj/.rustup/toolchains/1.30-x86_64-pc-windows-msvc/share/doc/rust/html/std/mem/fn.transmute.html","id":"50f7c233-48fc-4aee-98f8-a4c5f6cf4d0d","model":"deepseek-r1-250120"}