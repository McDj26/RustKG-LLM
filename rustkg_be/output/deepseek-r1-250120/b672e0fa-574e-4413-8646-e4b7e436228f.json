{"relations":["is a","has full name","stable since","is successor of","is predecessor of","has declaration","has attribute","has argument","has type","has return type","has description","has safety","has example"],"relation pairs":[["read_unaligned","is a","Function"],["read_unaligned","has full name","std::ptr::read_unaligned"],["read_unaligned","stable since","1.17.0"],["read_unaligned","has declaration","pub unsafe fn read_unaligned<T>(src: *const T) -> T"],["read_unaligned","has attribute","unsafe"],["read_unaligned","has argument","src"],["src","has type","*const T"],["read_unaligned","has return type","T"],["read_unaligned","has description","Reads the value from src without moving it. This leaves the memory in src unchanged. Unlike read, the pointer may be unaligned."],["read_unaligned","has safety","Beyond accepting a raw pointer, this is unsafe because it semantically moves the value out of src without preventing further usage of src. If T is not Copy, then care must be taken to ensure that the value at src is not used before the data is overwritten again (e.g. with write, write_bytes, or copy). Note that *src = foo counts as a use because it will attempt to drop the value previously at *src."],["read_unaligned","has example","pub unsafe fn read_unaligned<T>(src: *const T) -> T"]],"links":["../index.html","index.html","../../src/core/ptr.rs.html"],"create_time":"2025-03-01T17:59:29.034Z","source_url":"file:///C:/Users/Dj/.rustup/toolchains/1.30-x86_64-pc-windows-msvc/share/doc/rust/html/std/ptr/fn.read_unaligned.html","id":"b672e0fa-574e-4413-8646-e4b7e436228f","model":"deepseek-r1-250120"}