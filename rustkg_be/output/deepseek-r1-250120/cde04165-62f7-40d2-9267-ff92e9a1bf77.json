{"relations":["is a","has full name","stable since","is successor of","is predecessor of","has declaration","has stability","requires method","has description","has argument","has return type","implements","has associated type","has attribute","has type constraint","has Target type"],"relation pairs":[["Deref","is a","Trait"],["Deref","has full name","std::ops::Deref"],["Deref","stable since","1.0.0"],["Deref","has declaration","pub trait Deref { #[lang = \"deref\"] type Target: ?Sized; #[must_use] fn deref(&self) -> &Self::Target; }"],["Deref","has description","Used for immutable dereferencing operations, like *v."],["Deref","has description","In addition to being used for explicit dereferencing operations with the (unary) * operator in immutable contexts, Deref is also used implicitly by the compiler in many circumstances. This mechanism is called 'Deref coercion'. In mutable contexts, DerefMut is used."],["Deref","has description","Implementing Deref for smart pointers makes accessing the data behind them convenient, which is why they implement Deref. On the other hand, the rules regarding Deref and DerefMut were designed specifically to accommodate smart pointers. Because of this, Deref should only be implemented for smart pointers to avoid confusion."],["Deref","has description","For similar reasons, this trait should never fail. Failure during dereferencing can be extremely confusing when Deref is invoked implicitly."],["Deref","has associated type","Target"],["Deref::Target","has description","The resulting type after dereferencing."],["Deref::Target","has type constraint","?Sized"],["deref","is a","function"],["deref","has return type","&Self::Target"],["deref","has attribute","must_use"],["deref","has description","Dereferences the value."],["Deref","requires method","deref"],["deref","has argument","&self"],["CString","implements","Deref"],["CString","has Target type","CStr"],["OsString","implements","Deref"],["OsString","has Target type","OsStr"],["PathBuf","implements","Deref"],["PathBuf","has Target type","Path"],["String","implements","Deref"],["String","has Target type","str"],["Cow<'a, B>","implements","Deref"],["Cow<'a, B>","has Target type","B"],["&'a T","implements","Deref"],["&'a T","has Target type","T"],["&'a mut T","implements","Deref"],["&'a mut T","has Target type","T"],["Box<T>","implements","Deref"],["Box<T>","has Target type","T"],["Rc<T>","implements","Deref"],["Rc<T>","has Target type","T"],["Arc<T>","implements","Deref"],["Arc<T>","has Target type","T"]],"links":["../../src/core/ops/deref.rs.html","../../src/std/ffi/c_str.rs.html","../../src/std/ffi/os_str.rs.html","../../src/std/path.rs.html","../../src/alloc/string.rs.html","../../src/alloc/borrow.rs.html","../../src/alloc/collections/binary_heap.rs.html","../../src/core/pin.rs.html","../../src/core/cell.rs.html","../../src/std/sync/mutex.rs.html","../../src/std/sync/rwlock.rs.html","../../src/alloc/boxed.rs.html","../../src/alloc/rc.rs.html","../../src/alloc/sync.rs.html","../../src/alloc/vec.rs.html","struct.CString.html","struct.OsString.html","struct.PathBuf.html","struct.String.html","enum.Cow.html","trait.DerefMut.html","../../../primitive.u32.html","../../book/second-edition/ch15-02-deref.html","../../reference/expressions/operator-expr.html","../../reference/expressions/method-call-expr.html","../../reference/type-coercions.html"],"create_time":"2025-03-01T18:07:54.278Z","source_url":"file:///C:/Users/Dj/.rustup/toolchains/1.30-x86_64-pc-windows-msvc/share/doc/rust/html/std/ops/trait.Deref.html","id":"cde04165-62f7-40d2-9267-ff92e9a1bf77","model":"deepseek-r1-250120"}