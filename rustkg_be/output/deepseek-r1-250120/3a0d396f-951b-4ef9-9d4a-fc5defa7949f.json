{"relations":["is a","has full name","stable since","is successor of","is predecessor of","has declaration","has stability","has description","implements","requires","has source"],"relation_pairs":[["CoerceUnsized","is a","Trait"],["CoerceUnsized","has full name","std::ops::CoerceUnsized"],["CoerceUnsized","has declaration","pub trait CoerceUnsized<T> { }"],["CoerceUnsized","has stability","This is a nightly-only experimental API. (coerce_unsized #27732)"],["CoerceUnsized","has description","Trait that indicates that this is a pointer or a wrapper for one, where unsizing can be performed on the pointee. See the DST coercion RFC and the nomicon entry on coercion for more details. For builtin pointer types, pointers to T will coerce to pointers to U if T: Unsize<U> by converting from a thin pointer to a fat pointer. For custom types, the coercion here works by coercing Foo<T> to Foo<U> provided an impl of CoerceUnsized<Foo<U>> for Foo<T> exists. Such an impl can only be written if Foo<T> has only a single non-phantomdata field involving T. If the type of that field is Bar<T>, an implementation of CoerceUnsized<Bar<U>> for Bar<T> must exist. The coercion will work by coercing the Bar<T> field into Bar<U> and filling in the rest of the fields from Foo<T> to create a Foo<U>. This will effectively drill down to a pointer field and coerce that. Generally, for smart pointers you will implement CoerceUnsized<Ptr<U>> for Ptr<T> where T: Unsize<U>, U: ?Sized, with an optional ?Sized bound on T itself. For wrapper types that directly embed T like Cell<T> and RefCell<T>, you can directly implement CoerceUnsized<Wrap<U>> for Wrap<T> where T: CoerceUnsized<U>. This will let coercions of types like Cell<Box<T>> work. Unsize is used to mark types which can be coerced to DSTs if behind pointers. It is implemented automatically by the compiler."],["CoerceUnsized","requires","Unsize"],["&'b T","implements","CoerceUnsized<&'a U>"],["&'b mut T","implements","CoerceUnsized<&'a U>"],["&'a mut T","implements","CoerceUnsized<*mut U>"],["&'a mut T","implements","CoerceUnsized<&'a mut U>"],["PinMut<'a, T>","implements","CoerceUnsized<PinMut<'a, U>>"],["Ref<'b, T>","implements","CoerceUnsized<Ref<'b, U>>"],["RefMut<'b, T>","implements","CoerceUnsized<RefMut<'b, U>>"],["*const T","implements","CoerceUnsized<*const U>"],["*mut T","implements","CoerceUnsized<*const U>"],["*mut T","implements","CoerceUnsized<*mut U>"],["Box<T>","implements","CoerceUnsized<Box<U>>"],["Cell<T>","implements","CoerceUnsized<Cell<U>>"],["RefCell<T>","implements","CoerceUnsized<RefCell<U>>"],["UnsafeCell<T>","implements","CoerceUnsized<UnsafeCell<U>>"],["PinBox<T>","implements","CoerceUnsized<PinBox<U>>"],["NonNull<T>","implements","CoerceUnsized<NonNull<U>>"],["Rc<T>","implements","CoerceUnsized<Rc<U>>"],["Weak<T>","implements","CoerceUnsized<Weak<U>>"],["Arc<T>","implements","CoerceUnsized<Arc<U>>"]],"links":["../../std/index.html","../../src/core/ops/unsize.rs.html","../marker/trait.Unsize.html","../../std/pin/struct.PinMut.html","../../std/cell/struct.Ref.html","../../std/cell/struct.RefMut.html","../../std/cell/struct.Cell.html","../../std/cell/struct.RefCell.html","../../std/cell/struct.UnsafeCell.html","../../std/boxed/struct.Box.html","../../std/rc/struct.Rc.html","../../std/rc/struct.Weak.html","../../std/sync/struct.Arc.html","../../std/sync/struct.Weak.html","../../alloc/pin/struct.PinBox.html","../../std/ptr/struct.NonNull.html"],"create_time":"2025-03-02T04:47:36.771Z","source_url":"file:///C:/Users/Dj/.rustup/toolchains/1.30-x86_64-pc-windows-msvc/share/doc/rust/html/std/ops/trait.CoerceUnsized.html","id":"3a0d396f-951b-4ef9-9d4a-fc5defa7949f","model":"deepseek-r1-250120"}