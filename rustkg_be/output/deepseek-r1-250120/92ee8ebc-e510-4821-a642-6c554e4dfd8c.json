{"relations":["is a","has full name","stable since","is successor of","is predecessor of","has attribute","has declaration","has argument","has type","equivalent to","has description","has safety"],"relation_pairs":[["copy_nonoverlapping","is a","Function"],["copy_nonoverlapping","has full name","std::ptr::copy_nonoverlapping"],["copy_nonoverlapping","stable since","1.0.0"],["copy_nonoverlapping","has attribute","unsafe"],["copy_nonoverlapping","has declaration","pub unsafe extern \"rust-intrinsic\" fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize)"],["copy_nonoverlapping","has argument","copy_nonoverlapping::src"],["copy_nonoverlapping","has argument","copy_nonoverlapping::dst"],["copy_nonoverlapping","has argument","copy_nonoverlapping::count"],["copy_nonoverlapping::src","has type","*const T"],["copy_nonoverlapping::dst","has type","*mut T"],["copy_nonoverlapping::count","has type","usize"],["copy_nonoverlapping","has description","Copies count * size_of<T> bytes from src to dst. The source and destination may not overlap."],["copy_nonoverlapping","equivalent to","memcpy"],["copy_nonoverlapping","has safety","Beyond requiring that the program must be allowed to access both regions of memory, it is Undefined Behavior for source and destination to overlap. Care must also be taken with the ownership of src and dst. This method semantically moves the values of src into dst. However it does not drop the contents of dst, or prevent the contents of src from being dropped or used."]],"links":["../../src/core/intrinsics.rs.html","../index.html","index.html"],"create_time":"2025-03-01T18:00:12.101Z","source_url":"file:///C:/Users/Dj/.rustup/toolchains/1.30-x86_64-pc-windows-msvc/share/doc/rust/html/std/ptr/fn.copy_nonoverlapping.html","id":"92ee8ebc-e510-4821-a642-6c554e4dfd8c","model":"deepseek-r1-250120"}